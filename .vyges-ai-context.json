{
  "vyges_version": "1.0.0",
  "ai_context_version": "1.0.0",
  "description": "Defines structural, naming, and workflow conventions to guide AI-assisted hardware IP development within the Vyges platform. Enables consistent code generation, validation, and integration.",
  "copyright": "Â© 2025 Vyges. All Rights Reserved",
  "author": "shivaram@vyges.com",
  
  "date_guidance": "All new or updated metadata should use the actual current UTC date/time (in ISO 8601 format) for 'created', 'updated', and 'generated_at' fields. This includes metadata JSON files if they are updated. Avoid hardcoded dates from the past. Update copyright year annually.",
  
  "git_commit_guidance": "For Git commit messages, don't use double quotes as the command line version will reject the message. Use single quotes or no quotes instead.",
  
  "critical_ai_instructions": {
    "description": "CRITICAL instructions that must ALWAYS be followed when generating code, documents, or metadata",
    "date_handling": {
      "rule": "ALWAYS use the `date` command to get the current date/time",
      "command": "date -u +%Y-%m-%dT%H:%M:%SZ",
      "usage": "Use this command to get current UTC date/time in ISO 8601 format for all 'created', 'updated', and 'generated_at' fields",
      "prohibition": "NEVER use pattern matching based on existing files in the current repo for dates",
      "examples": [
        "metadata.json: 'created': '$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
        "documentation: 'Last updated: $(date -u +%Y-%m-%d)'",
        "commit messages: 'Updated on $(date -u +%Y-%m-%d)'"
      ]
    },
    "repository_name_detection": {
      "rule": "ALWAYS use `git rev-parse --show-toplevel` to get the correct repository name",
      "command": "basename $(git rev-parse --show-toplevel)",
      "usage": "Use this command to get the correct repo name for IP block names, metadata files, and documentation",
      "importance": "This is critical as the same name gets into generated metadata files, documentation, and other artifacts",
      "prohibition": "NEVER guess or use hardcoded repository names",
      "examples": [
        "IP block name: Use repo name from git rev-parse",
        "Metadata files: Use repo name for file naming",
        "Documentation: Use repo name in headers and titles"
      ]
    },
    "context_file_protection": {
      "rule": "NEVER update .vyges-ai-context.json file in any repository unless explicitly asked to do so",
      "prohibition": "Do not modify, update, or regenerate .vyges-ai-context.json files",
      "exception": "Only update when user explicitly requests: 'Update .vyges-ai-context.json' or similar",
      "reason": "This file contains critical configuration and should only be changed intentionally"
    },
    "enforcement": "These rules are MANDATORY and must be followed in ALL code generation, documentation creation, and metadata updates"
  },
  
  "catalog_objectives": {
    "description": "Ensure generated IP meets requirements for inclusion in the Vyges IP Catalog",
    "requirements": [
      "vyges-metadata.json is complete and conforms to schema",
      "Includes license, maturity, and interface metadata",
      "Includes testbench with pass/fail assertion",
      "Includes minimum documentation in docs/overview.md",
      "Must include basic functional verification (simulation or cocotb)",
      "Supports versioning and reproducibility via source tracking"
    ],
    "ai_assist_prompts": {
      "generate_catalog_ready_ip": "Create a SystemVerilog IP block that is ready for the Vyges Catalog. Include complete metadata, documentation, and testbench.",
      "check_catalog_readiness": "Validate the IP block for Vyges Catalog readiness: metadata coverage, testability, and discoverability."
    }
  },

  "catalog_context": {
    "purpose": "Support Vyges IP Catalog operations and discoverability",
    "fields": {
      "name": "IP package name with org/user prefix",
      "version": "IP version following semantic versioning",
      "interfaces": "Signals and protocols exposed by the IP",
      "target": "asic/fpga target platforms",
      "design_type": "digital|analog|mixed-signal design type",
      "toolchain_support": "validated tools and flows",
      "tags": "discovery tags for catalog search",
      "trust_profile": "security indicators and maturity level",
      "maturity": "alpha|beta|stable|deprecated maturity status",
      "license": "SPDX license identifier",
      "maintainers": "contact information for IP maintainers",
      "chiplet_ready": "boolean indicating if IP is designed for chiplet integration",
      "integration_level": "rtl|netlist|hard_ip indicating integration abstraction level",
      "packaging_considerations": "notes about physical packaging requirements",
      "die_to_die_interfaces": "list of supported die-to-die interface protocols",
      "interposer_constraints": "interposer technology, routing layers, pitch, die spacing",
      "bump_constraints": "bump pitch, size, array configuration, power/signal counts",
      "thermal_constraints": "power limits, junction temperature, thermal resistance, cooling",
      "multi_die_testing": "test access methods, coverage requirements, test vectors",
      "signal_conformance": "protocol compliance, verification tools, test suites",
      "power_domains": "voltage, isolation, retention, current limits per domain",
      "lifecycle": "origin, trusted fabricator, certifications, supply chain tracking"
    },
    "ai_prompts": {
      "generate_catalog_entry": "Generate a catalog-ready summary with name, version, description, interfaces, targets, tags, and trust indicators for the Vyges IP Catalog.",
      "catalog_search_query": "Given IP metadata, suggest effective search keywords and tags to improve discoverability in the Vyges IP Catalog.",
      "improve_catalog_presentation": "Enhance IP metadata for better catalog presentation: improve description, add relevant tags, optimize discoverability.",
      "validate_catalog_compliance": "Check IP metadata for Vyges Catalog compliance: required fields, format validation, and completeness."
    },
    "discoverability_features": {
      "tags": "Generate relevant tags for IP discovery (e.g., uart, communication, apb, asic, fpga)",
      "keywords": "Extract search keywords from IP description and interfaces",
      "categories": "Suggest appropriate catalog categories based on IP type and interfaces",
      "related_ips": "Identify related IPs in the catalog based on interfaces and functionality"
    }
  },

  "template_integration": {
    "mode": "hybrid",
    "description": "Use codegen + AI to scaffold IP repos: template + AI phase optimize for maximum developer productivity",
    "ai_prompts": {
      "bootstrap_project": "Generate directory structure and basic RTL/test files based on metadata using the vyges-ip-template as base.",
      "customize_template": "Customize the vyges-ip-template structure for specific IP requirements and target platforms.",
      "expand_template": "Expand the minimal template structure with additional directories and files based on IP complexity.",
      "optimize_structure": "Optimize project structure for the specific IP type, interfaces, and target platforms."
    },
    "workflow": {
      "start_with_template": "Begin with vyges-ip-template as the foundation",
      "ai_customization": "Use AI to customize structure and generate initial files",
      "progressive_expansion": "Expand complexity using vyges expand commands",
      "metadata_driven": "Use vyges-metadata.json to guide all customizations"
    },
    "benefits": [
      "Reduces cognitive load and setup time",
      "Ensures consistency with Vyges conventions",
      "Enables rapid prototyping and iteration",
      "Supports both simple and complex IP development"
    ]
  },
  
  "metadata_driven_generation": {
    "description": "Use vyges-metadata.json as canonical source of truth for generating specifications and code",
    "capabilities": {
      "specification_generation": {
        "input": "vyges-metadata.json fields (name, description, parameters, interfaces, target, design_type, toolRequirements, flows, test, performance)",
        "output": "docs/specification.md - Human-readable requirements document",
        "template_sections": [
          "Overview",
          "Target (ASIC/FPGA)",
          "Interfaces",
          "Parameters",
          "Tool Requirements",
          "Testing"
        ]
      },
      "design_document_generation": {
        "input": "vyges-metadata.json with comprehensive IP specifications",
        "output": "docs/{IP_NAME}_design_spec.md - Complete design specification document",
        "template_sections": [
          "Project Metadata",
          "Design Flow",
          "Functional Requirements",
          "Interface Design",
          "Register Map",
          "Timing Specifications",
          "Pinout and Package",
          "Validation Strategy",
          "RTL and Testbench Development",
          "Flow Configuration",
          "Documentation Requirements",
          "Testing and Verification",
          "Integration Guidelines",
          "CI/CD Pipeline",
          "Catalog Publication"
        ],
        "quality_requirements": {
          "completeness": "All sections must be populated with relevant information",
          "consistency": "Interface definitions must match vyges-metadata.json",
          "traceability": "Requirements must be traceable to implementation",
          "validation": "Include validation criteria and test strategies",
          "visual_aids": "Include ASCII diagrams for block representation and connections"
        }
      },
      "code_generation": {
        "rtl_scaffolding": "Generate RTL modules in rtl/*.sv based on interfaces and parameters",
        "testbench_generation": "Create testbenches in SystemVerilog or Python (cocotb) based on test specifications",
        "flow_configuration": "Generate tool configurations in flow/ based on toolRequirements",
        "documentation": "Generate README, LICENSE, and integration scripts",
        "metadata_annotation": "Annotate RTL with metadata comments based on vyges-metadata.json",
        "verification_targets": "Embed assertions and coverage based on test block specifications"
      }
    },
    "ai_assist_prompts": {
      "generate_from_metadata": "Generate complete IP specification and code scaffolding from vyges-metadata.json",
      "generate_design_document": "Generate comprehensive design specification document following Vyges conventions with all required sections, quality requirements, and visual aids",
      "update_metadata_from_code": "Update vyges-metadata.json based on changes in RTL code and interfaces",
      "synchronize_metadata_code": "Ensure vyges-metadata.json and generated code are in sync"
    },
    "branding_guidance": "Always include a 'branding' property at the top level of vyges-metadata.json. Example: 'branding': { 'provider': 'Vyges', 'logo': 'https://vyges.com/images/logo.svg', 'website': 'https://vyges.com/catalog', 'usage': 'Use of the logo is permitted for attribution or compatibility references only.' }. This ensures catalog and UI consistency and enables robust provider branding.",
    "notes": "The pinout table in documentation and README should be auto-generated from the interfaces section of vyges-metadata.json for consistency."
  },
  
  "project_structure": {
    "conventions": {
      "naming": {
        "repository": "{orgname}/{repo-name} or {username}/{repo-name} (e.g., vyges/uart-controller, janedoe/pwm-generator)",
        "repository_workflow": {
          "step1": "Create new repository using GitHub 'Use this template' button from vyges-ip-template",
          "step2": "Clone the newly created repository (not the template repository)",
          "step3": "Use Vyges CLI to initialize the project in current directory",
          "warning": "Ensure Git remote points to new repository, not template repository",
          "fix_command": "git remote remove origin && git remote add origin https://github.com/{org}/{repo}.git",
          "cli_fix": "Use 'vyges init --fix-remote' or 'vyges quickstart --fix-remote' to automatically remove template remote",
          "functional_ip_principle": "Each repository represents one functional IP in the catalog (e.g., uart-controller contains UART Master, FIFO, and other components as one functional unit)"
        },
        "ip_name": "lowercase with hyphens/underscores, 3-50 chars, start with letter, no consecutive hyphens/underscores",
        "modules": "snake_case (e.g., pwm_controller, uart_transmitter)",
        "files": "snake_case.sv (e.g., pwm_controller.sv, uart_transmitter.sv)",
        "testbenches": "tb_<module_name>.sv (e.g., tb_pwm_controller.sv)",
        "parameters": "UPPER_SNAKE_CASE (e.g., CLOCK_FREQUENCY, DATA_WIDTH)",
        "signals": "snake_case (e.g., clock_i, data_o, enable_n)"
      },
      "organization": {
        "rtl_files": "Place all RTL modules in rtl/ directory",
        "testbench_files": "Place all testbenches in tb/ directory",
        "test_files": "Place test vectors and coverage in test/ directory",
        "documentation": "Place all docs in docs/ directory",
        "flow_configs": "Place tool configurations in flow/ directory",
        "simulation_files": "Place simulation scripts and Makefiles under sim/",
        "constraints": "Place synthesis/implementation constraints (e.g., SDC, XDC) in constraints/"
      },
      "advanced_patterns": {
        "multi_platform": "For projects targeting both ASIC and FPGA, or including analog/mixed-signal, create subdirectories under rtl/, flow/, and constraints/ for asic/, fpga/, digital/, analog/, etc. The CLI should offer to expand the structure as needed.",
                  "directory_expansion": {
            "rtl": {
              "asic": "ASIC-specific RTL (digital and analog)",
              "fpga": "FPGA-specific RTL (digital only)",
              "digital": "Digital RTL (platform-agnostic)",
              "analog": "Analog/mixed-signal RTL (ASIC only)",
              "behavioral": "Behavioral models (Verilog-A, SystemVerilog-AMS)",
              "verilog_a": "Verilog-A behavioral models"
            },
            "schematic": {
              "schematic": "Cadence Virtuoso schematic files",
              "symbol": "Cadence Virtuoso symbol files",
              "netlist": "Simulation netlists (SPICE, Spectre)"
            },
            "simulation": {
              "spectre": "Spectre simulation files and results",
              "configs": "Simulation configuration files",
              "results": "Simulation results and reports",
              "waveforms": "Simulation waveform files"
            },
            "layout": {
              "layout": "Cadence Virtuoso layout files",
              "constraints": "Layout constraints and rules",
              "lvs": "Layout vs. schematic verification",
              "drc": "Design rule checking"
            },
            "pdks": {
              "cadence": "Cadence PDK files and models",
              "models": "Device models and libraries",
              "techfiles": "Technology files and rules"
            },
            "constraints": {
              "asic": "ASIC synthesis and timing constraints",
              "fpga": "FPGA implementation constraints"
            },
            "flow": {
              "asic": "ASIC tool flows (OpenLane, Synopsys, etc.)",
              "fpga": "FPGA tool flows (Vivado, Quartus, etc.)",
              "analog": "Analog design flows (Virtuoso, Spectre, etc.)"
            },
            "packaging": {
              "interposer": "Interposer design and routing constraints",
              "bump_map": "Bump map definitions for die-to-die connections",
              "thermal": "Thermal analysis and constraints for multi-die systems"
            }
          }
      }
    },
    
    "required_patterns": {
      "module_header": {
        "description": "Every RTL module must have a standardized header",
        "template": [
          "//=============================================================================",
          "// Module Name: {module_name}",
          "//=============================================================================",
          "// Description: {description}",
          "//",
          "// Features:",
          "// - {feature1}",
          "// - {feature2}",
          "//",
          "// Author: {author}",
          "// License: {license}",
          "//============================================================================="
        ]
      },
      
      "interface_patterns": {
        "clock_reset": "All modules must have clock_i and reset_n_i signals",
        "apb_slave": "APB slave interface must follow standard APB protocol signals: pclk, presetn, psel, penable, pwrite, paddr, pwdata, prdata, pready, pslverr",
        "axi_master": "AXI master interface must follow standard AXI protocol signals",
        "axi_lite_slave": "AXI-Lite slave interface must include: aclk, aresetn, awaddr, awvalid, awready, wdata, wstrb, wvalid, wready, bresp, bvalid, bready, araddr, arvalid, arready, rdata, rresp, rvalid, rready",
        "wishbone": "Wishbone interface must include: wb_clk_i, wb_rst_i, wb_cyc_i, wb_stb_i, wb_ack_o, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i",
        "spi_master": "SPI master interface must include: sclk_o, mosi_o, miso_i, ss_n_o[N-1:0], busy_o, done_o, data_valid_o, data_ready_i",
        "spi_slave": "SPI slave interface must include: sclk_i, mosi_i, miso_o, ss_n_i, busy_o, done_o, data_valid_o, data_ready_i",
        "interrupts": "Interrupt signals should be named irq_<description>_o",
        "power_management": "Power signals: power_on, power_good, pwr_gate_en, pwr_retention",
        "mailbox": "Mailbox interface: mbx_req, mbx_ack, mbx_addr, mbx_data, mbx_we, mbx_valid, mbx_ready",
        "debug": "Debug interface: jtag_tck, jtag_tdi, jtag_tdo, jtag_tms, trace_data",
        "security": "Security interface: fuse_data, fuse_addr, fuse_prog, fuse_done, trng_valid, trng_data",
        "chiplet_interfaces": {
          "ucie": "UCIe interface signals: ucie_clk, ucie_rst_n, ucie_tx_data, ucie_rx_data, ucie_tx_valid, ucie_rx_valid, ucie_tx_ready, ucie_rx_ready",
          "bow": "Bunch of Wires (BoW) interface: bow_clk, bow_rst_n, bow_tx_data, bow_rx_data, bow_tx_valid, bow_rx_valid",
          "aib": "Advanced Interface Bus (AIB): aib_clk, aib_rst_n, aib_tx_data, aib_rx_data, aib_tx_valid, aib_rx_valid",
          "emib": "Intel EMIB interface: emib_clk, emib_rst_n, emib_tx_data, emib_rx_data, emib_tx_valid, emib_rx_valid"
        }
      },
      
      "testbench_patterns": {
        "structure": "Testbenches must include clock generation, reset sequence, and test stimulus",
        "naming": "Testbench files must be named tb_<module_name>.sv",
        "coverage": "Include basic functional coverage for critical paths",
        "test_categories": "Must include functional, performance, corner case, error, and coverage tests",
        "verification_goals": "Must achieve 95% functional coverage, 90% code coverage, 100% toggle coverage",
        "assertion_requirements": "Must include protocol compliance, safety, and performance assertions",
        "regression_testing": "Must support automated regression testing with CI/CD integration"
      }
    }
  },
  
  "code_generation_rules": {
    "rtl": {
      "language": "SystemVerilog",
      "style": "Use always_ff for sequential logic, always_comb for combinational logic",
      "assertions": "Include basic assertions for critical functionality",
      "parameters": "Use parameters for configurable features",
      "comments": "Include detailed comments for complex logic",
      "naming_comment_convention": "Use // <type>: <description> for inline comments (e.g., // signal: rising edge detector)",
      "port_direction_comment": "Use comments above ports for direction and purpose"
    },
    
    "testbench": {
      "language": "SystemVerilog",
      "structure": [
        "Clock and reset generation",
        "DUT instantiation",
        "Test stimulus generation",
        "Response checking",
        "Coverage collection"
      ],
      "verification": "Include basic functional verification and coverage",
      "test_categories": {
        "functional_tests": "Basic functionality, protocol compliance, interface verification",
        "performance_tests": "Maximum frequency, throughput measurement, latency analysis",
        "corner_case_tests": "FIFO overflow/underflow, timeout conditions, reset behavior",
        "error_tests": "Protocol violations, error injection, fault tolerance",
        "coverage_tests": "Functional coverage, code coverage, toggle coverage, FSM coverage"
      },
      "verification_requirements": {
        "coverage_goals": "95% functional coverage, 90% code coverage, 100% toggle coverage",
        "assertion_requirements": "Protocol compliance assertions, safety assertions, performance assertions",
        "waveform_requirements": "Comprehensive waveform generation for debugging and analysis",
        "regression_requirements": "Automated regression testing with CI/CD integration"
      }
    },
    
    "cocotb": {
      "language": "Python",
      "framework": "cocotb",
      "structure": [
        "Import cocotb and required triggers",
        "Create coroutine with `@cocotb.test()`",
        "Drive inputs and check outputs",
        "Include test cases for edge conditions",
        "Add coverage collection and assertions",
        "Include waveform generation and analysis"
      ],
      "file_structure": {
        "location": "tb/cocotb/",
        "file_naming": "test_<module_name>.py"
      },
      "integration_notes": "Ensure Makefile or sim/ run script supports cocotb test execution",
      "supported_simulators": {
        "open_source": ["verilator", "icarus", "ghdl"],
        "commercial": ["vcs", "xcelium", "questa", "riviera-pro"],
        "ci_integration": "Use verilator for CI/CD pipelines, commercial tools for development"
      },
      "advanced_features": {
        "auto_generation": "Generate cocotb testbenches from vyges-metadata.json test specifications",
        "verification_harness": "Bundle cocotb-based verification harnesses into packaging metadata",
        "ci_hooks": "CI hooks that run testbenches with cocotb + verilator/vcs, returning waveform artifacts and coverage",
        "python_ecosystem": "Integrate with pytest, numpy, pandas for advanced test analysis",
        "mixed_signal": "Support mixed-signal testing with Python's scientific computing capabilities",
        "ai_driven_testing": "Enable AI-driven test generation and analysis using Python ML libraries"
      },
      "chinese_eda_adaptation": {
        "toolchain_isolation": "Provide cocotb-style testbench adapters for non-cocotb-compatible simulators",
        "python_harness": "Offer Python-based verification harness even with proprietary Chinese tools",
        "abstraction_layer": "Abstract cocotb under Vyges CI runner for tool-agnostic verification"
      },
      "test_categories": {
        "functional_tests": "Basic functionality, protocol compliance, interface verification",
        "performance_tests": "Maximum frequency, throughput measurement, latency analysis",
        "corner_case_tests": "FIFO overflow/underflow, timeout conditions, reset behavior",
        "error_tests": "Protocol violations, error injection, fault tolerance",
        "coverage_tests": "Functional coverage, code coverage, toggle coverage, FSM coverage"
      },
      "verification_requirements": {
        "coverage_goals": "95% functional coverage, 90% code coverage, 100% toggle coverage",
        "assertion_requirements": "Protocol compliance assertions, safety assertions, performance assertions",
        "waveform_requirements": "Comprehensive waveform generation for debugging and analysis",
        "regression_requirements": "Automated regression testing with CI/CD integration"
      },
      "ai_prompts": {
        "generate_cocotb_test": "Create a Python cocotb testbench for module {module_name}, covering {interfaces}, with clock/reset and basic stimulus, using metadata parameters.",
        "add_test_vectors": "Generate example input vectors for functional cocotb simulation based on interface definitions.",
        "create_advanced_tests": "Generate comprehensive cocotb tests with coverage, assertions, and edge case testing.",
        "setup_cocotb_ci": "Configure CI/CD pipeline for cocotb testing with multiple simulators and coverage reporting.",
        "generate_test_categories": "Generate comprehensive test categories including functional, performance, corner case, and error tests",
        "create_verification_plan": "Create detailed verification plan with coverage goals, assertion requirements, and regression strategy"
      },
      "code_generation_rules": {
        "directory": "tb/cocotb/",
        "filename_pattern": "test_<module_name>.py",
        "imports": ["cocotb", "cocotb.triggers", "cocotb.clock", "cocotb.assertions"],
        "structure": [
          "Define top-level cocotb test coroutine with @cocotb.test()",
          "Clock generation using cocotb.clock.Clock",
          "Reset handling with proper timing",
          "Stimulus sequence with cocotb.triggers",
          "Assertions using cocotb.assertions for verification",
          "Coverage collection and reporting",
          "Waveform generation and analysis"
        ],
        "best_practices": [
          "Use async/await for test coroutines",
          "Include proper error handling and timeouts",
          "Add comprehensive assertions for all outputs",
          "Generate meaningful test names and descriptions",
          "Include parameterized tests for different configurations"
        ]
      }
    },

    "uvm": {
      "language": "SystemVerilog",
      "framework": "UVM (Universal Verification Methodology)",
      "description": "Industry-standard verification methodology for complex digital designs",
      "structure": [
        "UVM test class extending uvm_test",
        "UVM environment class extending uvm_env",
        "UVM agent class extending uvm_agent",
        "UVM driver class extending uvm_driver",
        "UVM monitor class extending uvm_monitor",
        "UVM sequence class extending uvm_sequence",
        "UVM sequence item class extending uvm_sequence_item",
        "UVM scoreboard class extending uvm_scoreboard",
        "UVM coverage class extending uvm_subscriber"
      ],
      "file_structure": {
        "location": "tb/uvm/",
        "file_naming": {
          "test": "test_<module_name>.sv",
          "env": "<module_name>_env.sv",
          "agent": "<module_name>_agent.sv",
          "driver": "<module_name>_driver.sv",
          "monitor": "<module_name>_monitor.sv",
          "sequence": "<module_name>_sequence.sv",
          "sequence_item": "<module_name>_item.sv",
          "scoreboard": "<module_name>_scoreboard.sv",
          "coverage": "<module_name>_coverage.sv",
          "top": "<module_name>_testbench.sv"
        }
      },
      "supported_simulators": {
        "commercial": ["vcs", "xcelium", "questa", "riviera-pro", "modelsim"],
        "open_source": ["verilator-uvm"],
        "ci_integration": "Use commercial simulators for development, verilator-uvm for CI/CD"
      },
      "advanced_features": {
        "auto_generation": "Generate complete UVM testbench from vyges-metadata.json interface specifications",
        "verification_harness": "Bundle UVM-based verification harnesses into packaging metadata",
        "ci_hooks": "CI hooks that run UVM testbenches with coverage and regression testing",
        "protocol_support": "Built-in support for standard protocols (APB, AXI, SPI, I2C, UART)",
        "coverage_driven": "Automatic coverage collection and analysis",
        "constraint_random": "Constraint-random test generation for comprehensive verification",
        "assertion_integration": "SVA (SystemVerilog Assertions) integration with UVM",
        "regression_framework": "Automated regression testing with multiple test scenarios"
      },
      "test_categories": {
        "functional_tests": "Basic functionality, protocol compliance, interface verification",
        "performance_tests": "Maximum frequency, throughput measurement, latency analysis",
        "corner_case_tests": "FIFO overflow/underflow, timeout conditions, reset behavior",
        "error_tests": "Protocol violations, error injection, fault tolerance",
        "coverage_tests": "Functional coverage, code coverage, toggle coverage, FSM coverage",
        "stress_tests": "High-load testing, resource exhaustion, boundary conditions",
        "random_tests": "Constraint-random testing with coverage feedback"
      },
      "verification_requirements": {
        "coverage_goals": "95% functional coverage, 90% code coverage, 100% toggle coverage",
        "assertion_requirements": "Protocol compliance assertions, safety assertions, performance assertions",
        "waveform_requirements": "Comprehensive waveform generation for debugging and analysis",
        "regression_requirements": "Automated regression testing with CI/CD integration",
        "random_testing": "Constraint-random test generation with coverage feedback"
      },
      "uvm_components": {
        "test": {
          "description": "Top-level test class that orchestrates the verification",
          "extends": "uvm_test",
          "responsibilities": [
            "Create and configure UVM environment",
            "Set up test configuration",
            "Start test sequences",
            "Monitor test completion"
          ]
        },
        "environment": {
          "description": "UVM environment that contains all verification components",
          "extends": "uvm_env",
          "responsibilities": [
            "Instantiate and connect UVM agents",
            "Create and configure scoreboard",
            "Set up coverage collection",
            "Manage test configuration"
          ]
        },
        "agent": {
          "description": "UVM agent that manages driver, monitor, and sequencer",
          "extends": "uvm_agent",
          "responsibilities": [
            "Instantiate driver, monitor, and sequencer",
            "Connect components based on agent mode (active/passive)",
            "Handle interface connections"
          ]
        },
        "driver": {
          "description": "UVM driver that drives signals to DUT",
          "extends": "uvm_driver",
          "responsibilities": [
            "Receive sequence items from sequencer",
            "Drive signals to DUT interface",
            "Handle protocol-specific timing",
            "Report transaction completion"
          ]
        },
        "monitor": {
          "description": "UVM monitor that observes DUT interface",
          "extends": "uvm_monitor",
          "responsibilities": [
            "Monitor DUT interface signals",
            "Capture transactions and protocol events",
            "Send transactions to scoreboard and coverage",
            "Detect protocol violations"
          ]
        },
        "sequencer": {
          "description": "UVM sequencer that manages test sequences",
          "extends": "uvm_sequencer",
          "responsibilities": [
            "Manage sequence execution",
            "Handle sequence arbitration",
            "Provide sequence items to driver",
            "Control test flow"
          ]
        },
        "sequence": {
          "description": "UVM sequence that defines test scenarios",
          "extends": "uvm_sequence",
          "responsibilities": [
            "Define test scenarios and stimulus",
            "Create and send sequence items",
            "Handle test constraints and randomization",
            "Coordinate with other sequences"
          ]
        },
        "sequence_item": {
          "description": "UVM sequence item that represents transactions",
          "extends": "uvm_sequence_item",
          "responsibilities": [
            "Define transaction data structure",
            "Include constraints for randomization",
            "Provide transaction utilities and methods",
            "Support transaction recording and analysis"
          ]
        },
        "scoreboard": {
          "description": "UVM scoreboard that verifies DUT behavior",
          "extends": "uvm_scoreboard",
          "responsibilities": [
            "Receive transactions from monitors",
            "Compare actual vs expected behavior",
            "Implement reference model or golden model",
            "Report verification results and errors"
          ]
        },
        "coverage": {
          "description": "UVM coverage collector that tracks verification progress",
          "extends": "uvm_subscriber",
          "responsibilities": [
            "Collect functional coverage data",
            "Define coverage groups and bins",
            "Track coverage progress and goals",
            "Generate coverage reports"
          ]
        }
      },
      "protocol_support": {
        "apb": {
          "description": "APB (Advanced Peripheral Bus) protocol support",
          "sequence_item": "apb_transaction with address, data, write, select fields",
          "driver": "APB protocol timing and handshaking",
          "monitor": "APB transaction capture and protocol checking",
          "scoreboard": "APB transaction verification and response checking"
        },
        "axi": {
          "description": "AXI (Advanced eXtensible Interface) protocol support",
          "sequence_item": "axi_transaction with address, data, burst, cache fields",
          "driver": "AXI protocol timing and handshaking",
          "monitor": "AXI transaction capture and protocol checking",
          "scoreboard": "AXI transaction verification and response checking"
        },
        "spi": {
          "description": "SPI (Serial Peripheral Interface) protocol support",
          "sequence_item": "spi_transaction with data, chip_select, clock fields",
          "driver": "SPI protocol timing and data transmission",
          "monitor": "SPI transaction capture and protocol checking",
          "scoreboard": "SPI transaction verification and data checking"
        },
        "i2c": {
          "description": "I2C (Inter-Integrated Circuit) protocol support",
          "sequence_item": "i2c_transaction with address, data, read_write fields",
          "driver": "I2C protocol timing and handshaking",
          "monitor": "I2C transaction capture and protocol checking",
          "scoreboard": "I2C transaction verification and response checking"
        },
        "uart": {
          "description": "UART (Universal Asynchronous Receiver-Transmitter) protocol support",
          "sequence_item": "uart_transaction with data, baud_rate, parity fields",
          "driver": "UART protocol timing and data transmission",
          "monitor": "UART transaction capture and protocol checking",
          "scoreboard": "UART transaction verification and data checking"
        }
      },
      "ai_prompts": {
        "generate_uvm_testbench": "Create a complete UVM testbench for module {module_name}, including test, env, agent, driver, monitor, sequence, sequence_item, scoreboard, and coverage classes.",
        "generate_uvm_test": "Generate UVM test class for {module_name} with proper test configuration and sequence execution.",
        "generate_uvm_environment": "Create UVM environment class for {module_name} with agent instantiation and component connections.",
        "generate_uvm_agent": "Generate UVM agent class for {module_name} with driver, monitor, and sequencer management.",
        "generate_uvm_driver": "Create UVM driver class for {module_name} with protocol-specific signal driving.",
        "generate_uvm_monitor": "Generate UVM monitor class for {module_name} with transaction capture and protocol checking.",
        "generate_uvm_sequence": "Create UVM sequence class for {module_name} with test scenario definition and stimulus generation.",
        "generate_uvm_sequence_item": "Generate UVM sequence item class for {module_name} with transaction data structure and constraints.",
        "generate_uvm_scoreboard": "Create UVM scoreboard class for {module_name} with reference model and verification logic.",
        "generate_uvm_coverage": "Generate UVM coverage class for {module_name} with functional coverage groups and bins.",
        "setup_uvm_ci": "Configure CI/CD pipeline for UVM testing with coverage and regression reporting.",
        "create_uvm_verification_plan": "Create comprehensive UVM verification plan with test scenarios, coverage goals, and regression strategy.",
        "generate_protocol_uvm": "Generate UVM testbench for {protocol} protocol with proper transaction types and protocol checking.",
        "create_constraint_random_tests": "Create constraint-random UVM tests for {module_name} with coverage feedback and randomization.",
        "generate_uvm_assertions": "Generate SystemVerilog assertions for {module_name} with UVM integration and protocol checking."
      },
      "code_generation_rules": {
        "directory": "tb/uvm/",
        "imports": ["uvm_pkg", "uvm_macros"],
        "structure": [
          "Include UVM package and macros",
          "Define sequence item class with transaction data and constraints",
          "Create sequence class with test scenario definition",
          "Implement driver class with protocol-specific signal driving",
          "Create monitor class with transaction capture and protocol checking",
          "Build agent class with driver, monitor, and sequencer management",
          "Implement scoreboard class with reference model and verification",
          "Create coverage class with functional coverage groups",
          "Build environment class with component instantiation and connections",
          "Define test class with test configuration and sequence execution",
          "Create top-level testbench with DUT instantiation and UVM setup"
        ],
        "best_practices": [
          "Use UVM factory for component creation and configuration",
          "Implement proper transaction recording and analysis",
          "Include comprehensive protocol checking and assertions",
          "Use constraint-random testing for better coverage",
          "Implement functional coverage with meaningful bins",
          "Create reusable sequence library for different test scenarios",
          "Use UVM configuration for flexible test setup",
          "Include proper error handling and reporting",
          "Implement scoreboard with reference model or golden model",
          "Use UVM callbacks for custom verification hooks"
        ],
        "naming_conventions": {
          "test": "<module_name>_test",
          "env": "<module_name>_env",
          "agent": "<module_name>_agent",
          "driver": "<module_name>_driver",
          "monitor": "<module_name>_monitor",
          "sequencer": "<module_name>_sequencer",
          "sequence": "<module_name>_sequence",
          "sequence_item": "<module_name>_item",
          "scoreboard": "<module_name>_scoreboard",
          "coverage": "<module_name>_coverage"
        }
      }
    },
    
    "documentation": {
      "format": "Markdown",
      "required_sections": [
        "Overview",
        "Interfaces",
        "Parameters",
        "Usage Examples",
        "Testing",
        "Limitations"
      ],
      "style_guidelines": {
        "language": "Use clear English text instead of JSON code blocks for better readability",
        "format": "Present technical information in organized bullet points and tables",
        "accessibility": "Make documentation accessible to both technical and non-technical audiences",
        "structure": "Use consistent formatting with clear headings and logical organization",
        "examples": "Provide practical examples and use cases in plain text format"
      },
      "pinout_table": {
        "description": "Every IP documentation and README should include a Markdown table listing all external signals.",
        "columns": ["Name", "Function", "Direction", "Description"],
        "source": "Derived from vyges-metadata.json interfaces/signals",
        "ai_prompt": "Generate a Markdown pinout table for this IP block, listing all external signals with their function, direction, and description."
      },
      "readme_structure": {
        "required_sections": [
          "Overview with purpose and features",
          "Interfaces table with signal names, directions, and descriptions",
          "Integration info with bus protocols and target usage",
          "Testing & verification table with tool status",
          "Build & test commands",
          "Toolchain & flow support table",
          "File structure documentation",
          "Maintainers table",
          "Related projects links"
        ],
        "optional_sections": [
          "Branding & attribution",
          "Advanced usage examples",
          "Performance characteristics",
          "Known limitations"
        ],
        "badges": [
          "Vyges IP Template badge",
          "Use this template badge",
          "License badge",
          "Build status badge"
        ],
        "tables": {
          "interfaces": "Signal Name | Function | Direction | Description",
          "testing": "Method | Tool | Status",
          "toolchain": "Toolchain | Supported | Location",
          "maintainers": "Name | Role | Contact"
        }
      }
    }
  },
  
  "validation_rules": {
    "structure": {
      "required_files": {
        "vyges-metadata.json": "Required metadata file with v1.0.0 schema compliance",
        "rtl/": "Required directory for RTL sources",
        "tb/": "Required directory for testbenches",
        "flow/": "Required directory for tool configurations",
        "test/": "Required directory for test files",
        "docs/": "Required directory for documentation"
      },
      "optional_files": {
        "constraints/": "Optional directory for physical/synthesis constraints",
        "sim/": "Optional directory for simulation scripts and Makefiles"
      },
      "metadata_validation": "vyges-metadata.json must contain all required fields from v1.0.0 schema",
      "ip_name_validation": "IP name must follow GitHub repository naming conventions and Vyges format rules"
    },
    
    "code_quality": {
      "linting": "All RTL must pass basic linting checks",
      "synthesis": "RTL must be synthesizable",
      "simulation": "Testbenches must run without errors",
      "coverage": "Basic functional coverage must be implemented",
      "cocotb_compatibility": "If cocotb is used, test must run with ghdl/iverilog/verilator"
    },
    
    "design_document_quality": {
      "completeness": {
        "required_sections": "All template sections must be present and populated",
        "interface_coverage": "All interfaces must be documented with signal descriptions",
        "timing_specifications": "Critical timing requirements must be specified",
        "validation_criteria": "Clear validation and test criteria must be defined"
      },
      "consistency": {
        "metadata_alignment": "Design document must align with vyges-metadata.json",
        "interface_definitions": "Interface signals must match across all documentation",
        "naming_conventions": "All names must follow Vyges naming conventions"
      },
      "traceability": {
        "requirements_tracking": "Functional requirements must be traceable to implementation",
        "test_coverage": "Test cases must cover all specified requirements",
        "validation_evidence": "Validation results must demonstrate requirement satisfaction"
      },
      "visual_documentation": {
        "block_diagrams": "ASCII block diagrams must be included for IP representation",
        "connection_diagrams": "Connection diagrams must show interface compatibility",
        "timing_diagrams": "Critical timing relationships must be visually represented"
      },
      "documentation_style": {
        "language": "Use clear English text instead of JSON code blocks for better readability",
        "format": "Present technical information in organized bullet points and tables",
        "accessibility": "Make documentation accessible to both technical and non-technical audiences",
        "structure": "Use consistent formatting with clear headings and logical organization",
        "examples": "Provide practical examples and use cases in plain text format"
      }
    },
    
    "quality_assurance": {
      "review_process": "Design documents must undergo peer review before publication",
      "validation_evidence": "All claims must be supported by test results or analysis",
      "compliance_checking": "Must comply with Vyges standards and industry best practices",
      "maintainability": "Documentation must be maintainable and version-controlled"
    }
  },
  
  "ai_prompts": {
    "create_module": "Create a SystemVerilog module following Vyges conventions. Include proper header, interface signals, and basic functionality.",
    "create_testbench": "Create a SystemVerilog testbench for the given module. Include clock generation, reset sequence, and basic test stimulus.",
    "expand_structure": "Suggest when to use 'vyges expand' commands to add complexity to the project structure.",
    "validate_structure": "Check if the current project structure follows Vyges conventions and suggest improvements.",
    "generate_documentation": "Generate documentation for the functional IP block based on the RTL code and metadata.",
    "refactor_module": "Refactor a SystemVerilog module to improve readability, modularity, and testability. Follow Vyges naming and structure conventions.",
    "add_interface": "Extend the functional IP module by adding a new interface using Vyges Standardized Interface Catalog (e.g., AXI4-Lite, APB, Wishbone). Include port declarations and update documentation.",
    "generate_catalog_ready_ip": "Create a SystemVerilog functional IP block that is ready for the Vyges Catalog. Include complete metadata, documentation, and testbench.",
    "check_catalog_readiness": "Validate the functional IP block for Vyges Catalog readiness: metadata coverage, testability, and discoverability.",
    "improve_catalog_score": "Improve this functional IP block to raise its catalog quality score by enhancing metadata, documentation, and test coverage.",
    "generate_from_metadata": "Generate complete functional IP specification and code scaffolding from vyges-metadata.json",
    "update_metadata_from_code": "Update vyges-metadata.json based on changes in RTL code and interfaces",
    "synchronize_metadata_code": "Ensure vyges-metadata.json and generated code are in sync",
    "validate_ip_name": "Validate IP name format for GitHub compatibility and Vyges ecosystem usage",
    "setup_project": "Guide developer through initial functional IP project setup using vyges init --interactive workflow",
    "use_standard_interfaces": "Use Vyges Standardized Interface Catalog signals and naming conventions for IP integration",
    "validate_interface_compliance": "Validate that interface signals follow Vyges Standardized Interface Catalog conventions",
    "generate_interface_wrapper": "Generate interface wrapper using standardized signal names from Vyges catalog",
    "generate_ascii_diagram": "Generate ASCII block diagram showing functional IP block with all pins, grouped by interface type (clock, reset, data, control, etc.) with signal descriptions",
    "generate_connection_diagram": "Generate ASCII diagram showing connections between multiple functional IP blocks, highlighting pin-to-pin connections and interface compatibility",
    "validate_pin_connections": "Validate pin connections between functional IP blocks for signal compatibility, timing, and protocol compliance",
    "generate_cocotb_testbench": "Generate comprehensive cocotb testbench with coverage, assertions, and waveform generation from vyges-metadata.json test specifications",
    "create_cocotb_harness": "Create cocotb verification harness that can be bundled into packaging metadata for automated testing",
    "setup_cocotb_ci": "Set up CI hooks for cocotb testbenches with verilator/vcs, returning waveform artifacts and coverage reports",
    "adapt_cocotb_chinese_tools": "Create cocotb-style testbench adapters for non-cocotb-compatible Chinese EDA tools",
    "generate_readme": "Generate comprehensive README.md following Vyges conventions with all required sections, tables, and badges",
    "update_readme_sections": "Update specific sections of README.md based on IP metadata and current project state",
    "generate_pinout_table": "Generate a Markdown pinout table for the functional IP block, listing all external signals with columns: Name, Function, Direction, Description, based on vyges-metadata.json.",
    "generate_design_document": "Generate comprehensive design specification document following Vyges conventions with all required sections, quality requirements, and visual aids",
    "validate_design_document": "Validate design document for completeness, consistency, traceability, and visual documentation quality",
    "enhance_design_document": "Improve existing design document by adding missing sections, enhancing visual aids, and ensuring quality compliance",
    "improve_documentation_readability": "Convert JSON code blocks and technical jargon to clear English text for better accessibility and readability",
    "create_chiplet_ready_ip": "Create a chiplet-ready IP block with die-to-die interface support, packaging considerations, and multi-die integration capabilities",
    "validate_chiplet_compatibility": "Validate IP block for chiplet integration readiness: interface compatibility, packaging requirements, and die-to-die connectivity",
    "generate_chiplet_interface": "Generate die-to-die interface wrapper using UCIe, BoW, AIB, or EMIB protocols for chiplet integration",
    "create_multi_die_testbench": "Create testbench for multi-die system simulation with chiplet-to-chiplet communication testing",
    "generate_chiplet_documentation": "Generate chiplet-specific documentation including packaging requirements, die-to-die interface specifications, and integration guidelines",
    "generate_interposer_constraints": "Generate interposer design constraints including technology, routing layers, pitch, and die spacing requirements",
    "create_bump_constraints": "Create bump map constraints with pitch, size, array configuration, and power/signal bump counts",
    "analyze_thermal_constraints": "Analyze and specify thermal constraints including power limits, junction temperature, thermal resistance, and cooling requirements",
    "design_multi_die_testing": "Design multi-die testing strategy with test access methods, coverage requirements, and test vector specifications",
    "validate_signal_conformance": "Validate signal conformance against protocol specifications with compliance testing and verification tools",
    "configure_power_domains": "Configure power domains with voltage levels, isolation requirements, retention capabilities, and current limits",
    "track_lifecycle_metadata": "Track lifecycle and supply chain metadata including origin, trusted fabricator status, certifications, and version control",
    "setup_fpga_project": "Set up FPGA project structure with appropriate toolchain, constraints, and IP cores",
    "generate_fpga_flow": "Generate FPGA-specific flow configuration with synthesis, implementation, and bitstream generation",
    "create_fpga_constraints": "Create FPGA timing and pin constraints for specific board and toolchain",
    "integrate_fpga_ip": "Integrate vendor IP cores with proper configuration and instantiation",
    "validate_fpga_timing": "Validate FPGA timing constraints and perform static timing analysis",
    "generate_fpga_bitstream": "Generate FPGA bitstream with proper synthesis and implementation flow",
    "setup_fpga_simulation": "Set up FPGA-specific simulation environment with vendor tools",
    "create_fpga_testbench": "Create FPGA-specific testbench for hardware verification",
    "analyze_fpga_utilization": "Analyze FPGA resource utilization and optimization opportunities",
    "generate_comprehensive_testbench": "Generate comprehensive testbench with functional, performance, corner case, error, and coverage tests",
    "create_verification_plan": "Create detailed verification plan with coverage goals, assertion requirements, and regression strategy",
    "setup_test_automation": "Set up automated test execution with multiple simulators and coverage reporting",
    "validate_test_coverage": "Validate test coverage against specified goals and requirements",
    "generate_analog_behavioral": "Generate Verilog-A behavioral model for {analog_block} with specifications: {specs}",
    "design_analog_circuit": "Design transistor-level circuit for {analog_block} targeting {pdk} with performance requirements: {specs}",
    "create_spectre_simulation": "Create Spectre simulation setup for {analog_block} with corner analysis and Monte Carlo simulation",
    "generate_analog_layout_constraints": "Generate layout constraints for {analog_block} with matching, symmetry, and routing requirements",
    "validate_analog_design": "Validate analog design {analog_block} against specifications: {specs}",
    "optimize_analog_performance": "Optimize {analog_block} for performance metrics: {metrics}",
    "create_analog_testbench": "Create comprehensive testbench for {analog_block} with corner case analysis",
    "generate_analog_documentation": "Generate analog design documentation for {analog_block} with performance analysis and layout guidelines",
    "setup_analog_project": "Set up analog project structure with behavioral, circuit, simulation, and layout directories",
    "run_analog_corner_analysis": "Run corner analysis for {analog_block} across process, voltage, and temperature variations",
    "run_analog_monte_carlo": "Run Monte Carlo analysis for {analog_block} with specified iterations and metrics",
    "export_analog_layout": "Export analog layout for {analog_block} in specified format with LVS-clean verification",
    "generate_uvm_testbench": "Create a complete UVM testbench for {module_name}, including test, env, agent, driver, monitor, sequence, sequence_item, scoreboard, and coverage classes",
    "generate_uvm_test": "Generate UVM test class for {module_name} with proper test configuration and sequence execution",
    "generate_uvm_environment": "Create UVM environment class for {module_name} with agent instantiation and component connections",
    "generate_uvm_agent": "Generate UVM agent class for {module_name} with driver, monitor, and sequencer management",
    "generate_uvm_driver": "Create UVM driver class for {module_name} with protocol-specific signal driving",
    "generate_uvm_monitor": "Generate UVM monitor class for {module_name} with transaction capture and protocol checking",
    "generate_uvm_sequence": "Create UVM sequence class for {module_name} with test scenario definition and stimulus generation",
    "generate_uvm_sequence_item": "Generate UVM sequence item class for {module_name} with transaction data structure and constraints",
    "generate_uvm_scoreboard": "Create UVM scoreboard class for {module_name} with reference model and verification logic",
    "generate_uvm_coverage": "Generate UVM coverage class for {module_name} with functional coverage groups and bins",
    "setup_uvm_ci": "Configure CI/CD pipeline for UVM testing with coverage and regression reporting",
    "create_uvm_verification_plan": "Create comprehensive UVM verification plan with test scenarios, coverage goals, and regression strategy",
    "generate_protocol_uvm": "Generate UVM testbench for {protocol} protocol with proper transaction types and protocol checking",
    "create_constraint_random_tests": "Create constraint-random UVM tests for {module_name} with coverage feedback and randomization",
    "generate_uvm_assertions": "Generate SystemVerilog assertions for {module_name} with UVM integration and protocol checking",
    "convert_ipxact_to_vyges": "Convert this IP-XACT XML to Vyges metadata JSON format following the conversion mapping and rules",
    "parse_ipxact_component": "Parse this IP-XACT component and extract basic information (vendor, library, name, version, description)",
    "map_ipxact_ports": "Map these IP-XACT ports to Vyges pins with proper naming, direction, width, and type inference",
    "map_ipxact_parameters": "Convert these IP-XACT parameters to Vyges parameters with proper type mapping and validation",
    "map_ipxact_interfaces": "Map these IP-XACT bus interfaces to Vyges interface definitions with protocol detection",
    "map_ipxact_files": "Convert these IP-XACT file sets to Vyges file metadata with proper categorization",
    "generate_vyges_metadata": "Generate complete vyges-metadata.json from the parsed IP-XACT information",
    "enhance_converted_metadata": "Enhance the converted metadata with Vyges-specific features, tags, and quality improvements",
    "validate_converted_metadata": "Validate the converted metadata against Vyges schema and suggest improvements",
    "suggest_vyges_workflow": "Suggest Vyges CLI commands and workflow steps for the converted IP",
    "compare_ipxact_vyges": "Compare the original IP-XACT structure with the converted Vyges metadata and highlight differences",
    "migrate_ipxact_project": "Provide a complete migration plan from IP-XACT to Vyges including file structure and workflow changes",
    "setup_ieee_p1735_encryption": "Set up IEEE P1735 encrypted IP project structure with proper directory layout and metadata",
    "encrypt_hdl_with_p1735": "Encrypt HDL file using IEEE P1735 standard with specified rights and recipient certificate",
    "create_p1735_rights_declaration": "Create IEEE P1735 rights declaration XML for specified usage rights and restrictions",
    "generate_customer_certificate": "Generate test X.509 certificate for customer licensing and encryption",
    "setup_license_management": "Set up license management system for encrypted IP with customer certificate handling",
    "create_encrypted_interface": "Create encrypted IP with plaintext interface for integration while protecting core implementation",
    "validate_p1735_setup": "Validate IEEE P1735 encryption setup including certificate validity and rights declaration",
    "generate_encryption_metadata": "Generate Vyges metadata extensions for encrypted IP including licensing and distribution information",
    "create_encryption_workflow": "Create complete encryption workflow for IP distribution including CLI commands and metadata",
    "setup_multi_recipient_encryption": "Set up multi-recipient encryption for distributing IP to multiple customers with different rights",
    "create_hybrid_encryption": "Create hybrid encryption setup with plaintext interface and encrypted core implementation",
    "validate_license_compliance": "Validate license compliance for encrypted IP including rights enforcement and expiration checking",
    "generate_decryption_instructions": "Generate decryption instructions for authorized users of encrypted IP",
    "setup_encrypted_catalog_entry": "Set up encrypted IP catalog entry with proper metadata, licensing, and distribution information"
  },
  
  "proprietary_tools_guidance": {
    "description": "Guidance for handling proprietary EDA tools in build systems and workflows",
    "principle": "When providing support via Makefiles with proprietary tools such as Vivado, Quartus, Synopsys, Innovus/Cadence, we should always skip running those as part of the build system. The user may subsequently add that support.",
    "rationale": [
      "Proprietary tools require licensing and are not openly available",
      "Build systems should focus on open-source tools for accessibility",
      "Users can add proprietary tool support based on their specific needs",
      "Ensures build systems work out-of-the-box without licensing barriers"
    ],
    "proprietary_tools": {
      "vivado": {
        "vendor": "AMD/Xilinx",
        "availability": "Commercial license required",
        "build_system": "Skip in default builds",
        "user_addition": "User can add Vivado support to Makefiles as needed"
      },
      "quartus": {
        "vendor": "Intel/Altera", 
        "availability": "Commercial license required",
        "build_system": "Skip in default builds",
        "user_addition": "User can add Quartus support to Makefiles as needed"
      },
      "synopsys": {
        "vendor": "Synopsys",
        "availability": "Commercial license required", 
        "build_system": "Skip in default builds",
        "user_addition": "User can add Synopsys support to Makefiles as needed"
      },
      "innovus": {
        "vendor": "Cadence",
        "availability": "Commercial license required",
        "build_system": "Skip in default builds", 
        "user_addition": "User can add Innovus support to Makefiles as needed"
      },
      "cadence": {
        "vendor": "Cadence",
        "availability": "Commercial license required",
        "build_system": "Skip in default builds",
        "user_addition": "User can add Cadence support to Makefiles as needed"
      }
    },
    "open_source_alternatives": {
      "synthesis": ["yosys", "berkeley-abc"],
      "simulation": ["verilator", "icarus", "ghdl"],
      "layout": ["magic", "klayout"],
      "verification": ["netgen", "cocotb"],
      "waveform": ["gtkwave"]
    },
    "build_system_approach": {
      "default": "Use open-source tools for default builds",
      "optional": "Provide optional targets for proprietary tools",
      "documentation": "Document how users can add proprietary tool support",
      "examples": "Provide example Makefile targets for proprietary tools"
    },
    "ai_prompts": {
      "skip_proprietary_tools": "When generating Makefiles or build systems, skip proprietary tools like Vivado, Quartus, Synopsys, Innovus/Cadence. Focus on open-source alternatives.",
      "add_proprietary_support": "Show user how to add support for {proprietary_tool} to existing Makefile as optional target.",
      "document_proprietary_integration": "Document integration approach for {proprietary_tool} without including it in default build."
    }
  },

  "cli_integration": {
    "commands": {
      "init": {
        "description": "Initialize a new functional IP project with interactive setup",
        "examples": [
          "vyges init --interactive",
          "vyges init my-ip --type digital --pdk sky130",
          "vyges setup --from-template uart-controller"
        ],
        "features": [
          "Git integration for auto-detecting author",
          "Interactive license selection",
          "Platform and design type selection",
          "Tool auto-configuration",
          "IP name validation",
          "Functional IP principle (one repository = one functional IP)"
        ]
      },
      "validate": {
        "description": "Validates functional IP metadata, project structure, and lint/simulation readiness",
        "example": "vyges validate --strict"
      },
      "expand": {
        "description": "Adds complexity to project structure based on specified features",
        "example": "vyges expand --analog"
      },
      "test": {
        "description": "Runs comprehensive tests and validation for the functional IP block",
        "examples": [
          "vyges test --simulation",
          "vyges test --coverage --goals 95,90,100",
          "vyges test --regression --all-simulators",
          "vyges test --categories functional,performance,corner-case,error"
        ]
      },
      "publish": {
        "description": "Publishes functional IP to Vyges catalog",
        "example": "vyges publish --dry-run"
      },
      "generate": {
        "description": "Generate specifications and code for functional IP from vyges-metadata.json",
        "examples": [
          "vyges generate spec",
          "vyges generate code",
          "vyges generate rtl",
          "vyges generate testbench --lang cocotb",
          "vyges generate flow --tool openlane",
          "vyges generate readme",
          "vyges generate readme --update-sections",
          "vyges generate design-doc",
          "vyges generate design-doc --validate",
          "vyges generate design-doc --enhance",
          "vyges generate fpga-flow --toolchain vivado",
          "vyges generate fpga-constraints --board arty-a7",
          "vyges generate fpga-project --toolchain quartus"
        ]
      },
      "fpga": {
        "description": "Manage FPGA-specific flows and toolchains",
        "examples": [
          "vyges fpga setup --toolchain vivado --board arty-a7",
          "vyges fpga generate-constraints --toolchain vivado --board arty-a7",
          "vyges fpga synthesize --toolchain vivado --project spi_controller",
          "vyges fpga implement --toolchain vivado --project spi_controller",
          "vyges fpga generate-bitstream --toolchain vivado --project spi_controller",
          "vyges fpga simulate --toolchain vivado --testbench tb_spi_controller",
          "vyges fpga analyze-timing --toolchain vivado --project spi_controller",
          "vyges fpga integrate-ip --toolchain vivado --ip uart_controller",
          "vyges fpga program --toolchain vivado --bitstream spi_controller.bit",
          "vyges fpga validate --toolchain vivado --board arty-a7"
        ]
      },
      "cocotb": {
        "description": "Manage cocotb testbenches and verification harnesses",
        "examples": [
          "vyges cocotb generate --ip uart-controller",
          "vyges cocotb setup-ci --simulator verilator",
          "vyges cocotb run --simulator vcs --coverage",
          "vyges cocotb create-harness --bundle-metadata",
          "vyges cocotb generate-categories --ip spi-controller",
          "vyges cocotb create-verification-plan --ip spi-controller",
          "vyges cocotb validate-coverage --ip spi-controller --goals 95,90,100"
        ]
      },
      "uvm": {
        "description": "Manage UVM testbenches and verification methodology",
        "examples": [
          "vyges uvm generate --ip uart-controller --protocol apb",
          "vyges uvm setup-project --ip spi-controller --simulator vcs",
          "vyges uvm create-test --ip uart-controller --test-type functional",
          "vyges uvm create-sequence --ip spi-controller --protocol spi",
          "vyges uvm create-scoreboard --ip uart-controller --reference-model",
          "vyges uvm create-coverage --ip spi-controller --coverage-type functional",
          "vyges uvm run-simulation --ip uart-controller --simulator xcelium --coverage",
          "vyges uvm run-regression --ip spi-controller --test-list all --parallel",
          "vyges uvm generate-protocol --protocol axi --sequence-item --driver --monitor",
          "vyges uvm create-verification-plan --ip uart-controller --coverage-goals 95,90,100",
          "vyges uvm setup-ci --ip spi-controller --simulator verilator-uvm --coverage",
          "vyges uvm validate-testbench --ip uart-controller --check-components --check-protocol"
        ]
      },
      "diagram": {
        "description": "Generate ASCII block diagrams for functional IP blocks and connections",
        "examples": [
          "vyges diagram block --ip uart-controller",
          "vyges diagram connections --ip1 cpu --ip2 uart-controller",
          "vyges diagram validate --ip1 cpu --ip2 uart-controller"
        ]
      },
      "chiplet": {
        "description": "Manage chiplet-specific features and multi-die integration",
        "examples": [
          "vyges chiplet validate --ip uart-controller",
          "vyges chiplet validate --constraints interposer --ip uart-controller",
          "vyges chiplet validate --constraints thermal --ip uart-controller",
          "vyges chiplet generate-interface --protocol ucie --ip uart-controller",
          "vyges chiplet create-testbench --multi-die --ip1 cpu --ip2 uart-controller",
          "vyges chiplet generate-docs --packaging --ip uart-controller",
          "vyges chiplet generate-constraints --interposer --ip uart-controller",
          "vyges chiplet generate-constraints --bump-map --ip uart-controller",
          "vyges chiplet analyze-thermal --ip uart-controller",
          "vyges chiplet configure-power-domains --ip uart-controller",
          "vyges chiplet validate-conformance --protocol ucie --ip uart-controller",
          "vyges chiplet track-lifecycle --origin vyges/partner-x --ip uart-controller"
        ]
      },
      "analog": {
        "description": "Manage analog IP design flows and Cadence PDK integration",
        "examples": [
          "vyges analog generate-behavioral --block opamp --specs gain:60dB,bandwidth:1MHz",
          "vyges analog design-circuit --block bandgap --pdk cadence/tsmc65 --topology brokaw",
          "vyges analog simulate-spectre --block ldo --analysis dc,ac,transient,noise",
          "vyges analog generate-layout --block opamp --constraints matching,symmetry",
          "vyges analog validate-design --block opamp --specs gain,bandwidth,psrr,noise",
          "vyges analog optimize-performance --block bandgap --metrics temp_coeff,psrr",
          "vyges analog create-testbench --block ldo --corner-analysis tt,ff,ss",
          "vyges analog generate-documentation --block opamp --include-performance,layout",
          "vyges analog setup-project --block opamp --pdk cadence/tsmc65 --flow behavioral,circuit,simulation,layout",
          "vyges analog run-corner-analysis --block bandgap --corners tt,ff,ss,fs,sf",
          "vyges analog run-monte-carlo --block ldo --iterations 1000 --metrics dropout,psrr",
          "vyges analog export-layout --block opamp --format gdsii,oa --lvs-clean"
        ]
      },
      "encrypt": {
        "description": "Manage IEEE P1735 encryption for secure IP distribution (planned for future release)",
        "examples": [
          "Future: vyges encrypt --file rtl/my_ip.vhdl --public-key licenses/customer.crt --rights simulate=true,synthesize=false --output encrypted/my_ip.vhdp",
          "Future: vyges decrypt --file encrypted/my_ip.vhdp --private-key licenses/my_private.key --output decrypted/my_ip.vhdl",
          "Future: vyges publish --encrypted --license simulation-only --certs licenses/ --rights simulate=true,synthesize=false",
          "Future: vyges licenses add --cert customer1.crt --name 'Customer A' --rights simulate=true,synthesize=true"
        ],
        "status": "Planned for future release - model may change"
      }
    },
    "suggestions": {
      "when_to_expand": [
        "When adding analog components: vyges expand --analog",
        "When adding commercial tools: vyges expand --commercial-tools",
        "When creating multi-IP project: vyges expand --multi-ip",
        "When targeting multiple platforms or analog/mixed-signal: vyges expand --platform asic,fpga --add-analog",
        "When adding platform-specific constraints: vyges expand --constraints asic,fpga",
        "When creating multi-IP project with different targets: vyges expand --multi-ip --platform asic,fpga"
      ],
      "fpga_workflow": [
        "When targeting FPGA: vyges fpga setup --toolchain vivado --board arty-a7",
        "When generating FPGA constraints: vyges fpga generate-constraints --toolchain vivado --board arty-a7",
        "When synthesizing for FPGA: vyges fpga synthesize --toolchain vivado --project spi_controller",
        "When implementing FPGA design: vyges fpga implement --toolchain vivado --project spi_controller",
        "When generating bitstream: vyges fpga generate-bitstream --toolchain vivado --project spi_controller",
        "When programming FPGA: vyges fpga program --toolchain vivado --bitstream spi_controller.bit"
      ],
      "chiplet_workflow": [
        "When designing chiplet: vyges chiplet validate --ip spi-controller",
        "When implementing chiplet wrapper: vyges chiplet generate-interface --protocol ucie --ip spi-controller",
        "When designing packaging: vyges chiplet generate-constraints --interposer --ip spi-controller",
        "When analyzing thermal: vyges chiplet analyze-thermal --ip spi-controller",
        "When configuring power: vyges chiplet configure-power-domains --ip spi-controller",
        "When testing multi-die: vyges chiplet create-testbench --multi-die --ip1 cpu --ip2 spi-controller",
        "When validating integration: vyges chiplet validate-conformance --protocol ucie --ip spi-controller",
        "When tracking lifecycle: vyges chiplet track-lifecycle --origin vyges/partner-x --ip spi-controller"
      ],
      "analog_workflow": [
        "When starting analog design: vyges analog setup-project --block opamp --pdk cadence/tsmc65",
        "When creating behavioral model: vyges analog generate-behavioral --block opamp --specs gain:60dB,bandwidth:1MHz",
        "When designing transistor circuit: vyges analog design-circuit --block bandgap --pdk cadence/tsmc65 --topology brokaw",
        "When running simulations: vyges analog simulate-spectre --block ldo --analysis dc,ac,transient,noise",
        "When validating design: vyges analog validate-design --block opamp --specs gain,bandwidth,psrr,noise",
        "When optimizing performance: vyges analog optimize-performance --block bandgap --metrics temp_coeff,psrr",
        "When creating testbench: vyges analog create-testbench --block ldo --corner-analysis tt,ff,ss",
        "When generating layout: vyges analog generate-layout --block opamp --constraints matching,symmetry",
        "When running corner analysis: vyges analog run-corner-analysis --block bandgap --corners tt,ff,ss,fs,sf",
        "When running Monte Carlo: vyges analog run-monte-carlo --block ldo --iterations 1000 --metrics dropout,psrr",
        "When exporting layout: vyges analog export-layout --block opamp --format gdsii,oa --lvs-clean"
      ],
      "encryption_workflow": [
        "Future: When setting up encrypted IP: vyges encrypt setup --project my-ip --license commercial",
        "Future: When encrypting HDL files: vyges encrypt --file rtl/my_ip.vhdl --public-key licenses/customer.crt --rights simulate=true,synthesize=false",
        "Future: When publishing encrypted IP: vyges publish --encrypted --license simulation-only --certs licenses/",
        "Status: Planned for future release - model may change"
      ],
      "uvm_workflow": [
        "When starting UVM project: vyges uvm setup-project --ip uart-controller --simulator vcs",
        "When generating complete testbench: vyges uvm generate --ip uart-controller --protocol apb",
        "When creating test scenarios: vyges uvm create-test --ip uart-controller --test-type functional",
        "When defining transactions: vyges uvm create-sequence --ip spi-controller --protocol spi",
        "When implementing verification: vyges uvm create-scoreboard --ip uart-controller --reference-model",
        "When tracking coverage: vyges uvm create-coverage --ip spi-controller --coverage-type functional",
        "When running simulations: vyges uvm run-simulation --ip uart-controller --simulator xcelium --coverage",
        "When running regression: vyges uvm run-regression --ip spi-controller --test-list all --parallel",
        "When generating protocol support: vyges uvm generate-protocol --protocol axi --sequence-item --driver --monitor",
        "When creating verification plan: vyges uvm create-verification-plan --ip uart-controller --coverage-goals 95,90,100",
        "When setting up CI/CD: vyges uvm setup-ci --ip spi-controller --simulator verilator-uvm --coverage",
        "When validating testbench: vyges uvm validate-testbench --ip uart-controller --check-components --check-protocol"
      ],
      "metadata_driven_workflow": [
        "Start with vyges-metadata.json as source of truth",
        "Use vyges generate spec to create requirements document",
        "Use vyges generate design-doc to create comprehensive design specification",
        "Use vyges generate code to create RTL scaffolding",
        "Use vyges generate testbench to create verification code"
      ],
      "project_setup_workflow": [
        "Use vyges init --interactive for guided setup",
        "Validate IP name format for GitHub compatibility",
        "Select appropriate license and target platforms",
        "Let CLI auto-configure tools based on choices",
        "Initialize in current directory (one repository = one functional IP)"
      ]
    }
  },
  
  "fpga_flow_configuration": {
    "description": "Comprehensive FPGA tool flow configuration and requirements",
    "supported_toolchains": {
      "vivado": {
        "description": "Xilinx Vivado FPGA flow for Xilinx devices",
        "tools": ["vivado", "vivado_hls", "vitis"],
        "supported_families": ["artix7", "kintex7", "virtex7", "zynq", "ultrascale", "versal"],
        "config_files": {
          "project": "vivado_project.tcl",
          "constraints": "constraints.xdc",
          "synthesis": "synthesis.tcl",
          "implementation": "implementation.tcl",
          "bitstream": "bitstream.tcl"
        },
        "outputs": ["bitstream.bit", "netlist.v", "timing_report.txt", "utilization_report.txt"],
        "board_support": ["arty-a7", "nexys4", "zybo", "ultra96", "kcu105"],
        "ip_catalog": "Xilinx IP Catalog integration",
        "simulation": "Vivado Simulator support",
        "version_requirements": "Vivado 2023.1+ recommended"
      },
      "quartus": {
        "description": "Intel Quartus FPGA flow for Intel/Altera devices",
        "tools": ["quartus", "modelsim", "nios_eds"],
        "supported_families": ["cyclone", "arria", "stratix", "max", "agilex"],
        "config_files": {
          "project": "quartus_project.qpf",
          "constraints": "constraints.sdc",
          "synthesis": "synthesis.qsf",
          "implementation": "implementation.qsf"
        },
        "outputs": ["output.sof", "netlist.v", "timing_report.txt", "power_report.txt"],
        "board_support": ["de10-nano", "de1-soc", "cyclone-v", "arria-10"],
        "ip_catalog": "Intel IP Catalog integration",
        "simulation": "ModelSim support",
        "version_requirements": "Quartus Prime 22.1+ recommended"
      },
      "yosys_symbiflow": {
        "description": "Open-source FPGA flow with Yosys and SymbiFlow",
        "tools": ["yosys", "nextpnr", "symbiflow"],
        "supported_families": ["ice40", "ecp5", "artix7"],
        "config_files": {
          "synthesis": "yosys_synth.tcl",
          "constraints": "constraints.pcf",
          "placement": "nextpnr_config.py"
        },
        "outputs": ["output.bin", "netlist.v", "timing_report.txt"],
        "board_support": ["icebreaker", "ecp5-evn", "arty-a7"],
        "open_source": "Fully open-source toolchain",
        "version_requirements": "Latest stable releases"
      },
      "openfpga": {
        "description": "OpenFPGA framework for customizable FPGA architectures",
        "tools": ["openfpga", "vpr", "odin"],
        "config_files": {
          "architecture": "openfpga_config.xml",
          "placement": "vpr_config.xml",
          "constraints": "constraints.xml"
        },
        "outputs": ["bitstream.bin", "architecture.xml", "routing.txt"],
        "customizable": "User-defined FPGA architecture support",
        "research_oriented": "Academic and research applications"
      }
    },
    "fpga_specific_requirements": {
      "constraints": {
        "timing": "FPGA-specific timing constraints (XDC, SDC, PCF)",
        "pin_assignment": "I/O pin assignment and board-specific constraints",
        "clock_management": "Clock domain crossing and clock constraints",
        "power": "Power consumption and thermal constraints",
        "area": "Resource utilization and area constraints",
        "io_standards": "I/O voltage standards and drive strength"
      },
      "verification": {
        "simulation": "FPGA-specific simulation with vendor tools",
        "timing_analysis": "Static timing analysis for FPGA",
        "power_analysis": "Power consumption analysis",
        "functional_verification": "FPGA-specific functional verification",
        "post_route_simulation": "Post-placement and routing simulation"
      },
      "integration": {
        "ip_cores": "Vendor IP core integration and configuration",
        "board_support": "Board-specific integration and testing",
        "debug": "FPGA debugging and signal analysis tools",
        "programming": "Bitstream generation and programming tools",
        "hardware_testing": "On-board hardware verification"
      }
    },
    "fpga_project_structure": {
      "flow": {
        "vivado": "flow/vivado/",
        "quartus": "flow/quartus/",
        "yosys": "flow/yosys/",
        "openfpga": "flow/openfpga/"
      },
      "constraints": {
        "vivado": "constraints/vivado/",
        "quartus": "constraints/quartus/",
        "yosys": "constraints/yosys/"
      },
      "ip_cores": {
        "vivado": "ip/vivado/",
        "quartus": "ip/quartus/",
        "generic": "ip/generic/"
      },
      "testbenches": {
        "simulation": "tb/simulation/",
        "hardware": "tb/hardware/"
      }
    },
    "ai_prompts": {
      "generate_fpga_flow": "Generate FPGA-specific flow configuration for {toolchain} with appropriate constraints and project files",
      "setup_fpga_project": "Set up FPGA project structure with {toolchain} toolchain, including constraints and IP cores",
      "create_fpga_constraints": "Create FPGA-specific timing and pin constraints for {board} using {toolchain}",
      "integrate_fpga_ip": "Integrate vendor IP cores for {toolchain} with proper configuration and instantiation",
      "validate_fpga_timing": "Validate FPGA timing constraints and perform static timing analysis",
      "generate_fpga_bitstream": "Generate FPGA bitstream with proper synthesis and implementation flow"
    }
  },

  "analog_flow_configuration": {
    "description": "Comprehensive analog IP design flow configuration for behavioral modeling, circuit implementation, simulation, and layout targeting Cadence PDKs",
    "analog_ip_design": {
      "description": "Design flow for analog IP blocks including behavioral modeling, circuit implementation, simulation, and layout targeting a Cadence PDK",
      "stages": [
        {
          "name": "generate_behavioral_model",
          "description": "Create Verilog-A or SystemVerilog-AMS behavioral models based on specs in the /docs directory",
          "inputs": ["specs", "block_name"],
          "outputs": ["behavioral_model.sv", "testbench.sv"],
          "task_templates": {
            "verilog_a": "Generate Verilog-A behavioral model with proper module structure and parameter definitions",
            "systemverilog_ams": "Generate SystemVerilog-AMS model with mixed-signal capabilities",
            "testbench": "Create comprehensive testbench with corner case analysis and Monte Carlo simulation"
          },
          "verification_criteria": {
            "functional": "Behavioral model matches specification requirements",
            "performance": "Model achieves target performance metrics",
            "corner_cases": "Model handles process, voltage, and temperature variations"
          }
        },
        {
          "name": "design_transistor_level_circuit",
          "description": "Develop transistor-level implementation targeting a specified Cadence PDK, using the behavioral model as reference",
          "inputs": ["behavioral_model.sv", "pdks/cadence/<pdk-name>", "constraints"],
          "outputs": ["schematic_cellview", "simulation_netlist"],
          "task_templates": {
            "schematic": "Create transistor-level schematic with proper device sizing and biasing",
            "netlist": "Generate simulation-ready netlist with parasitic extraction",
            "constraints": "Define design constraints for area, power, and performance"
          },
          "verification_criteria": {
            "functionality": "Circuit implements required analog function",
            "performance": "Meets gain, bandwidth, noise, and power specifications",
            "robustness": "Design is robust across process corners"
          }
        },
        {
          "name": "simulate_with_spectre",
          "description": "Run Spectre simulations to validate the transistor-level design against functional and corner cases",
          "inputs": ["simulation_netlist", "spectre_config"],
          "outputs": ["waveforms", "metrics", "monte_carlo_results"],
          "task_templates": {
            "dc_analysis": "DC operating point analysis for biasing verification",
            "ac_analysis": "AC analysis for frequency response and stability",
            "transient": "Transient analysis for time-domain behavior",
            "noise": "Noise analysis for SNR and dynamic range",
            "monte_carlo": "Monte Carlo analysis for process variation impact"
          },
          "verification_criteria": {
            "dc_operation": "Proper DC operating points and biasing",
            "ac_performance": "Gain, bandwidth, phase margin meet specifications",
            "transient_response": "Settling time, slew rate, and distortion within limits",
            "noise_performance": "Noise floor and SNR meet requirements",
            "corner_analysis": "Performance maintained across process corners"
          }
        },
        {
          "name": "export_lvs_clean_layout",
          "description": "Export layout-ready schematic and constraints for LVS-clean layout in Cadence Virtuoso",
          "inputs": ["schematic_cellview", "layout_constraints"],
          "outputs": ["virtuoso_cellview", "lvs_report"],
          "task_templates": {
            "layout_constraints": "Generate layout constraints for matching, symmetry, and routing",
            "cellview_export": "Export schematic to Virtuoso cellview format",
            "lvs_setup": "Configure LVS setup for layout verification"
          },
          "verification_criteria": {
            "lvs_clean": "Layout vs. schematic verification passes",
            "drc_clean": "Design rule checking passes",
            "matching": "Critical devices properly matched and placed",
            "routing": "Signal routing optimized for performance"
          }
        }
      ],
      "tools": {
        "schematic_entry": "Cadence Virtuoso",
        "simulator": "Spectre",
        "layout_tool": "Virtuoso Layout Suite",
        "format": "OpenAccess (OA)",
        "export": "GDSII, OA, DEF"
      },
      "metadata_extensions": {
        "analog": true,
        "pdks_supported": [
          "cadence/tsmc65", 
          "cadence/gf22fdx", 
          "cadence/tsmc28", 
          "cadence/tsmc16",
          "cadence/tsmc40ulp"
        ],
        "simulation_types": [
          "dc", "ac", "transient", "noise", "monte_carlo", "corner",
          "stability", "psrr", "cmrr"
        ],
        "performance_metrics": {
          "gain": "Voltage/current gain specifications",
          "bandwidth": "Frequency response bandwidth",
          "noise": "Input-referred noise density",
          "psrr": "Power supply rejection ratio",
          "cmrr": "Common mode rejection ratio",
          "offset": "Input offset voltage",
          "slew_rate": "Slew rate specifications"
        },
        "layout_requirements": ["matching", "symmetry", "routing", "parasitics"]
      }
    },
    "analog_project_structure": {
      "rtl": {
        "behavioral": "rtl/behavioral/",
        "ams": "rtl/ams/",
        "verilog_a": "rtl/verilog_a/"
      },
      "schematic": {
        "schematic": "schematic/",
        "symbol": "symbol/",
        "netlist": "netlist/"
      },
      "simulation": {
        "spectre": "simulation/spectre/",
        "configs": "simulation/configs/",
        "results": "simulation/results/",
        "waveforms": "simulation/waveforms/"
      },
      "layout": {
        "layout": "layout/",
        "constraints": "layout/constraints/",
        "lvs": "layout/lvs/",
        "drc": "layout/drc/"
      },
      "pdks": {
        "cadence": "pdks/cadence/",
        "models": "pdks/models/",
        "techfiles": "pdks/techfiles/"
      }
    },
    "analog_specific_requirements": {
      "behavioral_modeling": {
        "language": "Verilog-A or SystemVerilog-AMS",
        "accuracy": "Model accuracy within 10% of transistor-level simulation",
        "speed": "Simulation speed 100x faster than transistor-level",
        "parameterization": "Fully parameterized for reusability"
      },
      "circuit_design": {
        "topology": "Standard analog circuit topologies (OTA, bandgap, LDO, etc.)",
        "sizing": "Device sizing for target performance specifications",
        "biasing": "Proper biasing for all operating regions",
        "matching": "Device matching for differential circuits"
      },
      "simulation": {
        "corner_analysis": "Process, voltage, and temperature corner analysis",
        "monte_carlo": "Monte Carlo analysis for process variation",
        "noise_analysis": "Noise analysis for dynamic range requirements",
        "stability": "Stability analysis for feedback circuits"
      },
      "layout": {
        "matching": "Critical device matching and symmetry",
        "routing": "Signal routing for minimal parasitics",
        "shielding": "Signal shielding for noise isolation",
        "power": "Power distribution and decoupling"
      }
    },
    "analog_ip_examples": {
      "operational_amplifier": {
        "description": "Operational amplifier with configurable gain and bandwidth",
        "specifications": {
          "gain": "> 60dB",
          "bandwidth": "> 1MHz",
          "psrr": "> 60dB",
          "cmrr": "> 80dB",
          "noise": "< 10nV/âHz"
        },
        "topology": "Two-stage opamp with Miller compensation",
        "files": [
          "rtl/behavioral/opamp_behavioral.sv",
          "schematic/opamp_schematic.cds",
          "simulation/spectre/opamp_sim.scs",
          "layout/opamp_layout.cds"
        ]
      },
      "bandgap_reference": {
        "description": "Bandgap voltage reference with temperature compensation",
        "specifications": {
          "voltage": "1.2V Â± 2%",
          "temp_coeff": "< 50ppm/Â°C",
          "psrr": "> 40dB",
          "noise": "< 100nV/âHz"
        },
        "topology": "Brokaw cell with curvature correction",
        "files": [
          "rtl/behavioral/bandgap_behavioral.sv",
          "schematic/bandgap_schematic.cds",
          "simulation/spectre/bandgap_sim.scs",
          "layout/bandgap_layout.cds"
        ]
      },
      "ldo_regulator": {
        "description": "Low-dropout voltage regulator with high PSRR",
        "specifications": {
          "dropout": "< 200mV",
          "psrr": "> 60dB at 1kHz",
          "load_regulation": "< 1%",
          "line_regulation": "< 0.1%"
        },
        "topology": "PMOS pass transistor with error amplifier",
        "files": [
          "rtl/behavioral/ldo_behavioral.sv",
          "schematic/ldo_schematic.cds",
          "simulation/spectre/ldo_sim.scs",
          "layout/ldo_layout.cds"
        ]
      }
    },
    "ai_prompts": {
      "generate_behavioral_model": "Generate Verilog-A behavioral model for {analog_block} with specifications: {specs}",
      "design_transistor_circuit": "Design transistor-level circuit for {analog_block} targeting {pdk} with performance requirements: {specs}",
      "create_spectre_simulation": "Create Spectre simulation setup for {analog_block} with corner analysis and Monte Carlo simulation",
      "generate_layout_constraints": "Generate layout constraints for {analog_block} with matching, symmetry, and routing requirements",
      "validate_analog_design": "Validate analog design {analog_block} against specifications: {specs}",
      "optimize_analog_performance": "Optimize {analog_block} for performance metrics: {metrics}",
      "create_analog_testbench": "Create comprehensive testbench for {analog_block} with corner case analysis",
      "generate_analog_documentation": "Generate analog design documentation for {analog_block} with performance analysis and layout guidelines"
    }
  },
  
  "chiplet_workflow_configuration": {
    "description": "Comprehensive chiplet development workflow and multi-die integration",
    "chiplet_development_phases": {
      "phase1_design": {
        "description": "Chiplet architecture and interface design",
        "activities": [
          "Define chiplet boundaries and interfaces",
          "Select die-to-die interface protocols",
          "Design chiplet wrapper and interface logic",
          "Plan power domain partitioning",
          "Define thermal and packaging requirements"
        ],
        "deliverables": [
          "Chiplet architecture specification",
          "Interface protocol definitions",
          "Power domain specifications",
          "Thermal analysis requirements"
        ]
      },
      "phase2_implementation": {
        "description": "RTL implementation and verification",
        "activities": [
          "Implement chiplet wrapper modules",
          "Develop die-to-die interface logic",
          "Create power management logic",
          "Implement test access mechanisms",
          "Develop chiplet-specific testbenches"
        ],
        "deliverables": [
          "Chiplet RTL implementation",
          "Interface verification testbenches",
          "Power domain verification",
          "Multi-die communication tests"
        ]
      },
      "phase3_packaging": {
        "description": "Packaging design and constraints",
        "activities": [
          "Design interposer layout and routing",
          "Define bump map and connectivity",
          "Specify thermal management solutions",
          "Plan power delivery network",
          "Design test access infrastructure"
        ],
        "deliverables": [
          "Interposer design constraints",
          "Bump map specifications",
          "Thermal analysis results",
          "Power delivery specifications"
        ]
      },
      "phase4_integration": {
        "description": "Multi-die system integration",
        "activities": [
          "Integrate multiple chiplets",
          "Verify system-level functionality",
          "Perform thermal and power analysis",
          "Validate signal integrity",
          "Execute system-level testing"
        ],
        "deliverables": [
          "Integrated system design",
          "System-level verification results",
          "Thermal and power analysis reports",
          "Signal integrity analysis"
        ]
      }
    },
    "chiplet_specific_tools": {
      "design_tools": {
        "interposer_design": ["Cadence Virtuoso", "Synopsys IC Compiler", "Mentor Calibre"],
        "thermal_analysis": ["Ansys Icepak", "Cadence Celsius", "Synopsys PrimePower"],
        "signal_integrity": ["Ansys HFSS", "Cadence Sigrity", "Synopsys HSPICE"],
        "power_analysis": ["Synopsys PrimePower", "Cadence Voltus", "Mentor PowerPro"]
      },
      "verification_tools": {
        "multi_die_simulation": ["Synopsys VCS", "Cadence Xcelium", "Mentor Questa"],
        "formal_verification": ["Synopsys VC Formal", "Cadence Jasper", "Mentor Questa Formal"],
        "emulation": ["Synopsys ZeBu", "Cadence Palladium", "Mentor Veloce"]
      },
      "testing_tools": {
        "die_testing": ["Advantest V93000", "Teradyne UltraFLEX", "Cohu Falcon"],
        "system_testing": ["Advantest T2000", "Teradyne J750", "Cohu Diamond"],
        "thermal_testing": ["Thermal imaging cameras", "Thermal test chambers"]
      }
    },
    "chiplet_quality_assurance": {
      "interface_validation": {
        "protocol_compliance": "Validate die-to-die interface protocol compliance",
        "signal_integrity": "Verify signal integrity across interposer",
        "timing_closure": "Ensure timing closure across multiple dies",
        "power_integrity": "Validate power delivery and noise margins"
      },
      "thermal_validation": {
        "junction_temperature": "Verify junction temperature within limits",
        "thermal_resistance": "Validate thermal resistance specifications",
        "cooling_requirements": "Confirm cooling solution adequacy",
        "thermal_cycling": "Test thermal cycling reliability"
      },
      "reliability_validation": {
        "mechanical_stress": "Validate mechanical stress handling",
        "thermal_stress": "Test thermal stress reliability",
        "electrical_stress": "Verify electrical stress tolerance",
        "aging_effects": "Analyze long-term aging effects"
      }
    },
    "chiplet_ecosystem_integration": {
      "standards_compliance": {
        "ucie": "Universal Chiplet Interconnect Express compliance",
        "bow": "Bunch of Wires (BoW) standard compliance",
        "aib": "Advanced Interface Bus (AIB) compliance",
        "emib": "Embedded Multi-die Interconnect Bridge compliance"
      },
      "vendor_integration": {
        "foundry_partners": "Integration with foundry chiplet ecosystems",
        "packaging_partners": "Collaboration with packaging service providers",
        "testing_partners": "Integration with testing service providers",
        "supply_chain": "End-to-end supply chain management"
      },
      "certification": {
        "reliability_certification": "Industry reliability certification",
        "quality_certification": "Quality management system certification",
        "security_certification": "Security and trust certification",
        "compliance_certification": "Regulatory compliance certification"
      }
    },
    "ai_prompts": {
      "design_chiplet_architecture": "Design chiplet architecture with optimal die partitioning and interface selection",
      "implement_chiplet_wrapper": "Implement chiplet wrapper with die-to-die interface and power management",
      "create_chiplet_testbench": "Create comprehensive testbench for chiplet functionality and interfaces",
      "design_interposer_layout": "Design interposer layout with optimal routing and bump placement",
      "analyze_chiplet_thermal": "Perform thermal analysis for chiplet integration and cooling requirements",
      "validate_chiplet_integration": "Validate chiplet integration with system-level verification and testing",
      "optimize_chiplet_power": "Optimize power delivery and management for multi-die chiplet system",
      "certify_chiplet_quality": "Certify chiplet quality and reliability for production deployment"
    }
  },
  
  "catalog_score_guidance": {
    "weighting": {
      "metadata_completeness": 35,
      "test_coverage": 20,
      "code_quality": 15,
      "documentation": 10,
      "discoverability_tags": 10,
      "security_validation": 10
    },
    "chiplet_specific_weighting": {
      "interface_compliance": 25,
      "thermal_analysis": 20,
      "power_integrity": 20,
      "signal_integrity": 15,
      "reliability_validation": 10,
      "ecosystem_integration": 10
    },
    "ai_prompt": "Improve this IP block to raise its catalog quality score"
  },

  "security_and_trust": {
    "description": "Security validation, trust indicators, and supply chain security for IP blocks",
    "security_validation": {
      "description": "Security assessment and validation guidelines for IP blocks",
      "security_levels": {
        "basic": "Standard security practices for general-purpose IP",
        "enhanced": "Enhanced security for sensitive applications",
        "critical": "Critical security for high-assurance systems",
        "certified": "Certified security for regulated environments"
      },
      "validation_areas": {
        "code_security": "Static code analysis for security vulnerabilities",
        "interface_security": "Interface security and access control validation",
        "data_security": "Data protection and encryption requirements",
        "side_channel": "Side-channel attack resistance validation",
        "tamper_resistance": "Tamper detection and resistance mechanisms"
      },
      "tools": {
        "static_analysis": ["verilator", "spyglass", "leda"],
        "security_scanners": ["bandit", "semgrep", "codeql"],
        "formal_verification": ["jkind", "pkind", "kind2"],
        "penetration_testing": ["custom testbenches", "fuzzing", "adversarial testing"]
      },
      "ai_prompts": {
        "security_assessment": "Perform security assessment for {ip_name} with focus on {security_areas}",
        "vulnerability_scan": "Scan {ip_name} for security vulnerabilities using {tools}",
        "security_validation": "Validate security requirements for {ip_name} at {security_level} level",
        "secure_coding": "Implement secure coding practices for {ip_name} following {standards}"
      }
    },
    "trust_indicators": {
      "description": "Trust verification and certification support for IP blocks",
      "trust_levels": {
        "unverified": "No trust verification performed",
        "self_assessed": "Self-assessed trust indicators",
        "third_party": "Third-party trust verification",
        "certified": "Industry certification achieved"
      },
      "trust_metrics": {
        "code_quality": "Code quality and maintainability metrics",
        "test_coverage": "Comprehensive test coverage validation",
        "documentation": "Complete and accurate documentation",
        "peer_review": "Peer review and validation status",
        "community_trust": "Community adoption and feedback",
        "vendor_reputation": "Vendor reputation and track record"
      },
      "certification_standards": {
        "iso_27001": "Information security management",
        "common_criteria": "IT security evaluation criteria",
        "fips_140": "Cryptographic module validation",
        "do_178c": "Software considerations in airborne systems",
        "iec_61508": "Functional safety of electrical/electronic systems"
      },
      "ai_prompts": {
        "trust_assessment": "Assess trust indicators for {ip_name} and suggest improvements",
        "certification_guidance": "Provide guidance for {certification} certification for {ip_name}",
        "trust_metrics": "Calculate trust metrics for {ip_name} based on {criteria}"
      }
    },
    "supply_chain_security": {
      "description": "Secure supply chain practices and validation for IP development",
      "supply_chain_phases": {
        "design": "Secure design practices and validation",
        "development": "Secure development environment and processes",
        "verification": "Secure verification and testing practices",
        "distribution": "Secure distribution and deployment",
        "maintenance": "Secure maintenance and updates"
      },
      "security_practices": {
        "access_control": "Role-based access control and authentication",
        "code_signing": "Digital signature and integrity verification",
        "version_control": "Secure version control and change management",
        "dependency_management": "Secure dependency and third-party component management",
        "audit_trail": "Comprehensive audit trail and logging",
        "incident_response": "Security incident response and recovery"
      },
      "validation_requirements": {
        "provenance": "Component provenance and origin verification",
        "integrity": "Code integrity and tamper detection",
        "authenticity": "Authenticity and authorship verification",
        "compliance": "Regulatory and industry compliance validation"
      },
      "ai_prompts": {
        "supply_chain_assessment": "Assess supply chain security for {ip_name} development process",
        "security_practices": "Implement secure supply chain practices for {ip_name}",
        "compliance_validation": "Validate compliance with {standard} for {ip_name}"
      }
    }
  },
  
  "performance_and_power_analysis": {
    "description": "Performance benchmarking, power analysis, and thermal management for IP blocks",
    "performance_benchmarking": {
      "description": "Standardized performance benchmarking and analysis",
      "performance_metrics": {
        "throughput": "Data processing throughput (Mbps, Gbps)",
        "latency": "Processing latency and response time",
        "frequency": "Maximum operating frequency",
        "area": "Silicon area utilization",
        "efficiency": "Performance per unit area/power",
        "scalability": "Performance scaling with parameters"
      },
      "benchmark_suites": {
        "synthetic": "Synthetic benchmark tests for basic performance",
        "real_world": "Real-world workload simulation",
        "stress": "Stress testing for maximum performance",
        "corner_case": "Corner case performance analysis",
        "comparative": "Comparative analysis against similar IP"
      },
      "measurement_methods": {
        "simulation": "Performance measurement through simulation",
        "emulation": "Performance measurement through emulation",
        "prototyping": "Performance measurement on prototype hardware",
        "production": "Performance measurement on production silicon"
      },
      "ai_prompts": {
        "performance_analysis": "Analyze performance of {ip_name} using {metrics} and {methods}",
        "benchmark_creation": "Create performance benchmarks for {ip_name} with {workloads}",
        "performance_optimization": "Optimize performance of {ip_name} for {target_metrics}",
        "comparative_analysis": "Compare performance of {ip_name} against {baseline}"
      }
    },
    "power_analysis": {
      "description": "Power analysis and optimization for IP blocks",
      "power_metrics": {
        "static_power": "Static power consumption (leakage)",
        "dynamic_power": "Dynamic power consumption (switching)",
        "peak_power": "Peak power consumption",
        "average_power": "Average power consumption",
        "power_efficiency": "Power efficiency (performance per watt)",
        "power_density": "Power density (watts per mmÂ²)"
      },
      "power_analysis_types": {
        "gate_level": "Gate-level power analysis",
        "rtl_level": "RTL-level power estimation",
        "architectural": "Architectural-level power analysis",
        "system_level": "System-level power analysis"
      },
      "power_optimization": {
        "clock_gating": "Clock gating for dynamic power reduction",
        "power_gating": "Power gating for static power reduction",
        "voltage_scaling": "Dynamic voltage scaling",
        "frequency_scaling": "Dynamic frequency scaling",
        "logic_optimization": "Logic optimization for power reduction",
        "memory_optimization": "Memory access optimization"
      },
      "tools": {
        "power_estimation": ["synopsys_power", "cadence_power", "mentor_power"],
        "power_analysis": ["primetime_px", "voltus", "powerpro"],
        "power_optimization": ["design_compiler", "ic_compiler", "innovus"]
      },
      "ai_prompts": {
        "power_analysis": "Analyze power consumption of {ip_name} using {analysis_type}",
        "power_optimization": "Optimize power consumption of {ip_name} using {techniques}",
        "power_estimation": "Estimate power consumption of {ip_name} at {level}",
        "power_efficiency": "Improve power efficiency of {ip_name} for {target}"
      }
    },
    "thermal_management": {
      "description": "Thermal analysis and cooling requirements for IP blocks",
      "thermal_metrics": {
        "junction_temperature": "Maximum junction temperature",
        "thermal_resistance": "Thermal resistance (junction to ambient)",
        "thermal_impedance": "Thermal impedance for transient analysis",
        "power_density": "Power density for thermal analysis",
        "hot_spot_temperature": "Hot spot temperature analysis"
      },
      "thermal_analysis": {
        "steady_state": "Steady-state thermal analysis",
        "transient": "Transient thermal analysis",
        "3d_thermal": "3D thermal analysis for complex geometries",
        "system_level": "System-level thermal analysis"
      },
      "cooling_solutions": {
        "passive": "Passive cooling (natural convection)",
        "active_air": "Active air cooling (forced convection)",
        "liquid_cooling": "Liquid cooling solutions",
        "phase_change": "Phase change cooling (heat pipes, vapor chambers)",
        "thermoelectric": "Thermoelectric cooling"
      },
      "thermal_constraints": {
        "temperature_limits": "Operating temperature limits",
        "thermal_budget": "Thermal budget allocation",
        "cooling_capacity": "Available cooling capacity",
        "thermal_margins": "Thermal safety margins"
      },
      "ai_prompts": {
        "thermal_analysis": "Perform thermal analysis for {ip_name} with {power_profile}",
        "cooling_design": "Design cooling solution for {ip_name} with {constraints}",
        "thermal_optimization": "Optimize thermal performance of {ip_name}",
        "thermal_constraints": "Define thermal constraints for {ip_name} integration"
      }
    }
  },

  "standardized_interfaces": {
    "description": "Use Vyges Standardized Interface Catalog for consistent IP integration",
    "canonical_bus_types": [
      "AXI4",
      "AXI4-Lite", 
      "APB",
      "Wishbone",
      "SPI",
      "I2C"
    ],
    "interface_categories": [
      "bus",
      "clock", 
      "reset",
      "mailbox",
      "interrupt",
      "debug",
      "power",
      "security",
      "memory",
      "misc"
    ],
    "signal_naming_conventions": {
      "clock": "clk, clk_en",
      "reset": "rst_n, init_done",
      "power": "power_on, power_good, pwr_gate_en, pwr_retention",
      "interrupts": "irq, error_irq, timer_irq",
      "debug": "jtag_tck, jtag_tdi, jtag_tdo, jtag_tms, trace_data",
      "security": "fuse_data, fuse_addr, fuse_prog, fuse_done, trng_valid, trng_data"
    },
    "ai_assist_prompts": {
      "use_standard_interfaces": "Use Vyges Standardized Interface Catalog signals and naming conventions for IP integration",
      "validate_interface_compliance": "Validate that interface signals follow Vyges Standardized Interface Catalog conventions",
      "generate_interface_wrapper": "Generate interface wrapper using standardized signal names from Vyges catalog"
    }
  },
  
  "ascii_diagram_conventions": {
    "description": "Conventions for generating ASCII block diagrams of IP blocks and their connections",
    "block_representation": {
      "single_block": {
        "format": "Box with rounded corners using ASCII characters",
        "example": [
          "âââââââââââââââââââââââââââââââââââââââ",
          "â           IP_BLOCK_NAME             â",
          "â                                     â",
          "â  âââââââââââ    âââââââââââ        â",
          "â  â Clock   â    â Reset   â        â",
          "â  â clk_i   â    â rst_n_i â        â",
          "â  âââââââââââ    âââââââââââ        â",
          "â                                     â",
          "â  âââââââââââââââââââââââââââ        â",
          "â  â      Data Interface     â        â",
          "â  â data_i[7:0]             â        â",
          "â  â data_o[7:0]             â        â",
          "â  âââââââââââââââââââââââââââ        â",
          "âââââââââââââââââââââââââââââââââââââââ"
        ]
      },
      "pin_grouping": {
        "clock_reset": "Group clock and reset signals together",
        "data_bus": "Group data bus signals (address, data, control)",
        "control": "Group control signals (enable, valid, ready)",
        "interrupts": "Group interrupt signals",
        "power": "Group power management signals",
        "debug": "Group debug and test signals"
      },
      "signal_annotations": {
        "direction": "Use _i for input, _o for output, _io for bidirectional",
        "width": "Show bus width in brackets [7:0]",
        "active_level": "Use _n suffix for active-low signals",
        "description": "Add brief description after signal name"
      }
    },
    "connection_diagrams": {
      "multi_block": {
        "format": "Show multiple blocks with connecting lines",
        "example": [
          "âââââââââââââââ         âââââââââââââââ",
          "â   CPU       â         â   UART      â",
          "â             â         â Controller  â",
          "â clk_i       âââââââââââ clk_i       â",
          "â rst_n_i     âââââââââââ rst_n_i     â",
          "â             â         â             â",
          "â paddr[7:0]  âââââââââââ paddr[7:0]  â",
          "â pwdata[31:0]âââââââââââ pwdata[31:0]â",
          "â prdata[31:0]âââââââââââ prdata[31:0]â",
          "â psel        âââââââââââ psel        â",
          "â penable     âââââââââââ penable     â",
          "â pwrite      âââââââââââ pwrite      â",
          "â pready      âââââââââââ pready      â",
          "â pslverr     âââââââââââ pslverr     â",
          "â             â         â             â",
          "â             â         â tx_o        âââââº UART_TX",
          "â             â         â rx_i        âââââ UART_RX",
          "âââââââââââââââ         âââââââââââââââ"
        ]
      },
      "connection_annotations": {
        "bus_connections": "Use ââââ for multi-bit connections",
        "single_signals": "Use âââ for single-bit connections",
        "bidirectional": "Use ââââº for bidirectional signals",
        "interface_labels": "Add interface type labels (APB, AXI, etc.)"
      }
    },
    "interface_specific": {
      "apb": {
        "signals": ["pclk", "presetn", "psel", "penable", "pwrite", "paddr", "pwdata", "prdata", "pready", "pslverr"],
        "grouping": "Clock/Reset | Control | Address/Data | Response"
      },
      "axi_lite": {
        "signals": ["aclk", "aresetn", "awaddr", "awvalid", "awready", "wdata", "wstrb", "wvalid", "wready", "bresp", "bvalid", "bready", "araddr", "arvalid", "arready", "rdata", "rresp", "rvalid", "rready"],
        "grouping": "Clock/Reset | Write Address | Write Data | Write Response | Read Address | Read Data"
      },
      "uart": {
        "signals": ["tx", "rx", "cts", "rts"],
        "grouping": "Transmit | Receive | Flow Control"
      },
      "spi": {
        "signals": ["sclk", "mosi", "miso", "ss_n"],
        "grouping": "Clock | Data | Chip Select"
      }
    },
    "generation_rules": {
      "readability": "Use clear spacing and alignment for readability",
      "consistency": "Use consistent symbols and formatting throughout",
      "completeness": "Include all interface signals with proper grouping",
      "annotations": "Add signal descriptions and interface labels",
      "scalability": "Design diagrams to accommodate different IP sizes"
    }
  },
  
  "reference_projects": {
    "simple_digital_ip": {
      "description": "Basic digital IP with APB interface",
      "files": [
        "rtl/pwm_controller.sv",
        "tb/tb_pwm_controller.sv",
        "tb/cocotb/test_pwm_controller.py",
        "flow/openlane/config.json",
        "test/vectors/basic_test.json",
        "docs/architecture.md"
      ]
    },
    "complex_digital_ip": {
      "description": "Complex digital IP with multiple interfaces",
      "files": [
        "rtl/uart_controller.sv",
        "rtl/uart_transmitter.sv",
        "rtl/uart_receiver.sv",
        "tb/tb_uart_controller.sv",
        "tb/cocotb/test_uart_controller.py",
        "flow/openlane/config.json",
        "test/vectors/uart_tests.json",
        "docs/architecture.md"
      ]
    },
    "spi_controller_ip": {
      "description": "SPI Controller IP with comprehensive design documentation and validation",
      "files": [
        "rtl/spi_controller.sv",
        "rtl/spi_master.sv",
        "rtl/spi_slave.sv",
        "rtl/spi_fifo.sv",
        "tb/tb_spi_controller.sv",
        "tb/cocotb/test_spi_controller.py",
        "flow/openlane/config.json",
        "flow/vivado/constraints.xdc",
        "test/vectors/spi_tests.json",
        "docs/SPI_Controller_design.md",
        "docs/architecture.md",
        "docs/waveforms.md"
      ],
      "design_features": [
        "Comprehensive design specification document",
        "Multiple interface support (APB, SPI Master/Slave)",
        "Configurable parameters and register map",
        "Complete validation strategy with test vectors",
        "Visual documentation with ASCII diagrams",
        "Quality assurance and compliance checking"
      ]
    },
    "fpga_optimized_ip": {
      "description": "IP block optimized for FPGA implementation with vendor-specific features",
      "files": [
        "rtl/spi_controller.sv",
        "rtl/spi_fpga_optimized.sv",
        "flow/vivado/vivado_project.tcl",
        "flow/vivado/constraints.xdc",
        "flow/vivado/synthesis.tcl",
        "flow/vivado/implementation.tcl",
        "constraints/vivado/pin_assignment.xdc",
        "constraints/vivado/timing.xdc",
        "ip/vivado/spi_controller_ip.tcl",
        "tb/fpga/tb_fpga_spi_controller.sv",
        "tb/hardware/fpga_test_bench.v",
        "docs/fpga_integration.md",
        "docs/fpga_timing_analysis.md",
        "docs/fpga_utilization_report.md"
      ],
      "fpga_features": [
        "Vendor-specific optimizations (Xilinx/Intel)",
        "FPGA resource utilization optimization",
        "Timing closure and constraint management",
        "IP core integration and configuration",
        "Hardware verification and testing",
        "Bitstream generation and programming"
      ]
    },
    "hybrid_ip": {
      "description": "IP block with analog and digital domains (e.g., SAR ADC)",
      "files": [
        "rtl/digital_core.sv",
        "rtl/analog_interface.vams",
        "tb/tb_digital_core.sv",
        "tb/cocotb/test_digital_core.py",
        "docs/mixed_signal_notes.md"
      ]
    },
    "chiplet_ready_ip": {
      "description": "IP block designed for chiplet integration with die-to-die interfaces",
      "files": [
        "rtl/uart_controller.sv",
        "rtl/ucie_interface.sv",
        "rtl/chiplet_wrapper.sv",
        "tb/tb_chiplet_integration.sv",
        "tb/cocotb/test_chiplet_communication.py",
        "packaging/interposer_constraints.json",
        "packaging/bump_map.csv",
        "packaging/thermal_analysis.json",
        "packaging/power_domains.json",
        "packaging/signal_conformance.json",
        "packaging/lifecycle_metadata.json",
        "docs/chiplet_integration.md",
        "docs/packaging_requirements.md",
        "docs/thermal_analysis.md",
        "docs/power_management.md"
      ]
    },
    "analog_ip": {
      "description": "Analog IP block with behavioral modeling, transistor-level design, and Cadence PDK integration",
      "files": [
        "rtl/behavioral/opamp_behavioral.sv",
        "rtl/verilog_a/opamp_veriloga.va",
        "schematic/opamp_schematic.cds",
        "symbol/opamp_symbol.cds",
        "netlist/opamp_netlist.sp",
        "simulation/spectre/opamp_sim.scs",
        "simulation/configs/opamp_corners.scs",
        "simulation/results/opamp_dc.txt",
        "simulation/results/opamp_ac.txt",
        "simulation/waveforms/opamp_transient.tr0",
        "layout/opamp_layout.cds",
        "layout/constraints/opamp_constraints.txt",
        "layout/lvs/opamp_lvs_setup.cal",
        "layout/drc/opamp_drc_report.txt",
        "pdks/cadence/tsmc65/models.scs",
        "pdks/cadence/tsmc65/techfile.tf",
        "docs/opamp_design_spec.md",
        "docs/opamp_performance_analysis.md",
        "docs/opamp_layout_guidelines.md"
      ],
      "analog_features": [
        "Verilog-A behavioral model with parameterized specifications",
        "Transistor-level schematic with proper device sizing",
        "Spectre simulation setup with corner analysis",
        "Monte Carlo analysis for process variation",
        "Layout-ready design with matching and symmetry",
        "LVS-clean layout verification",
        "Performance analysis and optimization",
        "Comprehensive documentation with specifications"
      ]
    },
    "uvm_ip": {
      "description": "Digital IP block with comprehensive UVM verification methodology",
      "files": [
        "rtl/uart_controller.sv",
        "rtl/uart_transmitter.sv",
        "rtl/uart_receiver.sv",
        "rtl/apb_slave.sv",
        "tb/uvm/test_uart_controller.sv",
        "tb/uvm/uart_controller_env.sv",
        "tb/uvm/uart_controller_agent.sv",
        "tb/uvm/uart_controller_driver.sv",
        "tb/uvm/uart_controller_monitor.sv",
        "tb/uvm/uart_controller_sequence.sv",
        "tb/uvm/uart_controller_item.sv",
        "tb/uvm/uart_controller_scoreboard.sv",
        "tb/uvm/uart_controller_coverage.sv",
        "tb/uvm/uart_controller_testbench.sv",
        "tb/uvm/apb_agent.sv",
        "tb/uvm/apb_driver.sv",
        "tb/uvm/apb_monitor.sv",
        "tb/uvm/apb_sequence.sv",
        "tb/uvm/apb_item.sv",
        "tb/uvm/uart_agent.sv",
        "tb/uvm/uart_driver.sv",
        "tb/uvm/uart_monitor.sv",
        "tb/uvm/uart_sequence.sv",
        "tb/uvm/uart_item.sv",
        "simulation/uvm/run_simulation.tcl",
        "simulation/uvm/coverage_report.txt",
        "simulation/uvm/regression_results.txt",
        "docs/uvm_verification_plan.md",
        "docs/uvm_coverage_analysis.md",
        "docs/uvm_test_scenarios.md"
      ],
      "uvm_features": [
        "Complete UVM testbench with all components (test, env, agent, driver, monitor, sequence, scoreboard, coverage)",
        "Protocol-specific agents for APB and UART interfaces",
        "Constraint-random test generation with coverage feedback",
        "Functional coverage collection and analysis",
        "SystemVerilog assertions for protocol checking",
        "Regression testing framework with multiple test scenarios",
        "CI/CD integration with coverage reporting",
        "Comprehensive verification documentation and test plans"
      ]
    }
  },

  "advanced_verification": {
    "description": "Advanced verification methodologies including formal verification, emulation, and hardware-in-the-loop testing",
    "formal_verification": {
      "description": "Formal verification methodology support for IP blocks",
      "formal_methods": {
        "model_checking": "Model checking for temporal logic verification",
        "theorem_proving": "Theorem proving for mathematical correctness",
        "equivalence_checking": "Equivalence checking between design representations",
        "property_checking": "Property checking using formal assertions",
        "reachability_analysis": "Reachability analysis for state space exploration"
      },
      "formal_tools": {
        "model_checkers": ["jkind", "pkind", "kind2", "nuXmv", "sal"],
        "theorem_provers": ["coq", "isabelle", "hol", "acl2"],
        "equivalence_checkers": ["conformal", "formality", "lec"],
        "property_checkers": ["jasper", "vc_formal", "questa_formal"]
      },
      "formal_properties": {
        "safety": "Safety properties (bad states never reached)",
        "liveness": "Liveness properties (good states eventually reached)",
        "invariants": "Invariant properties (always true conditions)",
        "protocol": "Protocol compliance properties",
        "timing": "Timing and performance properties"
      },
      "verification_goals": {
        "functional_correctness": "Functional correctness verification",
        "protocol_compliance": "Protocol compliance verification",
        "safety_critical": "Safety-critical property verification",
        "security_properties": "Security property verification",
        "performance_guarantees": "Performance guarantee verification"
      },
      "ai_prompts": {
        "formal_specification": "Create formal specification for {ip_name} with {properties}",
        "formal_verification": "Perform formal verification of {ip_name} using {methods}",
        "property_generation": "Generate formal properties for {ip_name} verification",
        "formal_analysis": "Analyze formal verification results for {ip_name}"
      }
    },
    "emulation": {
      "description": "Emulation platform support for IP verification",
      "emulation_platforms": {
        "fpga_based": "FPGA-based emulation platforms",
        "processor_based": "Processor-based emulation platforms",
        "hybrid": "Hybrid emulation platforms",
        "cloud_based": "Cloud-based emulation services"
      },
      "emulation_tools": {
        "fpga_platforms": ["palladium", "veloce", "zeBu", "vcs_emulation"],
        "processor_platforms": ["palladium_z1", "veloce_pro", "zeBu_server"],
        "cloud_services": ["aws_f1", "azure_hardware", "google_tpu"],
        "virtual_platforms": ["qemu", "virtualbox", "vmware"]
      },
      "emulation_benefits": {
        "speed": "Faster execution compared to simulation",
        "capacity": "Larger design capacity",
        "real_world": "Real-world interface testing",
        "software": "Software and hardware co-verification",
        "system_level": "System-level verification"
      },
      "emulation_workflows": {
        "design_compilation": "Design compilation for emulation",
        "test_development": "Test development for emulation",
        "debug_infrastructure": "Debug infrastructure setup",
        "performance_analysis": "Performance analysis on emulation",
        "system_integration": "System integration testing"
      },
      "ai_prompts": {
        "emulation_setup": "Set up emulation environment for {ip_name} using {platform}",
        "emulation_compilation": "Compile {ip_name} for emulation on {platform}",
        "emulation_testing": "Create emulation tests for {ip_name} with {scenarios}",
        "emulation_analysis": "Analyze emulation results for {ip_name}"
      }
    },
    "hardware_in_the_loop": {
      "description": "Hardware-in-the-loop testing for IP verification",
      "hil_testing_types": {
        "rapid_prototyping": "Rapid prototyping with real hardware",
        "real_time_testing": "Real-time testing with hardware interfaces",
        "system_integration": "System integration testing",
        "performance_validation": "Performance validation on real hardware",
        "environmental_testing": "Environmental testing (temperature, vibration)"
      },
      "hil_platforms": {
        "fpga_boards": ["arty_a7", "nexys4", "zybo", "ultra96"],
        "development_boards": ["raspberry_pi", "arduino", "beaglebone"],
        "custom_boards": "Custom development boards",
        "evaluation_boards": "Vendor evaluation boards"
      },
      "hil_benefits": {
        "real_hardware": "Testing on real hardware",
        "real_interfaces": "Real interface testing",
        "performance": "Real performance measurement",
        "reliability": "Reliability testing",
        "environmental": "Environmental factor testing"
      },
      "hil_workflows": {
        "board_setup": "Development board setup and configuration",
        "interface_connection": "Interface connection and routing",
        "test_development": "Test development for hardware",
        "data_collection": "Data collection and analysis",
        "debugging": "Hardware debugging and troubleshooting"
      },
      "ai_prompts": {
        "hil_setup": "Set up hardware-in-the-loop testing for {ip_name} on {platform}",
        "hil_testing": "Create HIL tests for {ip_name} with {interfaces}",
        "hil_analysis": "Analyze HIL test results for {ip_name}",
        "hil_optimization": "Optimize {ip_name} based on HIL test results"
      }
    }
  },

  "ai_ml_support": {
    "description": "Support for AI/ML IP blocks, neural network accelerators, and ML-specific verification methodologies",
    "ai_ip_types": {
      "neural_network_accelerator": "Hardware accelerator for neural network inference/training",
      "ml_processor": "Processor optimized for machine learning workloads",
      "ai_peripheral": "Peripheral IP for AI/ML data movement and preprocessing"
    },
    "ai_ml_features": {
      "quantization": "Support for quantized neural network operations",
      "sparsity": "Sparsity-aware computation and storage",
      "reconfigurability": "Reconfigurable datapaths for AI workloads",
      "on_chip_memory": "On-chip memory for AI model storage",
      "dma_support": "DMA engines for high-throughput data movement"
    },
    "ml_verification": {
      "dataset_driven": "Verification using real-world datasets",
      "golden_model": "Golden model comparison for accuracy",
      "corner_case_generation": "Corner case input generation for ML models",
      "ai_prompts": {
        "generate_ai_ip": "Generate hardware accelerator for {model_type} neural network",
        "verify_ml_ip": "Verify ML IP block using {dataset} and {metrics}",
        "compare_golden_model": "Compare hardware results to golden model for {model_type}",
        "generate_corner_cases": "Generate corner case inputs for {model_type} verification"
      }
    }
  },

  "quality_assurance": {
    "description": "Quality assurance features including code review, static analysis, and security scanning",
    "code_review": {
      "automated_review": "Automated code review using AI and static analysis tools",
      "peer_review": "Peer review workflow for code and documentation",
      "review_checklists": "Standardized review checklists for IP quality"
    },
    "static_analysis": {
      "tools": ["verilator", "spyglass", "codeql", "semgrep"],
      "integration": "CI/CD integration for static analysis and linting"
    },
    "security_scanning": {
      "tools": ["bandit", "semgrep", "codeql"],
      "integration": "Automated security scanning in CI/CD pipeline"
    },
    "ai_prompts": {
      "run_code_review": "Run automated code review for {ip_name} using {tools}",
      "run_static_analysis": "Run static analysis for {ip_name} using {tools}",
      "run_security_scan": "Run security scan for {ip_name} using {tools}"
    }
  },

  "collaboration": {
    "description": "Collaboration and team workflow features for multi-developer projects",
    "team_workflows": {
      "branching": "Branching strategies for collaborative development",
      "merging": "Merging and conflict resolution workflows",
      "review_process": "Code review and approval workflows",
      "issue_tracking": "Issue tracking and project management integration"
    },
    "version_control": {
      "tools": ["git", "github", "gitlab", "bitbucket"],
      "best_practices": "Best practices for version control in hardware projects"
    },
    "ai_prompts": {
      "suggest_branching": "Suggest branching strategy for {project_type}",
      "suggest_review_process": "Suggest code review process for {team_size}",
      "track_issues": "Track issues and progress for {ip_name}"
    }
  },

  "internationalization": {
    "description": "Internationalization, localization, and regional compliance features",
    "multi_language_support": {
      "documentation": "Support for multi-language documentation",
      "ui": "Multi-language user interface support"
    },
    "regional_compliance": {
      "standards": ["CE", "FCC", "RoHS", "REACH", "CCC"],
      "compliance_guidance": "Guidance for regional standards and compliance"
    },
    "localization": {
      "translation": "Translation workflows for documentation and UI",
      "localization_tools": ["poedit", "crowdin", "transifex"]
    },
    "ai_prompts": {
      "translate_docs": "Translate documentation for {ip_name} to {language}",
      "check_compliance": "Check {ip_name} for compliance with {standard}",
      "localize_ui": "Localize user interface for {region}"
    }
  },

  "advanced_ip_types": {
    "description": "Support for advanced IP types including memory, security, and network IP blocks",
    "memory_ip": {
      "controller": "Memory controller IP (DDR, LPDDR, SRAM, etc.)",
      "phy": "Memory PHY IP for high-speed interfaces",
      "ecc": "Error correction and detection features"
    },
    "security_ip": {
      "crypto": "Cryptographic accelerator IP (AES, RSA, ECC, etc.)",
      "trng": "True random number generator IP",
      "secure_boot": "Secure boot and root of trust IP"
    },
    "network_ip": {
      "ethernet": "Ethernet MAC/PHY IP",
      "pcie": "PCI Express controller IP",
      "usb": "USB controller IP",
      "can": "CAN bus controller IP"
    },
    "ai_prompts": {
      "generate_memory_ip": "Generate memory controller IP for {memory_type}",
      "generate_security_ip": "Generate security IP block for {security_feature}",
      "generate_network_ip": "Generate network IP block for {protocol}"
    }
  },

  "ieee_p1735_encryption": {
    "description": "IEEE P1735 standard support for encrypting HDL IP blocks for secure distribution and licensing",
    "standard_overview": {
      "name": "IEEE P1735 - Standard for Encryption of Electronic Design Intellectual Property (IP)",
      "purpose": "Enable secure distribution of HDL IP without revealing internals",
      "supported_vendors": ["Synopsys", "Cadence", "Siemens", "Aldec"],
      "file_extensions": [".vhdp", ".vpe", ".vhdpe", ".vpe"],
      "encryption_method": "AES encryption with RSA/X.509 PKI for key distribution"
    },
    "encryption_components": {
      "aes_encryption": {
        "description": "AES-128 or AES-256 encryption for HDL content",
        "purpose": "Encrypt the actual HDL source code",
        "key_management": "AES keys wrapped with recipient RSA public keys"
      },
      "rsa_key_exchange": {
        "description": "RSA/X.509 public key infrastructure for key distribution",
        "purpose": "Securely distribute AES keys to authorized recipients",
        "certificate_formats": ["PEM", "DER", "X.509"],
        "key_sizes": ["2048-bit", "4096-bit"]
      },
      "digital_signatures": {
        "description": "Digital signatures for tamper detection",
        "purpose": "Prevent unauthorized modification of encrypted IP",
        "algorithms": ["RSA-SHA256", "RSA-SHA512"]
      },
      "usage_rights": {
        "description": "Usage rights encoding for license enforcement",
        "rights_types": {
          "simulation": "Allow simulation of the IP",
          "synthesis": "Allow synthesis of the IP",
          "modification": "Allow modification of the IP",
          "redistribution": "Allow redistribution of the IP",
          "expiration": "Expiration date for license validity"
        }
      }
    },
    "rights_declaration": {
      "description": "XML-based rights declaration for usage control",
      "structure": {
        "rights_block": "Main rights container with tool and value attributes",
        "tool_specification": "Target EDA tool or tool category",
        "value_assignment": "Boolean or string value for the right",
        "expiration_handling": "Date-based expiration for time-limited licenses"
      },
      "example_xml": {
        "simulation_only": "<rights><right tool='simulation' value='true'/><right tool='synthesis' value='false'/></rights>",
        "time_limited": "<rights><right tool='simulation' value='true'/><right tool='synthesis' value='true'/><expiration>2025-12-31</expiration></rights>",
        "vendor_specific": "<rights><right tool='synopsys_vcs' value='true'/><right tool='cadence_xcelium' value='false'/></rights>"
      }
    },
    "project_structure": {
      "encrypted_ip": {
        "description": "Project structure for encrypted IP distribution",
        "directory_layout": {
          "src": "Source HDL files (unencrypted for development)",
          "encrypted": "Encrypted HDL files (.vhdp, .vpe)",
          "licenses": "Customer certificates and public keys",
          "metadata": "Encryption metadata and rights declarations",
          "interfaces": "Unencrypted interface definitions for integration"
        },
        "file_organization": {
          "encrypted_core": "Encrypted implementation files",
          "plaintext_interface": "Unencrypted interface declarations",
          "license_files": "Customer-specific license files",
          "metadata_files": "Encryption and rights metadata"
        }
      }
    },
    "cli_integration": {
      "description": "Future Vyges CLI commands for IEEE P1735 encryption support (not yet implemented)",
      "planned_commands": {
        "encrypt": "Encrypt HDL files using IEEE P1735 standard",
        "decrypt": "Decrypt HDL files (for authorized users)",
        "publish_encrypted": "Publish encrypted IP to Vyges catalog",
        "manage_licenses": "Manage customer licenses and certificates"
      },
      "implementation_status": "Planned for future release - model may change"
    },
    "metadata_extensions": {
      "description": "Vyges metadata extensions for encrypted IP support",
      "encryption_metadata": {
        "encryption_enabled": "Boolean indicating if IP is encrypted",
        "encryption_standard": "IEEE P1735",
        "encryption_algorithm": "AES-128 or AES-256",
        "key_management": "RSA/X.509 PKI",
        "digital_signature": "Boolean indicating if file is signed"
      },
      "licensing_metadata": {
        "license_type": "Type of license (commercial, evaluation, academic)",
        "usage_rights": "Array of usage rights and restrictions",
        "expiration_date": "License expiration date",
        "customer_restrictions": "Customer-specific restrictions",
        "redistribution_policy": "Redistribution permissions"
      },
      "distribution_metadata": {
        "encrypted_files": "List of encrypted file paths",
        "plaintext_interfaces": "List of unencrypted interface files",
        "customer_certificates": "List of authorized customer certificates",
        "decryption_instructions": "Instructions for authorized users"
      }
    },
    "ai_prompts": {
      "setup_encrypted_ip": "Set up IEEE P1735 encrypted IP project structure with proper directory layout and metadata",
      "encrypt_hdl_file": "Encrypt HDL file using IEEE P1735 standard with specified rights and recipient certificate",
      "create_rights_declaration": "Create IEEE P1735 rights declaration XML for specified usage rights and restrictions",
      "generate_customer_certificate": "Generate test X.509 certificate for customer licensing and encryption",
      "setup_license_management": "Set up license management system for encrypted IP with customer certificate handling",
      "create_encrypted_interface": "Create encrypted IP with plaintext interface for integration while protecting core implementation",
      "validate_encryption_setup": "Validate IEEE P1735 encryption setup including certificate validity and rights declaration",
      "generate_encryption_metadata": "Generate Vyges metadata extensions for encrypted IP including licensing and distribution information",
      "create_encryption_workflow": "Create complete encryption workflow for IP distribution including CLI commands and metadata",
      "setup_multi_recipient_encryption": "Set up multi-recipient encryption for distributing IP to multiple customers with different rights",
      "create_hybrid_encryption": "Create hybrid encryption setup with plaintext interface and encrypted core implementation",
      "validate_license_compliance": "Validate license compliance for encrypted IP including rights enforcement and expiration checking",
      "generate_decryption_instructions": "Generate decryption instructions for authorized users of encrypted IP",
      "setup_encrypted_catalog_entry": "Set up encrypted IP catalog entry with proper metadata, licensing, and distribution information"
    },
    "security_considerations": {
      "key_management": {
        "description": "Secure key management practices for IEEE P1735 encryption",
        "best_practices": [
          "Store private keys securely with proper access controls",
          "Use strong RSA key sizes (2048-bit minimum, 4096-bit recommended)",
          "Regularly rotate encryption keys",
          "Implement proper certificate validation",
          "Use secure random number generation for AES keys"
        ]
      },
      "certificate_handling": {
        "description": "Secure certificate handling and validation",
        "requirements": [
          "Validate certificate format and signature",
          "Check certificate expiration dates",
          "Verify certificate authority trust chain",
          "Implement certificate revocation checking",
          "Secure storage of customer certificates"
        ]
      },
      "rights_enforcement": {
        "description": "Usage rights enforcement and compliance",
        "mechanisms": [
          "Embed rights declarations in encrypted files",
          "Validate rights during decryption",
          "Check expiration dates and usage restrictions",
          "Implement audit logging for license usage",
          "Provide clear usage terms and restrictions"
        ]
      }
    },
    "integration_features": {
      "catalog_integration": {
        "description": "Integration with Vyges catalog for encrypted IP",
        "features": [
          "Encrypted IP discovery and search",
          "License type filtering and categorization",
          "Customer-specific access control",
          "Usage rights display and validation",
          "License purchase and distribution workflow"
        ]
      },
      "workflow_integration": {
        "description": "Integration with Vyges development workflow",
        "features": [
          "Seamless encryption during IP development",
          "Automated license generation and management",
          "Integration with CI/CD for encrypted builds",
          "Automated rights validation and enforcement",
          "Customer certificate management workflow"
        ]
      },
      "toolchain_integration": {
        "description": "Integration with EDA toolchains",
        "supported_tools": {
          "synopsys": ["VCS", "Design Compiler", "IC Compiler"],
          "cadence": ["Xcelium", "Genus", "Innovus"],
          "siemens": ["Questa", "ModelSim", "Precision"],
          "aldec": ["Active-HDL", "Riviera-PRO"]
        },
        "integration_methods": [
          "Standard IEEE P1735 file format support",
          "Tool-specific encryption options",
          "License validation during tool execution",
          "Rights enforcement at runtime"
        ]
      }
    },
    "development_flows": {
      "description": "Standardized development flows for different IP types with OSS/COTS tool categorization",
      "tool_categories": {
        "oss": {
          "full_name": "Open Source Software",
          "description": "Free and open-source tools available without licensing costs",
          "characteristics": [
            "No licensing fees",
            "Source code available",
            "Community-driven development",
            "Cross-platform compatibility",
            "Educational and commercial use allowed"
          ]
        },
        "cots": {
          "full_name": "Commercial Off-The-Shelf",
          "description": "Commercial tools requiring licenses and potentially PDK access",
          "characteristics": [
            "Requires licensing fees",
            "Proprietary software",
            "Vendor support available",
            "Industry-standard tools",
            "May require foundry relationships"
          ]
        }
      },
      "flows": {
        "digital_asic": {
          "description": "Standard digital ASIC design flow with synthesis and place-and-route",
          "pdk_required_from": "technology_mapping",
          "tools": {
            "oss": [
              "verilator",
              "yosys",
              "openroad",
              "magic",
              "netgen",
              "klayout",
              "cocotb",
              "gtkwave"
            ],
            "cots": []
          },
          "phases": [
            "requirements",
            "architecture",
            "rtl_generation",
            "testbench",
            "simulation",
            "synthesis",
            "technology_mapping",
            "floorplanning",
            "place_and_route",
            "lvs_drc_sta",
            "gdsii_generation"
          ]
        },
        "digital_fpga": {
          "description": "Digital FPGA flow using fully open-source tools",
          "pdk_required": false,
          "tools": {
            "oss": [
              "verilator",
              "yosys",
              "nextpnr",
              "cocotb",
              "gtkwave"
            ],
            "cots": [
              "vivado",
              "quartus"
            ]
          },
          "phases": [
            "requirements",
            "architecture",
            "rtl_generation",
            "testbench",
            "simulation",
            "synthesis",
            "bitstream_mapping",
            "fpga_flash"
          ]
        },
        "analog_asic": {
          "description": "Analog ASIC flow requiring PDK for circuit-level design and layout",
          "pdk_required_from": "circuit_implementation",
          "tools": {
            "oss": [
              "ngspice",
              "xyce",
              "magic",
              "netgen",
              "klayout",
              "xschem"
            ],
            "cots": [
              "cadence_pdk",
              "virtuoso",
              "spectre"
            ]
          },
          "phases": [
            "requirements",
            "specification",
            "block_diagram",
            "circuit_implementation",
            "simulation",
            "layout",
            "extraction",
            "gdsii_generation"
          ]
        },
        "chiplet_integration": {
          "description": "Chiplet flow focused on metadata-driven integration and system-level validation",
          "pdk_required": false,
          "tools": {
            "oss": [
              "vyges-cli",
              "verilator",
              "cocotb"
            ],
            "cots": []
          },
          "phases": [
            "metadata_definition",
            "interface_specification",
            "wrapper_generation",
            "testbench_generation",
            "packaging_docs",
            "integration_validation"
          ]
        }
      },
      "ai_prompts": {
        "generate_flow_specific_code": "Using the {flow_name} flow, generate {component_type} for {ip_name}, and provide Makefile targets for {target_operations}.",
        "setup_flow_environment": "Set up the {flow_name} development environment with appropriate tools and configurations.",
        "validate_flow_compliance": "Validate the IP block against {flow_name} flow requirements and suggest improvements.",
        "generate_flow_documentation": "Generate documentation specific to the {flow_name} flow for {ip_name}."
      },
      "cli_integration": {
        "init_with_flow": "vyges init --flow {flow_name} --template {template_name}",
        "test_with_flow": "vyges test --flow {flow_name} --ip {ip_name}",
        "generate_flow_config": "vyges generate flow-config --flow {flow_name} --target {target_platform}"
      }
    },
    "open_pdks": {
      "description": "Open-source Process Design Kits (PDKs) available for academic and commercial use",
      "pdks": {
        "sky130": {
          "full_name": "SkyWater 130nm Open PDK",
          "provider": "Google/SkyWater Technology",
          "description": "130nm CMOS process with open-source design rules and models",
          "digital": true,
          "analog": false,
          "mixed_signal": false,
          "features": [
            "Digital design support",
            "Open-source design rules",
            "Community-driven development",
            "Free for academic and commercial use"
          ],
          "supported_tools": ["openlane", "magic", "klayout", "ngspice"],
          "repository": "https://github.com/google/skywater-pdk"
        },
        "ihp130": {
          "full_name": "IHP 130nm Open PDK",
          "provider": "IHP Microelectronics",
          "description": "130nm BiCMOS process with open-source design rules",
          "digital": true,
          "analog": true,
          "mixed_signal": true,
          "features": [
            "BiCMOS technology",
            "Mixed-signal design support",
            "Open-source design rules"
          ],
          "supported_tools": ["openlane", "magic", "klayout"],
          "repository": "https://github.com/IHP-Microelectronics/pdk"
        },
        "gf180": {
          "full_name": "GlobalFoundries 180nm Open PDK",
          "provider": "GlobalFoundries",
          "description": "180nm CMOS process with open-source design rules",
          "digital": true,
          "analog": false,
          "mixed_signal": false,
          "features": [
            "Digital design support",
            "Open-source design rules",
            "Free for academic use"
          ],
          "supported_tools": ["openlane", "magic", "klayout"],
          "repository": "https://github.com/google/gf180mcu-pdk"
        },
        "asap7": {
          "full_name": "ASAP7 7nm Predictive PDK",
          "provider": "Arizona State University",
          "description": "7nm predictive process design kit for research",
          "digital": true,
          "analog": false,
          "mixed_signal": false,
          "features": [
            "Predictive technology models",
            "Research and educational use",
            "Advanced node exploration"
          ],
          "supported_tools": ["openlane", "magic", "klayout"],
          "repository": "https://github.com/The-OpenROAD-Project/asap7"
        },
        "freepdk45": {
          "full_name": "FreePDK45 45nm Predictive PDK",
          "provider": "North Carolina State University",
          "description": "45nm predictive process design kit",
          "digital": true,
          "analog": false,
          "mixed_signal": false,
          "features": [
            "Predictive technology models",
            "Educational and research use",
            "Open-source design rules"
          ],
          "supported_tools": ["openlane", "magic", "klayout"],
          "repository": "https://github.com/The-OpenROAD-Project/FreePDK45"
        },
        "gf12lp": {
          "full_name": "GlobalFoundries 12LP Open PDK",
          "provider": "GlobalFoundries",
          "description": "12nm FinFET process with open-source design rules",
          "digital": true,
          "analog": false,
          "mixed_signal": false,
          "features": [
            "Advanced FinFET technology",
            "Digital design support",
            "Open-source design rules"
          ],
          "supported_tools": ["openlane", "magic", "klayout"],
          "repository": "https://github.com/google/gf180mcu-pdk"
        },
        "gf22fdx": {
          "full_name": "GlobalFoundries 22FDX Open PDK",
          "provider": "GlobalFoundries",
          "description": "22nm FD-SOI process with open-source design rules",
          "digital": true,
          "analog": false,
          "mixed_signal": false,
          "features": [
            "FD-SOI technology",
            "Low power digital design support",
            "Open-source design rules"
          ],
          "supported_tools": ["openlane", "magic", "klayout"],
          "repository": "https://github.com/google/gf180mcu-pdk"
        },
        "intel16": {
          "full_name": "Intel 16nm Open PDK",
          "provider": "Intel",
          "description": "16nm FinFET process with open-source design rules",
          "digital": true,
          "analog": false,
          "mixed_signal": false,
          "features": [
            "FinFET technology",
            "Advanced node support",
            "Open-source design rules"
          ],
          "supported_tools": ["openlane", "magic", "klayout"],
          "repository": "https://github.com/intel/OpenROAD"
        }
      },
      "ai_prompts": {
        "select_pdk": "Based on the IP requirements (digital: {digital}, analog: {analog}, mixed_signal: {mixed_signal}), suggest the most appropriate open PDK from the available options. Filter PDKs by matching boolean flags.",
        "select_digital_pdk": "Suggest open PDKs that support digital design (digital: true) for the given IP requirements.",
        "select_analog_pdk": "Suggest open PDKs that support analog design (analog: true) for the given IP requirements.",
        "select_mixed_signal_pdk": "Suggest open PDKs that support mixed-signal design (mixed_signal: true) for the given IP requirements.",
        "pdk_compatibility": "Check if the IP design is compatible with the selected open PDK technology and boolean flags.",
        "pdk_setup": "Provide setup instructions for the selected open PDK with appropriate tool configurations.",
        "filter_pdks_by_type": "Filter the available open PDKs based on design type requirements: digital={digital}, analog={analog}, mixed_signal={mixed_signal}."
      },
      "cli_integration": {
        "init_with_pdk": "vyges init --pdk {pdk_name} --type {ip_type}",
        "validate_pdk": "vyges validate --pdk {pdk_name} --ip {ip_name}",
        "setup_pdk": "vyges setup-pdk --pdk {pdk_name} --tools {tool_list}"
      }
    },
    "compliance_and_legal": {
      "description": "Legal and compliance considerations for IEEE P1735 implementation",
      "legal_considerations": {
        "licensing": "Ensure proper licensing terms and conditions",
        "compliance": "Comply with IEEE P1735 standard specifications",
        "liability": "Clear liability and warranty disclaimers",
        "jurisdiction": "Applicable law and jurisdiction for disputes"
      },
      "compliance_requirements": {
        "standard_compliance": "Full compliance with IEEE P1735 standard",
        "vendor_compatibility": "Compatibility with major EDA vendor implementations",
        "security_audit": "Regular security audits of encryption implementation",
        "certification": "Industry certification for encryption capabilities"
      }
    }
  },

  "ipxact_conversion": {
    "description": "IP-XACT to Vyges metadata conversion functionality for AI-assisted migration",
    "conversion_mapping": {
      "component_info": {
        "vendor": "Extract vendor name for IP identification",
        "library": "Extract library name for organization",
        "name": "Extract component name for IP naming",
        "version": "Extract version information",
        "description": "Extract component description"
      },
      "ports_to_pins": {
        "port_name": "Map IP-XACT port names to Vyges pin names",
        "direction": "Convert IP-XACT direction (in/out/inout) to Vyges direction (input/output/inout)",
        "width": "Extract bus width from vectors or arrays",
        "signal_type": "Infer signal type from port name and context",
        "description": "Generate pin description from port information"
      },
      "parameters": {
        "parameter_name": "Map IP-XACT parameter names to Vyges parameter names",
        "parameter_type": "Convert IP-XACT parameter types to Vyges types",
        "default_value": "Extract default values and ranges",
        "description": "Preserve parameter descriptions and documentation"
      },
      "bus_interfaces": {
        "interface_name": "Map IP-XACT bus interface names to Vyges interface names",
        "protocol": "Extract bus protocol information (APB, AXI, etc.)",
        "port_maps": "Convert port maps to Vyges signal mappings",
        "abstraction": "Handle abstraction type information"
      },
      "file_sets": {
        "file_set_name": "Map IP-XACT file set names to Vyges file categories",
        "file_paths": "Extract file paths and types",
        "file_types": "Map IP-XACT file types to Vyges file types"
      }
    },
    "conversion_rules": {
      "naming_conventions": {
        "ip_name": "Convert to lowercase with hyphens: {vendor}/{name}",
        "pin_names": "Preserve original names or convert to snake_case",
        "parameter_names": "Convert to UPPER_SNAKE_CASE",
        "interface_names": "Preserve protocol names (APB, AXI, etc.)"
      },
      "type_mapping": {
        "ipxact_types": {
          "bit": "int",
          "string": "string",
          "float": "float",
          "long": "int"
        },
        "direction_mapping": {
          "in": "input",
          "out": "output",
          "inout": "inout"
        },
        "signal_type_inference": {
          "clock_patterns": ["clk", "clock", "pclk", "aclk"],
          "reset_patterns": ["rst", "reset", "preset", "areset"],
          "interrupt_patterns": ["irq", "int", "interrupt"],
          "data_patterns": ["data", "addr", "wdata", "rdata"],
          "control_patterns": ["valid", "ready", "enable", "select"]
        }
      },
      "metadata_structure": {
        "required_fields": [
          "name", "version", "description", "license", "target", 
          "design_type", "maturity", "template", "created", "updated"
        ],
        "optional_fields": [
          "parameters", "interfaces", "files", "test", "flows", "meta"
        ],
        "default_values": {
          "license": "MIT",
          "target": ["asic"],
          "design_type": ["digital"],
          "maturity": "beta",
          "template": "vyges-ip-template@1.0.0"
        }
      }
    },
    "conversion_workflow": {
      "step1_parse": "Parse IP-XACT XML and extract component information",
      "step2_map_ports": "Map IP-XACT ports to Vyges pins with proper naming and types",
      "step3_map_parameters": "Convert IP-XACT parameters to Vyges parameters",
      "step4_map_interfaces": "Map bus interfaces to Vyges interface definitions",
      "step5_map_files": "Convert file sets to Vyges file metadata",
      "step6_generate_metadata": "Generate complete vyges-metadata.json structure",
      "step7_validate": "Validate generated metadata against Vyges schema",
      "step8_enhance": "Enhance metadata with Vyges-specific features and conventions"
    },
    "enhancement_features": {
      "auto_detection": {
        "protocol_detection": "Auto-detect bus protocols from interface names and signals",
        "signal_grouping": "Group related signals into logical interfaces",
        "parameter_validation": "Validate and enhance parameter definitions",
        "interface_standardization": "Standardize interfaces to Vyges conventions"
      },
      "quality_improvements": {
        "description_enhancement": "Improve descriptions for better catalog discoverability",
        "tag_generation": "Generate relevant tags based on IP functionality",
        "category_suggestion": "Suggest appropriate IP categories",
        "maturity_assessment": "Assess and suggest appropriate maturity level"
      },
      "vyges_integration": {
        "cli_commands": "Generate vyges CLI commands for project setup",
        "template_expansion": "Suggest template expansion based on IP complexity",
        "test_generation": "Suggest test generation based on interfaces",
        "documentation": "Generate documentation structure recommendations"
      }
    },
    "ai_prompts": {
      "convert_ipxact": "Convert this IP-XACT XML to Vyges metadata JSON format following the conversion mapping and rules",
      "parse_ipxact_component": "Parse this IP-XACT component and extract basic information (vendor, library, name, version, description)",
      "map_ipxact_ports": "Map these IP-XACT ports to Vyges pins with proper naming, direction, width, and type inference",
      "map_ipxact_parameters": "Convert these IP-XACT parameters to Vyges parameters with proper type mapping and validation",
      "map_ipxact_interfaces": "Map these IP-XACT bus interfaces to Vyges interface definitions with protocol detection",
      "map_ipxact_files": "Convert these IP-XACT file sets to Vyges file metadata with proper categorization",
      "generate_vyges_metadata": "Generate complete vyges-metadata.json from the parsed IP-XACT information",
      "enhance_converted_metadata": "Enhance the converted metadata with Vyges-specific features, tags, and quality improvements",
      "validate_converted_metadata": "Validate the converted metadata against Vyges schema and suggest improvements",
      "suggest_vyges_workflow": "Suggest Vyges CLI commands and workflow steps for the converted IP",
      "compare_ipxact_vyges": "Compare the original IP-XACT structure with the converted Vyges metadata and highlight differences",
      "migrate_ipxact_project": "Provide a complete migration plan from IP-XACT to Vyges including file structure and workflow changes"
    },
    "conversion_examples": {
      "simple_component": {
        "description": "Basic IP-XACT component with ports and parameters",
        "ipxact_input": "IP-XACT XML with basic component definition",
        "vyges_output": "Corresponding vyges-metadata.json structure",
        "conversion_notes": "Key conversion decisions and mappings"
      },
      "complex_component": {
        "description": "Complex IP-XACT component with multiple interfaces and file sets",
        "ipxact_input": "IP-XACT XML with advanced features",
        "vyges_output": "Enhanced vyges-metadata.json with Vyges-specific features",
        "conversion_notes": "Advanced conversion techniques and enhancements"
      },
      "protocol_specific": {
        "description": "IP-XACT component with specific bus protocols (APB, AXI, etc.)",
        "ipxact_input": "IP-XACT XML with protocol-specific interfaces",
        "vyges_output": "Vyges metadata with standardized protocol definitions",
        "conversion_notes": "Protocol detection and standardization"
      }
    },
    "validation_rules": {
      "schema_compliance": "Ensure generated metadata complies with Vyges schema v1.0.0",
      "naming_compliance": "Verify all names follow Vyges naming conventions",
      "interface_compliance": "Validate interfaces follow Vyges Standardized Interface Catalog",
      "completeness_check": "Ensure all required fields are present and populated",
      "quality_assessment": "Assess metadata quality for catalog readiness"
    },
    "error_handling": {
      "parsing_errors": "Handle malformed IP-XACT XML gracefully",
      "mapping_errors": "Provide fallback mappings for unknown elements",
      "validation_errors": "Report validation errors with suggestions for fixes",
      "enhancement_warnings": "Warn about potential quality improvements"
    },
    "integration_features": {
      "cli_integration": "Generate vyges CLI commands for the converted IP",
      "template_integration": "Suggest appropriate Vyges template expansion",
      "catalog_integration": "Prepare metadata for Vyges catalog publication",
      "workflow_integration": "Provide complete Vyges development workflow"
    }
  }
} 