{
  "vyges_version": "1.0.0",
  "ai_context_version": "1.0.0",
  "description": "Defines structural, naming, and workflow conventions to guide AI-assisted hardware IP development within the Vyges platform. Enables consistent code generation, validation, and integration.",
  "copyright": "Â© 2025 Vyges. All Rights Reserved",
  "author": "shivaram@vyges.com",
  
  "date_guidance": "All new or updated metadata should use the actual current UTC date/time (in ISO 8601 format) for 'created', 'updated', and 'generated_at' fields. This includes metadata JSON files if they are updated. Avoid hardcoded dates from the past. Update copyright year annually.",
  
  "git_commit_guidance": "For Git commit messages, don't use double quotes as the command line version will reject the message. Use single quotes or no quotes instead.",
  
  "catalog_objectives": {
    "description": "Ensure generated IP meets requirements for inclusion in the Vyges IP Catalog",
    "requirements": [
      "vyges-metadata.json is complete and conforms to schema",
      "Includes license, maturity, and interface metadata",
      "Includes testbench with pass/fail assertion",
      "Includes minimum documentation in docs/overview.md",
      "Must include basic functional verification (simulation or cocotb)",
      "Supports versioning and reproducibility via source tracking"
    ],
    "ai_assist_prompts": {
      "generate_catalog_ready_ip": "Create a SystemVerilog IP block that is ready for the Vyges Catalog. Include complete metadata, documentation, and testbench.",
      "check_catalog_readiness": "Validate the IP block for Vyges Catalog readiness: metadata coverage, testability, and discoverability."
    }
  },

  "catalog_context": {
    "purpose": "Support Vyges IP Catalog operations and discoverability",
    "fields": {
      "name": "IP package name with org/user prefix",
      "version": "IP version following semantic versioning",
      "interfaces": "Signals and protocols exposed by the IP",
      "target": "asic/fpga target platforms",
      "design_type": "digital|analog|mixed-signal design type",
      "toolchain_support": "validated tools and flows",
      "tags": "discovery tags for catalog search",
      "trust_profile": "security indicators and maturity level",
      "maturity": "alpha|beta|stable|deprecated maturity status",
      "license": "SPDX license identifier",
      "maintainers": "contact information for IP maintainers",
      "chiplet_ready": "boolean indicating if IP is designed for chiplet integration",
      "integration_level": "rtl|netlist|hard_ip indicating integration abstraction level",
      "packaging_considerations": "notes about physical packaging requirements",
      "die_to_die_interfaces": "list of supported die-to-die interface protocols",
      "interposer_constraints": "interposer technology, routing layers, pitch, die spacing",
      "bump_constraints": "bump pitch, size, array configuration, power/signal counts",
      "thermal_constraints": "power limits, junction temperature, thermal resistance, cooling",
      "multi_die_testing": "test access methods, coverage requirements, test vectors",
      "signal_conformance": "protocol compliance, verification tools, test suites",
      "power_domains": "voltage, isolation, retention, current limits per domain",
      "lifecycle": "origin, trusted fabricator, certifications, supply chain tracking"
    },
    "ai_prompts": {
      "generate_catalog_entry": "Generate a catalog-ready summary with name, version, description, interfaces, targets, tags, and trust indicators for the Vyges IP Catalog.",
      "catalog_search_query": "Given IP metadata, suggest effective search keywords and tags to improve discoverability in the Vyges IP Catalog.",
      "improve_catalog_presentation": "Enhance IP metadata for better catalog presentation: improve description, add relevant tags, optimize discoverability.",
      "validate_catalog_compliance": "Check IP metadata for Vyges Catalog compliance: required fields, format validation, and completeness."
    },
    "discoverability_features": {
      "tags": "Generate relevant tags for IP discovery (e.g., uart, communication, apb, asic, fpga)",
      "keywords": "Extract search keywords from IP description and interfaces",
      "categories": "Suggest appropriate catalog categories based on IP type and interfaces",
      "related_ips": "Identify related IPs in the catalog based on interfaces and functionality"
    }
  },

  "template_integration": {
    "mode": "hybrid",
    "description": "Use codegen + AI to scaffold IP repos: template + AI phase optimize for maximum developer productivity",
    "ai_prompts": {
      "bootstrap_project": "Generate directory structure and basic RTL/test files based on metadata using the vyges-ip-template as base.",
      "customize_template": "Customize the vyges-ip-template structure for specific IP requirements and target platforms.",
      "expand_template": "Expand the minimal template structure with additional directories and files based on IP complexity.",
      "optimize_structure": "Optimize project structure for the specific IP type, interfaces, and target platforms."
    },
    "workflow": {
      "start_with_template": "Begin with vyges-ip-template as the foundation",
      "ai_customization": "Use AI to customize structure and generate initial files",
      "progressive_expansion": "Expand complexity using vyges expand commands",
      "metadata_driven": "Use vyges-metadata.json to guide all customizations"
    },
    "benefits": [
      "Reduces cognitive load and setup time",
      "Ensures consistency with Vyges conventions",
      "Enables rapid prototyping and iteration",
      "Supports both simple and complex IP development"
    ]
  },
  
  "metadata_driven_generation": {
    "description": "Use vyges-metadata.json as canonical source of truth for generating specifications and code",
    "capabilities": {
      "specification_generation": {
        "input": "vyges-metadata.json fields (name, description, parameters, interfaces, target, design_type, toolRequirements, flows, test, performance)",
        "output": "docs/specification.md - Human-readable requirements document",
        "template_sections": [
          "Overview",
          "Target (ASIC/FPGA)",
          "Interfaces",
          "Parameters",
          "Tool Requirements",
          "Testing"
        ]
      },
      "design_document_generation": {
        "input": "vyges-metadata.json with comprehensive IP specifications",
        "output": "docs/{IP_NAME}_design_spec.md - Complete design specification document",
        "template_sections": [
          "Project Metadata",
          "Design Flow",
          "Functional Requirements",
          "Interface Design",
          "Register Map",
          "Timing Specifications",
          "Pinout and Package",
          "Validation Strategy",
          "RTL and Testbench Development",
          "Flow Configuration",
          "Documentation Requirements",
          "Testing and Verification",
          "Integration Guidelines",
          "CI/CD Pipeline",
          "Catalog Publication"
        ],
        "quality_requirements": {
          "completeness": "All sections must be populated with relevant information",
          "consistency": "Interface definitions must match vyges-metadata.json",
          "traceability": "Requirements must be traceable to implementation",
          "validation": "Include validation criteria and test strategies",
          "visual_aids": "Include ASCII diagrams for block representation and connections"
        }
      },
      "code_generation": {
        "rtl_scaffolding": "Generate RTL modules in rtl/*.sv based on interfaces and parameters",
        "testbench_generation": "Create testbenches in SystemVerilog or Python (cocotb) based on test specifications",
        "flow_configuration": "Generate tool configurations in flow/ based on toolRequirements",
        "documentation": "Generate README, LICENSE, and integration scripts",
        "metadata_annotation": "Annotate RTL with metadata comments based on vyges-metadata.json",
        "verification_targets": "Embed assertions and coverage based on test block specifications"
      }
    },
    "ai_assist_prompts": {
      "generate_from_metadata": "Generate complete IP specification and code scaffolding from vyges-metadata.json",
      "generate_design_document": "Generate comprehensive design specification document following Vyges conventions with all required sections, quality requirements, and visual aids",
      "update_metadata_from_code": "Update vyges-metadata.json based on changes in RTL code and interfaces",
      "synchronize_metadata_code": "Ensure vyges-metadata.json and generated code are in sync"
    },
    "branding_guidance": "Always include a 'branding' property at the top level of vyges-metadata.json. Example: 'branding': { 'provider': 'Vyges', 'logo': 'https://vyges.com/images/logo.svg', 'website': 'https://vyges.com/catalog', 'usage': 'Use of the logo is permitted for attribution or compatibility references only.' }. This ensures catalog and UI consistency and enables robust provider branding.",
    "notes": "The pinout table in documentation and README should be auto-generated from the interfaces section of vyges-metadata.json for consistency."
  },
  
  "project_structure": {
    "conventions": {
      "naming": {
        "repository": "{orgname}/{repo-name} or {username}/{repo-name} (e.g., vyges/uart-controller, janedoe/pwm-generator)",
        "repository_workflow": {
          "step1": "Create new repository using GitHub 'Use this template' button from vyges-ip-template",
          "step2": "Clone the newly created repository (not the template repository)",
          "step3": "Use Vyges CLI to initialize the project in current directory",
          "warning": "Ensure Git remote points to new repository, not template repository",
          "fix_command": "git remote remove origin && git remote add origin https://github.com/{org}/{repo}.git",
          "cli_fix": "Use 'vyges init --fix-remote' or 'vyges quickstart --fix-remote' to automatically remove template remote",
          "functional_ip_principle": "Each repository represents one functional IP in the catalog (e.g., uart-controller contains UART Master, FIFO, and other components as one functional unit)"
        },
        "ip_name": "lowercase with hyphens/underscores, 3-50 chars, start with letter, no consecutive hyphens/underscores",
        "modules": "snake_case (e.g., pwm_controller, uart_transmitter)",
        "files": "snake_case.sv (e.g., pwm_controller.sv, uart_transmitter.sv)",
        "testbenches": "tb_<module_name>.sv (e.g., tb_pwm_controller.sv)",
        "parameters": "UPPER_SNAKE_CASE (e.g., CLOCK_FREQUENCY, DATA_WIDTH)",
        "signals": "snake_case (e.g., clock_i, data_o, enable_n)"
      },
      "organization": {
        "rtl_files": "Place all RTL modules in rtl/ directory",
        "testbench_files": "Place all testbenches in tb/ directory",
        "test_files": "Place test vectors and coverage in test/ directory",
        "documentation": "Place all docs in docs/ directory",
        "flow_configs": "Place tool configurations in flow/ directory",
        "simulation_files": "Place simulation scripts and Makefiles under sim/",
        "constraints": "Place synthesis/implementation constraints (e.g., SDC, XDC) in constraints/"
      },
      "advanced_patterns": {
        "multi_platform": "For projects targeting both ASIC and FPGA, or including analog/mixed-signal, create subdirectories under rtl/, flow/, and constraints/ for asic/, fpga/, digital/, analog/, etc. The CLI should offer to expand the structure as needed.",
        "directory_expansion": {
          "rtl": {
            "asic": "ASIC-specific RTL (digital and analog)",
            "fpga": "FPGA-specific RTL (digital only)",
            "digital": "Digital RTL (platform-agnostic)",
            "analog": "Analog/mixed-signal RTL (ASIC only)"
          },
          "constraints": {
            "asic": "ASIC synthesis and timing constraints",
            "fpga": "FPGA implementation constraints"
          },
          "flow": {
            "asic": "ASIC tool flows (OpenLane, Synopsys, etc.)",
            "fpga": "FPGA tool flows (Vivado, Quartus, etc.)"
          },
          "packaging": {
            "interposer": "Interposer design and routing constraints",
            "bump_map": "Bump map definitions for die-to-die connections",
            "thermal": "Thermal analysis and constraints for multi-die systems"
          }
        }
      }
    },
    
    "required_patterns": {
      "module_header": {
        "description": "Every RTL module must have a standardized header",
        "template": [
          "//=============================================================================",
          "// Module Name: {module_name}",
          "//=============================================================================",
          "// Description: {description}",
          "//",
          "// Features:",
          "// - {feature1}",
          "// - {feature2}",
          "//",
          "// Author: {author}",
          "// License: {license}",
          "//============================================================================="
        ]
      },
      
      "interface_patterns": {
        "clock_reset": "All modules must have clock_i and reset_n_i signals",
        "apb_slave": "APB slave interface must follow standard APB protocol signals: pclk, presetn, psel, penable, pwrite, paddr, pwdata, prdata, pready, pslverr",
        "axi_master": "AXI master interface must follow standard AXI protocol signals",
        "axi_lite_slave": "AXI-Lite slave interface must include: aclk, aresetn, awaddr, awvalid, awready, wdata, wstrb, wvalid, wready, bresp, bvalid, bready, araddr, arvalid, arready, rdata, rresp, rvalid, rready",
        "wishbone": "Wishbone interface must include: wb_clk_i, wb_rst_i, wb_cyc_i, wb_stb_i, wb_ack_o, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i",
        "spi_master": "SPI master interface must include: sclk_o, mosi_o, miso_i, ss_n_o[N-1:0], busy_o, done_o, data_valid_o, data_ready_i",
        "spi_slave": "SPI slave interface must include: sclk_i, mosi_i, miso_o, ss_n_i, busy_o, done_o, data_valid_o, data_ready_i",
        "interrupts": "Interrupt signals should be named irq_<description>_o",
        "power_management": "Power signals: power_on, power_good, pwr_gate_en, pwr_retention",
        "mailbox": "Mailbox interface: mbx_req, mbx_ack, mbx_addr, mbx_data, mbx_we, mbx_valid, mbx_ready",
        "debug": "Debug interface: jtag_tck, jtag_tdi, jtag_tdo, jtag_tms, trace_data",
        "security": "Security interface: fuse_data, fuse_addr, fuse_prog, fuse_done, trng_valid, trng_data",
        "chiplet_interfaces": {
          "ucie": "UCIe interface signals: ucie_clk, ucie_rst_n, ucie_tx_data, ucie_rx_data, ucie_tx_valid, ucie_rx_valid, ucie_tx_ready, ucie_rx_ready",
          "bow": "Bunch of Wires (BoW) interface: bow_clk, bow_rst_n, bow_tx_data, bow_rx_data, bow_tx_valid, bow_rx_valid",
          "aib": "Advanced Interface Bus (AIB): aib_clk, aib_rst_n, aib_tx_data, aib_rx_data, aib_tx_valid, aib_rx_valid",
          "emib": "Intel EMIB interface: emib_clk, emib_rst_n, emib_tx_data, emib_rx_data, emib_tx_valid, emib_rx_valid"
        }
      },
      
      "testbench_patterns": {
        "structure": "Testbenches must include clock generation, reset sequence, and test stimulus",
        "naming": "Testbench files must be named tb_<module_name>.sv",
        "coverage": "Include basic functional coverage for critical paths",
        "test_categories": "Must include functional, performance, corner case, error, and coverage tests",
        "verification_goals": "Must achieve 95% functional coverage, 90% code coverage, 100% toggle coverage",
        "assertion_requirements": "Must include protocol compliance, safety, and performance assertions",
        "regression_testing": "Must support automated regression testing with CI/CD integration"
      }
    }
  },
  
  "code_generation_rules": {
    "rtl": {
      "language": "SystemVerilog",
      "style": "Use always_ff for sequential logic, always_comb for combinational logic",
      "assertions": "Include basic assertions for critical functionality",
      "parameters": "Use parameters for configurable features",
      "comments": "Include detailed comments for complex logic",
      "naming_comment_convention": "Use // <type>: <description> for inline comments (e.g., // signal: rising edge detector)",
      "port_direction_comment": "Use comments above ports for direction and purpose"
    },
    
    "testbench": {
      "language": "SystemVerilog",
      "structure": [
        "Clock and reset generation",
        "DUT instantiation",
        "Test stimulus generation",
        "Response checking",
        "Coverage collection"
      ],
      "verification": "Include basic functional verification and coverage",
      "test_categories": {
        "functional_tests": "Basic functionality, protocol compliance, interface verification",
        "performance_tests": "Maximum frequency, throughput measurement, latency analysis",
        "corner_case_tests": "FIFO overflow/underflow, timeout conditions, reset behavior",
        "error_tests": "Protocol violations, error injection, fault tolerance",
        "coverage_tests": "Functional coverage, code coverage, toggle coverage, FSM coverage"
      },
      "verification_requirements": {
        "coverage_goals": "95% functional coverage, 90% code coverage, 100% toggle coverage",
        "assertion_requirements": "Protocol compliance assertions, safety assertions, performance assertions",
        "waveform_requirements": "Comprehensive waveform generation for debugging and analysis",
        "regression_requirements": "Automated regression testing with CI/CD integration"
      }
    },
    
    "cocotb": {
      "language": "Python",
      "framework": "cocotb",
      "structure": [
        "Import cocotb and required triggers",
        "Create coroutine with `@cocotb.test()`",
        "Drive inputs and check outputs",
        "Include test cases for edge conditions",
        "Add coverage collection and assertions",
        "Include waveform generation and analysis"
      ],
      "file_structure": {
        "location": "tb/cocotb/",
        "file_naming": "test_<module_name>.py"
      },
      "integration_notes": "Ensure Makefile or sim/ run script supports cocotb test execution",
      "supported_simulators": {
        "open_source": ["verilator", "icarus", "ghdl"],
        "commercial": ["vcs", "xcelium", "questa", "riviera-pro"],
        "ci_integration": "Use verilator for CI/CD pipelines, commercial tools for development"
      },
      "advanced_features": {
        "auto_generation": "Generate cocotb testbenches from vyges-metadata.json test specifications",
        "verification_harness": "Bundle cocotb-based verification harnesses into packaging metadata",
        "ci_hooks": "CI hooks that run testbenches with cocotb + verilator/vcs, returning waveform artifacts and coverage",
        "python_ecosystem": "Integrate with pytest, numpy, pandas for advanced test analysis",
        "mixed_signal": "Support mixed-signal testing with Python's scientific computing capabilities",
        "ai_driven_testing": "Enable AI-driven test generation and analysis using Python ML libraries"
      },
      "chinese_eda_adaptation": {
        "toolchain_isolation": "Provide cocotb-style testbench adapters for non-cocotb-compatible simulators",
        "python_harness": "Offer Python-based verification harness even with proprietary Chinese tools",
        "abstraction_layer": "Abstract cocotb under Vyges CI runner for tool-agnostic verification"
      },
      "test_categories": {
        "functional_tests": "Basic functionality, protocol compliance, interface verification",
        "performance_tests": "Maximum frequency, throughput measurement, latency analysis",
        "corner_case_tests": "FIFO overflow/underflow, timeout conditions, reset behavior",
        "error_tests": "Protocol violations, error injection, fault tolerance",
        "coverage_tests": "Functional coverage, code coverage, toggle coverage, FSM coverage"
      },
      "verification_requirements": {
        "coverage_goals": "95% functional coverage, 90% code coverage, 100% toggle coverage",
        "assertion_requirements": "Protocol compliance assertions, safety assertions, performance assertions",
        "waveform_requirements": "Comprehensive waveform generation for debugging and analysis",
        "regression_requirements": "Automated regression testing with CI/CD integration"
      },
      "ai_prompts": {
        "generate_cocotb_test": "Create a Python cocotb testbench for module {module_name}, covering {interfaces}, with clock/reset and basic stimulus, using metadata parameters.",
        "add_test_vectors": "Generate example input vectors for functional cocotb simulation based on interface definitions.",
        "create_advanced_tests": "Generate comprehensive cocotb tests with coverage, assertions, and edge case testing.",
        "setup_cocotb_ci": "Configure CI/CD pipeline for cocotb testing with multiple simulators and coverage reporting.",
        "generate_test_categories": "Generate comprehensive test categories including functional, performance, corner case, and error tests",
        "create_verification_plan": "Create detailed verification plan with coverage goals, assertion requirements, and regression strategy"
      },
      "code_generation_rules": {
        "directory": "tb/cocotb/",
        "filename_pattern": "test_<module_name>.py",
        "imports": ["cocotb", "cocotb.triggers", "cocotb.clock", "cocotb.assertions"],
        "structure": [
          "Define top-level cocotb test coroutine with @cocotb.test()",
          "Clock generation using cocotb.clock.Clock",
          "Reset handling with proper timing",
          "Stimulus sequence with cocotb.triggers",
          "Assertions using cocotb.assertions for verification",
          "Coverage collection and reporting",
          "Waveform generation and analysis"
        ],
        "best_practices": [
          "Use async/await for test coroutines",
          "Include proper error handling and timeouts",
          "Add comprehensive assertions for all outputs",
          "Generate meaningful test names and descriptions",
          "Include parameterized tests for different configurations"
        ]
      }
    },
    
    "documentation": {
      "format": "Markdown",
      "required_sections": [
        "Overview",
        "Interfaces",
        "Parameters",
        "Usage Examples",
        "Testing",
        "Limitations"
      ],
      "style_guidelines": {
        "language": "Use clear English text instead of JSON code blocks for better readability",
        "format": "Present technical information in organized bullet points and tables",
        "accessibility": "Make documentation accessible to both technical and non-technical audiences",
        "structure": "Use consistent formatting with clear headings and logical organization",
        "examples": "Provide practical examples and use cases in plain text format"
      },
      "pinout_table": {
        "description": "Every IP documentation and README should include a Markdown table listing all external signals.",
        "columns": ["Name", "Function", "Direction", "Description"],
        "source": "Derived from vyges-metadata.json interfaces/signals",
        "ai_prompt": "Generate a Markdown pinout table for this IP block, listing all external signals with their function, direction, and description."
      },
      "readme_structure": {
        "required_sections": [
          "Overview with purpose and features",
          "Interfaces table with signal names, directions, and descriptions",
          "Integration info with bus protocols and target usage",
          "Testing & verification table with tool status",
          "Build & test commands",
          "Toolchain & flow support table",
          "File structure documentation",
          "Maintainers table",
          "Related projects links"
        ],
        "optional_sections": [
          "Branding & attribution",
          "Advanced usage examples",
          "Performance characteristics",
          "Known limitations"
        ],
        "badges": [
          "Vyges IP Template badge",
          "Use this template badge",
          "License badge",
          "Build status badge"
        ],
        "tables": {
          "interfaces": "Signal Name | Function | Direction | Description",
          "testing": "Method | Tool | Status",
          "toolchain": "Toolchain | Supported | Location",
          "maintainers": "Name | Role | Contact"
        }
      }
    }
  },
  
  "validation_rules": {
    "structure": {
      "required_files": {
        "vyges-metadata.json": "Required metadata file with v1.0.0 schema compliance",
        "rtl/": "Required directory for RTL sources",
        "tb/": "Required directory for testbenches",
        "flow/": "Required directory for tool configurations",
        "test/": "Required directory for test files",
        "docs/": "Required directory for documentation"
      },
      "optional_files": {
        "constraints/": "Optional directory for physical/synthesis constraints",
        "sim/": "Optional directory for simulation scripts and Makefiles"
      },
      "metadata_validation": "vyges-metadata.json must contain all required fields from v1.0.0 schema",
      "ip_name_validation": "IP name must follow GitHub repository naming conventions and Vyges format rules"
    },
    
    "code_quality": {
      "linting": "All RTL must pass basic linting checks",
      "synthesis": "RTL must be synthesizable",
      "simulation": "Testbenches must run without errors",
      "coverage": "Basic functional coverage must be implemented",
      "cocotb_compatibility": "If cocotb is used, test must run with ghdl/iverilog/verilator"
    },
    
    "design_document_quality": {
      "completeness": {
        "required_sections": "All template sections must be present and populated",
        "interface_coverage": "All interfaces must be documented with signal descriptions",
        "timing_specifications": "Critical timing requirements must be specified",
        "validation_criteria": "Clear validation and test criteria must be defined"
      },
      "consistency": {
        "metadata_alignment": "Design document must align with vyges-metadata.json",
        "interface_definitions": "Interface signals must match across all documentation",
        "naming_conventions": "All names must follow Vyges naming conventions"
      },
      "traceability": {
        "requirements_tracking": "Functional requirements must be traceable to implementation",
        "test_coverage": "Test cases must cover all specified requirements",
        "validation_evidence": "Validation results must demonstrate requirement satisfaction"
      },
      "visual_documentation": {
        "block_diagrams": "ASCII block diagrams must be included for IP representation",
        "connection_diagrams": "Connection diagrams must show interface compatibility",
        "timing_diagrams": "Critical timing relationships must be visually represented"
      },
      "documentation_style": {
        "language": "Use clear English text instead of JSON code blocks for better readability",
        "format": "Present technical information in organized bullet points and tables",
        "accessibility": "Make documentation accessible to both technical and non-technical audiences",
        "structure": "Use consistent formatting with clear headings and logical organization",
        "examples": "Provide practical examples and use cases in plain text format"
      }
    },
    
    "quality_assurance": {
      "review_process": "Design documents must undergo peer review before publication",
      "validation_evidence": "All claims must be supported by test results or analysis",
      "compliance_checking": "Must comply with Vyges standards and industry best practices",
      "maintainability": "Documentation must be maintainable and version-controlled"
    }
  },
  
  "ai_prompts": {
    "create_module": "Create a SystemVerilog module following Vyges conventions. Include proper header, interface signals, and basic functionality.",
    "create_testbench": "Create a SystemVerilog testbench for the given module. Include clock generation, reset sequence, and basic test stimulus.",
    "expand_structure": "Suggest when to use 'vyges expand' commands to add complexity to the project structure.",
    "validate_structure": "Check if the current project structure follows Vyges conventions and suggest improvements.",
    "generate_documentation": "Generate documentation for the functional IP block based on the RTL code and metadata.",
    "refactor_module": "Refactor a SystemVerilog module to improve readability, modularity, and testability. Follow Vyges naming and structure conventions.",
    "add_interface": "Extend the functional IP module by adding a new interface using Vyges Standardized Interface Catalog (e.g., AXI4-Lite, APB, Wishbone). Include port declarations and update documentation.",
    "generate_catalog_ready_ip": "Create a SystemVerilog functional IP block that is ready for the Vyges Catalog. Include complete metadata, documentation, and testbench.",
    "check_catalog_readiness": "Validate the functional IP block for Vyges Catalog readiness: metadata coverage, testability, and discoverability.",
    "improve_catalog_score": "Improve this functional IP block to raise its catalog quality score by enhancing metadata, documentation, and test coverage.",
    "generate_from_metadata": "Generate complete functional IP specification and code scaffolding from vyges-metadata.json",
    "update_metadata_from_code": "Update vyges-metadata.json based on changes in RTL code and interfaces",
    "synchronize_metadata_code": "Ensure vyges-metadata.json and generated code are in sync",
    "validate_ip_name": "Validate IP name format for GitHub compatibility and Vyges ecosystem usage",
    "setup_project": "Guide developer through initial functional IP project setup using vyges init --interactive workflow",
    "use_standard_interfaces": "Use Vyges Standardized Interface Catalog signals and naming conventions for IP integration",
    "validate_interface_compliance": "Validate that interface signals follow Vyges Standardized Interface Catalog conventions",
    "generate_interface_wrapper": "Generate interface wrapper using standardized signal names from Vyges catalog",
    "generate_ascii_diagram": "Generate ASCII block diagram showing functional IP block with all pins, grouped by interface type (clock, reset, data, control, etc.) with signal descriptions",
    "generate_connection_diagram": "Generate ASCII diagram showing connections between multiple functional IP blocks, highlighting pin-to-pin connections and interface compatibility",
    "validate_pin_connections": "Validate pin connections between functional IP blocks for signal compatibility, timing, and protocol compliance",
    "generate_cocotb_testbench": "Generate comprehensive cocotb testbench with coverage, assertions, and waveform generation from vyges-metadata.json test specifications",
    "create_cocotb_harness": "Create cocotb verification harness that can be bundled into packaging metadata for automated testing",
    "setup_cocotb_ci": "Set up CI hooks for cocotb testbenches with verilator/vcs, returning waveform artifacts and coverage reports",
    "adapt_cocotb_chinese_tools": "Create cocotb-style testbench adapters for non-cocotb-compatible Chinese EDA tools",
    "generate_readme": "Generate comprehensive README.md following Vyges conventions with all required sections, tables, and badges",
    "update_readme_sections": "Update specific sections of README.md based on IP metadata and current project state",
    "generate_pinout_table": "Generate a Markdown pinout table for the functional IP block, listing all external signals with columns: Name, Function, Direction, Description, based on vyges-metadata.json.",
    "generate_design_document": "Generate comprehensive design specification document following Vyges conventions with all required sections, quality requirements, and visual aids",
    "validate_design_document": "Validate design document for completeness, consistency, traceability, and visual documentation quality",
    "enhance_design_document": "Improve existing design document by adding missing sections, enhancing visual aids, and ensuring quality compliance",
    "improve_documentation_readability": "Convert JSON code blocks and technical jargon to clear English text for better accessibility and readability",
    "create_chiplet_ready_ip": "Create a chiplet-ready IP block with die-to-die interface support, packaging considerations, and multi-die integration capabilities",
    "validate_chiplet_compatibility": "Validate IP block for chiplet integration readiness: interface compatibility, packaging requirements, and die-to-die connectivity",
    "generate_chiplet_interface": "Generate die-to-die interface wrapper using UCIe, BoW, AIB, or EMIB protocols for chiplet integration",
    "create_multi_die_testbench": "Create testbench for multi-die system simulation with chiplet-to-chiplet communication testing",
    "generate_chiplet_documentation": "Generate chiplet-specific documentation including packaging requirements, die-to-die interface specifications, and integration guidelines",
    "generate_interposer_constraints": "Generate interposer design constraints including technology, routing layers, pitch, and die spacing requirements",
    "create_bump_constraints": "Create bump map constraints with pitch, size, array configuration, and power/signal bump counts",
    "analyze_thermal_constraints": "Analyze and specify thermal constraints including power limits, junction temperature, thermal resistance, and cooling requirements",
    "design_multi_die_testing": "Design multi-die testing strategy with test access methods, coverage requirements, and test vector specifications",
    "validate_signal_conformance": "Validate signal conformance against protocol specifications with compliance testing and verification tools",
    "configure_power_domains": "Configure power domains with voltage levels, isolation requirements, retention capabilities, and current limits",
    "track_lifecycle_metadata": "Track lifecycle and supply chain metadata including origin, trusted fabricator status, certifications, and version control",
    "setup_fpga_project": "Set up FPGA project structure with appropriate toolchain, constraints, and IP cores",
    "generate_fpga_flow": "Generate FPGA-specific flow configuration with synthesis, implementation, and bitstream generation",
    "create_fpga_constraints": "Create FPGA timing and pin constraints for specific board and toolchain",
    "integrate_fpga_ip": "Integrate vendor IP cores with proper configuration and instantiation",
    "validate_fpga_timing": "Validate FPGA timing constraints and perform static timing analysis",
    "generate_fpga_bitstream": "Generate FPGA bitstream with proper synthesis and implementation flow",
    "setup_fpga_simulation": "Set up FPGA-specific simulation environment with vendor tools",
    "create_fpga_testbench": "Create FPGA-specific testbench for hardware verification",
    "analyze_fpga_utilization": "Analyze FPGA resource utilization and optimization opportunities",
    "generate_comprehensive_testbench": "Generate comprehensive testbench with functional, performance, corner case, error, and coverage tests",
    "create_verification_plan": "Create detailed verification plan with coverage goals, assertion requirements, and regression strategy",
    "setup_test_automation": "Set up automated test execution with multiple simulators and coverage reporting",
    "validate_test_coverage": "Validate test coverage against specified goals and requirements"
  },
  
  "cli_integration": {
    "commands": {
      "init": {
        "description": "Initialize a new functional IP project with interactive setup",
        "examples": [
          "vyges init --interactive",
          "vyges init my-ip --type digital --pdk sky130",
          "vyges setup --from-template uart-controller"
        ],
        "features": [
          "Git integration for auto-detecting author",
          "Interactive license selection",
          "Platform and design type selection",
          "Tool auto-configuration",
          "IP name validation",
          "Functional IP principle (one repository = one functional IP)"
        ]
      },
      "validate": {
        "description": "Validates functional IP metadata, project structure, and lint/simulation readiness",
        "example": "vyges validate --strict"
      },
      "expand": {
        "description": "Adds complexity to project structure based on specified features",
        "example": "vyges expand --analog"
      },
      "test": {
        "description": "Runs comprehensive tests and validation for the functional IP block",
        "examples": [
          "vyges test --simulation",
          "vyges test --coverage --goals 95,90,100",
          "vyges test --regression --all-simulators",
          "vyges test --categories functional,performance,corner-case,error"
        ]
      },
      "publish": {
        "description": "Publishes functional IP to Vyges catalog",
        "example": "vyges publish --dry-run"
      },
      "generate": {
        "description": "Generate specifications and code for functional IP from vyges-metadata.json",
        "examples": [
          "vyges generate spec",
          "vyges generate code",
          "vyges generate rtl",
          "vyges generate testbench --lang cocotb",
          "vyges generate flow --tool openlane",
          "vyges generate readme",
          "vyges generate readme --update-sections",
          "vyges generate design-doc",
          "vyges generate design-doc --validate",
          "vyges generate design-doc --enhance",
          "vyges generate fpga-flow --toolchain vivado",
          "vyges generate fpga-constraints --board arty-a7",
          "vyges generate fpga-project --toolchain quartus"
        ]
      },
      "fpga": {
        "description": "Manage FPGA-specific flows and toolchains",
        "examples": [
          "vyges fpga setup --toolchain vivado --board arty-a7",
          "vyges fpga generate-constraints --toolchain vivado --board arty-a7",
          "vyges fpga synthesize --toolchain vivado --project spi_controller",
          "vyges fpga implement --toolchain vivado --project spi_controller",
          "vyges fpga generate-bitstream --toolchain vivado --project spi_controller",
          "vyges fpga simulate --toolchain vivado --testbench tb_spi_controller",
          "vyges fpga analyze-timing --toolchain vivado --project spi_controller",
          "vyges fpga integrate-ip --toolchain vivado --ip uart_controller",
          "vyges fpga program --toolchain vivado --bitstream spi_controller.bit",
          "vyges fpga validate --toolchain vivado --board arty-a7"
        ]
      },
      "cocotb": {
        "description": "Manage cocotb testbenches and verification harnesses",
        "examples": [
          "vyges cocotb generate --ip uart-controller",
          "vyges cocotb setup-ci --simulator verilator",
          "vyges cocotb run --simulator vcs --coverage",
          "vyges cocotb create-harness --bundle-metadata",
          "vyges cocotb generate-categories --ip spi-controller",
          "vyges cocotb create-verification-plan --ip spi-controller",
          "vyges cocotb validate-coverage --ip spi-controller --goals 95,90,100"
        ]
      },
      "diagram": {
        "description": "Generate ASCII block diagrams for functional IP blocks and connections",
        "examples": [
          "vyges diagram block --ip uart-controller",
          "vyges diagram connections --ip1 cpu --ip2 uart-controller",
          "vyges diagram validate --ip1 cpu --ip2 uart-controller"
        ]
      },
      "chiplet": {
        "description": "Manage chiplet-specific features and multi-die integration",
        "examples": [
          "vyges chiplet validate --ip uart-controller",
          "vyges chiplet validate --constraints interposer --ip uart-controller",
          "vyges chiplet validate --constraints thermal --ip uart-controller",
          "vyges chiplet generate-interface --protocol ucie --ip uart-controller",
          "vyges chiplet create-testbench --multi-die --ip1 cpu --ip2 uart-controller",
          "vyges chiplet generate-docs --packaging --ip uart-controller",
          "vyges chiplet generate-constraints --interposer --ip uart-controller",
          "vyges chiplet generate-constraints --bump-map --ip uart-controller",
          "vyges chiplet analyze-thermal --ip uart-controller",
          "vyges chiplet configure-power-domains --ip uart-controller",
          "vyges chiplet validate-conformance --protocol ucie --ip uart-controller",
          "vyges chiplet track-lifecycle --origin vyges/partner-x --ip uart-controller"
        ]
      }
    },
    "suggestions": {
      "when_to_expand": [
        "When adding analog components: vyges expand --analog",
        "When adding commercial tools: vyges expand --commercial-tools",
        "When creating multi-IP project: vyges expand --multi-ip",
        "When targeting multiple platforms or analog/mixed-signal: vyges expand --platform asic,fpga --add-analog",
        "When adding platform-specific constraints: vyges expand --constraints asic,fpga",
        "When creating multi-IP project with different targets: vyges expand --multi-ip --platform asic,fpga"
      ],
      "fpga_workflow": [
        "When targeting FPGA: vyges fpga setup --toolchain vivado --board arty-a7",
        "When generating FPGA constraints: vyges fpga generate-constraints --toolchain vivado --board arty-a7",
        "When synthesizing for FPGA: vyges fpga synthesize --toolchain vivado --project spi_controller",
        "When implementing FPGA design: vyges fpga implement --toolchain vivado --project spi_controller",
        "When generating bitstream: vyges fpga generate-bitstream --toolchain vivado --project spi_controller",
        "When programming FPGA: vyges fpga program --toolchain vivado --bitstream spi_controller.bit"
      ],
      "chiplet_workflow": [
        "When designing chiplet: vyges chiplet validate --ip spi-controller",
        "When implementing chiplet wrapper: vyges chiplet generate-interface --protocol ucie --ip spi-controller",
        "When designing packaging: vyges chiplet generate-constraints --interposer --ip spi-controller",
        "When analyzing thermal: vyges chiplet analyze-thermal --ip spi-controller",
        "When configuring power: vyges chiplet configure-power-domains --ip spi-controller",
        "When testing multi-die: vyges chiplet create-testbench --multi-die --ip1 cpu --ip2 spi-controller",
        "When validating integration: vyges chiplet validate-conformance --protocol ucie --ip spi-controller",
        "When tracking lifecycle: vyges chiplet track-lifecycle --origin vyges/partner-x --ip spi-controller"
      ],
      "metadata_driven_workflow": [
        "Start with vyges-metadata.json as source of truth",
        "Use vyges generate spec to create requirements document",
        "Use vyges generate design-doc to create comprehensive design specification",
        "Use vyges generate code to create RTL scaffolding",
        "Use vyges generate testbench to create verification code"
      ],
      "project_setup_workflow": [
        "Use vyges init --interactive for guided setup",
        "Validate IP name format for GitHub compatibility",
        "Select appropriate license and target platforms",
        "Let CLI auto-configure tools based on choices",
        "Initialize in current directory (one repository = one functional IP)"
      ]
    }
  },
  
  "fpga_flow_configuration": {
    "description": "Comprehensive FPGA tool flow configuration and requirements",
    "supported_toolchains": {
      "vivado": {
        "description": "Xilinx Vivado FPGA flow for Xilinx devices",
        "tools": ["vivado", "vivado_hls", "vitis"],
        "supported_families": ["artix7", "kintex7", "virtex7", "zynq", "ultrascale", "versal"],
        "config_files": {
          "project": "vivado_project.tcl",
          "constraints": "constraints.xdc",
          "synthesis": "synthesis.tcl",
          "implementation": "implementation.tcl",
          "bitstream": "bitstream.tcl"
        },
        "outputs": ["bitstream.bit", "netlist.v", "timing_report.txt", "utilization_report.txt"],
        "board_support": ["arty-a7", "nexys4", "zybo", "ultra96", "kcu105"],
        "ip_catalog": "Xilinx IP Catalog integration",
        "simulation": "Vivado Simulator support",
        "version_requirements": "Vivado 2023.1+ recommended"
      },
      "quartus": {
        "description": "Intel Quartus FPGA flow for Intel/Altera devices",
        "tools": ["quartus", "modelsim", "nios_eds"],
        "supported_families": ["cyclone", "arria", "stratix", "max", "agilex"],
        "config_files": {
          "project": "quartus_project.qpf",
          "constraints": "constraints.sdc",
          "synthesis": "synthesis.qsf",
          "implementation": "implementation.qsf"
        },
        "outputs": ["output.sof", "netlist.v", "timing_report.txt", "power_report.txt"],
        "board_support": ["de10-nano", "de1-soc", "cyclone-v", "arria-10"],
        "ip_catalog": "Intel IP Catalog integration",
        "simulation": "ModelSim support",
        "version_requirements": "Quartus Prime 22.1+ recommended"
      },
      "yosys_symbiflow": {
        "description": "Open-source FPGA flow with Yosys and SymbiFlow",
        "tools": ["yosys", "nextpnr", "symbiflow"],
        "supported_families": ["ice40", "ecp5", "artix7"],
        "config_files": {
          "synthesis": "yosys_synth.tcl",
          "constraints": "constraints.pcf",
          "placement": "nextpnr_config.py"
        },
        "outputs": ["output.bin", "netlist.v", "timing_report.txt"],
        "board_support": ["icebreaker", "ecp5-evn", "arty-a7"],
        "open_source": "Fully open-source toolchain",
        "version_requirements": "Latest stable releases"
      },
      "openfpga": {
        "description": "OpenFPGA framework for customizable FPGA architectures",
        "tools": ["openfpga", "vpr", "odin"],
        "config_files": {
          "architecture": "openfpga_config.xml",
          "placement": "vpr_config.xml",
          "constraints": "constraints.xml"
        },
        "outputs": ["bitstream.bin", "architecture.xml", "routing.txt"],
        "customizable": "User-defined FPGA architecture support",
        "research_oriented": "Academic and research applications"
      }
    },
    "fpga_specific_requirements": {
      "constraints": {
        "timing": "FPGA-specific timing constraints (XDC, SDC, PCF)",
        "pin_assignment": "I/O pin assignment and board-specific constraints",
        "clock_management": "Clock domain crossing and clock constraints",
        "power": "Power consumption and thermal constraints",
        "area": "Resource utilization and area constraints",
        "io_standards": "I/O voltage standards and drive strength"
      },
      "verification": {
        "simulation": "FPGA-specific simulation with vendor tools",
        "timing_analysis": "Static timing analysis for FPGA",
        "power_analysis": "Power consumption analysis",
        "functional_verification": "FPGA-specific functional verification",
        "post_route_simulation": "Post-placement and routing simulation"
      },
      "integration": {
        "ip_cores": "Vendor IP core integration and configuration",
        "board_support": "Board-specific integration and testing",
        "debug": "FPGA debugging and signal analysis tools",
        "programming": "Bitstream generation and programming tools",
        "hardware_testing": "On-board hardware verification"
      }
    },
    "fpga_project_structure": {
      "flow": {
        "vivado": "flow/vivado/",
        "quartus": "flow/quartus/",
        "yosys": "flow/yosys/",
        "openfpga": "flow/openfpga/"
      },
      "constraints": {
        "vivado": "constraints/vivado/",
        "quartus": "constraints/quartus/",
        "yosys": "constraints/yosys/"
      },
      "ip_cores": {
        "vivado": "ip/vivado/",
        "quartus": "ip/quartus/",
        "generic": "ip/generic/"
      },
      "testbenches": {
        "simulation": "tb/simulation/",
        "hardware": "tb/hardware/"
      }
    },
    "ai_prompts": {
      "generate_fpga_flow": "Generate FPGA-specific flow configuration for {toolchain} with appropriate constraints and project files",
      "setup_fpga_project": "Set up FPGA project structure with {toolchain} toolchain, including constraints and IP cores",
      "create_fpga_constraints": "Create FPGA-specific timing and pin constraints for {board} using {toolchain}",
      "integrate_fpga_ip": "Integrate vendor IP cores for {toolchain} with proper configuration and instantiation",
      "validate_fpga_timing": "Validate FPGA timing constraints and perform static timing analysis",
      "generate_fpga_bitstream": "Generate FPGA bitstream with proper synthesis and implementation flow"
    }
  },
  
  "chiplet_workflow_configuration": {
    "description": "Comprehensive chiplet development workflow and multi-die integration",
    "chiplet_development_phases": {
      "phase1_design": {
        "description": "Chiplet architecture and interface design",
        "activities": [
          "Define chiplet boundaries and interfaces",
          "Select die-to-die interface protocols",
          "Design chiplet wrapper and interface logic",
          "Plan power domain partitioning",
          "Define thermal and packaging requirements"
        ],
        "deliverables": [
          "Chiplet architecture specification",
          "Interface protocol definitions",
          "Power domain specifications",
          "Thermal analysis requirements"
        ]
      },
      "phase2_implementation": {
        "description": "RTL implementation and verification",
        "activities": [
          "Implement chiplet wrapper modules",
          "Develop die-to-die interface logic",
          "Create power management logic",
          "Implement test access mechanisms",
          "Develop chiplet-specific testbenches"
        ],
        "deliverables": [
          "Chiplet RTL implementation",
          "Interface verification testbenches",
          "Power domain verification",
          "Multi-die communication tests"
        ]
      },
      "phase3_packaging": {
        "description": "Packaging design and constraints",
        "activities": [
          "Design interposer layout and routing",
          "Define bump map and connectivity",
          "Specify thermal management solutions",
          "Plan power delivery network",
          "Design test access infrastructure"
        ],
        "deliverables": [
          "Interposer design constraints",
          "Bump map specifications",
          "Thermal analysis results",
          "Power delivery specifications"
        ]
      },
      "phase4_integration": {
        "description": "Multi-die system integration",
        "activities": [
          "Integrate multiple chiplets",
          "Verify system-level functionality",
          "Perform thermal and power analysis",
          "Validate signal integrity",
          "Execute system-level testing"
        ],
        "deliverables": [
          "Integrated system design",
          "System-level verification results",
          "Thermal and power analysis reports",
          "Signal integrity analysis"
        ]
      }
    },
    "chiplet_specific_tools": {
      "design_tools": {
        "interposer_design": ["Cadence Virtuoso", "Synopsys IC Compiler", "Mentor Calibre"],
        "thermal_analysis": ["Ansys Icepak", "Cadence Celsius", "Synopsys PrimePower"],
        "signal_integrity": ["Ansys HFSS", "Cadence Sigrity", "Synopsys HSPICE"],
        "power_analysis": ["Synopsys PrimePower", "Cadence Voltus", "Mentor PowerPro"]
      },
      "verification_tools": {
        "multi_die_simulation": ["Synopsys VCS", "Cadence Xcelium", "Mentor Questa"],
        "formal_verification": ["Synopsys VC Formal", "Cadence Jasper", "Mentor Questa Formal"],
        "emulation": ["Synopsys ZeBu", "Cadence Palladium", "Mentor Veloce"]
      },
      "testing_tools": {
        "die_testing": ["Advantest V93000", "Teradyne UltraFLEX", "Cohu Falcon"],
        "system_testing": ["Advantest T2000", "Teradyne J750", "Cohu Diamond"],
        "thermal_testing": ["Thermal imaging cameras", "Thermal test chambers"]
      }
    },
    "chiplet_quality_assurance": {
      "interface_validation": {
        "protocol_compliance": "Validate die-to-die interface protocol compliance",
        "signal_integrity": "Verify signal integrity across interposer",
        "timing_closure": "Ensure timing closure across multiple dies",
        "power_integrity": "Validate power delivery and noise margins"
      },
      "thermal_validation": {
        "junction_temperature": "Verify junction temperature within limits",
        "thermal_resistance": "Validate thermal resistance specifications",
        "cooling_requirements": "Confirm cooling solution adequacy",
        "thermal_cycling": "Test thermal cycling reliability"
      },
      "reliability_validation": {
        "mechanical_stress": "Validate mechanical stress handling",
        "thermal_stress": "Test thermal stress reliability",
        "electrical_stress": "Verify electrical stress tolerance",
        "aging_effects": "Analyze long-term aging effects"
      }
    },
    "chiplet_ecosystem_integration": {
      "standards_compliance": {
        "ucie": "Universal Chiplet Interconnect Express compliance",
        "bow": "Bunch of Wires (BoW) standard compliance",
        "aib": "Advanced Interface Bus (AIB) compliance",
        "emib": "Embedded Multi-die Interconnect Bridge compliance"
      },
      "vendor_integration": {
        "foundry_partners": "Integration with foundry chiplet ecosystems",
        "packaging_partners": "Collaboration with packaging service providers",
        "testing_partners": "Integration with testing service providers",
        "supply_chain": "End-to-end supply chain management"
      },
      "certification": {
        "reliability_certification": "Industry reliability certification",
        "quality_certification": "Quality management system certification",
        "security_certification": "Security and trust certification",
        "compliance_certification": "Regulatory compliance certification"
      }
    },
    "ai_prompts": {
      "design_chiplet_architecture": "Design chiplet architecture with optimal die partitioning and interface selection",
      "implement_chiplet_wrapper": "Implement chiplet wrapper with die-to-die interface and power management",
      "create_chiplet_testbench": "Create comprehensive testbench for chiplet functionality and interfaces",
      "design_interposer_layout": "Design interposer layout with optimal routing and bump placement",
      "analyze_chiplet_thermal": "Perform thermal analysis for chiplet integration and cooling requirements",
      "validate_chiplet_integration": "Validate chiplet integration with system-level verification and testing",
      "optimize_chiplet_power": "Optimize power delivery and management for multi-die chiplet system",
      "certify_chiplet_quality": "Certify chiplet quality and reliability for production deployment"
    }
  },
  
  "catalog_score_guidance": {
    "weighting": {
      "metadata_completeness": 40,
      "test_coverage": 25,
      "code_quality": 15,
      "documentation": 10,
      "discoverability_tags": 10
    },
    "chiplet_specific_weighting": {
      "interface_compliance": 25,
      "thermal_analysis": 20,
      "power_integrity": 20,
      "signal_integrity": 15,
      "reliability_validation": 10,
      "ecosystem_integration": 10
    },
    "ai_prompt": "Improve this IP block to raise its catalog quality score"
  },
  
  "standardized_interfaces": {
    "description": "Use Vyges Standardized Interface Catalog for consistent IP integration",
    "canonical_bus_types": [
      "AXI4",
      "AXI4-Lite", 
      "APB",
      "Wishbone",
      "SPI",
      "I2C"
    ],
    "interface_categories": [
      "bus",
      "clock", 
      "reset",
      "mailbox",
      "interrupt",
      "debug",
      "power",
      "security",
      "memory",
      "misc"
    ],
    "signal_naming_conventions": {
      "clock": "clk, clk_en",
      "reset": "rst_n, init_done",
      "power": "power_on, power_good, pwr_gate_en, pwr_retention",
      "interrupts": "irq, error_irq, timer_irq",
      "debug": "jtag_tck, jtag_tdi, jtag_tdo, jtag_tms, trace_data",
      "security": "fuse_data, fuse_addr, fuse_prog, fuse_done, trng_valid, trng_data"
    },
    "ai_assist_prompts": {
      "use_standard_interfaces": "Use Vyges Standardized Interface Catalog signals and naming conventions for IP integration",
      "validate_interface_compliance": "Validate that interface signals follow Vyges Standardized Interface Catalog conventions",
      "generate_interface_wrapper": "Generate interface wrapper using standardized signal names from Vyges catalog"
    }
  },
  
  "ascii_diagram_conventions": {
    "description": "Conventions for generating ASCII block diagrams of IP blocks and their connections",
    "block_representation": {
      "single_block": {
        "format": "Box with rounded corners using ASCII characters",
        "example": [
          "âââââââââââââââââââââââââââââââââââââââ",
          "â           IP_BLOCK_NAME             â",
          "â                                     â",
          "â  âââââââââââ    âââââââââââ        â",
          "â  â Clock   â    â Reset   â        â",
          "â  â clk_i   â    â rst_n_i â        â",
          "â  âââââââââââ    âââââââââââ        â",
          "â                                     â",
          "â  âââââââââââââââââââââââââââ        â",
          "â  â      Data Interface     â        â",
          "â  â data_i[7:0]             â        â",
          "â  â data_o[7:0]             â        â",
          "â  âââââââââââââââââââââââââââ        â",
          "âââââââââââââââââââââââââââââââââââââââ"
        ]
      },
      "pin_grouping": {
        "clock_reset": "Group clock and reset signals together",
        "data_bus": "Group data bus signals (address, data, control)",
        "control": "Group control signals (enable, valid, ready)",
        "interrupts": "Group interrupt signals",
        "power": "Group power management signals",
        "debug": "Group debug and test signals"
      },
      "signal_annotations": {
        "direction": "Use _i for input, _o for output, _io for bidirectional",
        "width": "Show bus width in brackets [7:0]",
        "active_level": "Use _n suffix for active-low signals",
        "description": "Add brief description after signal name"
      }
    },
    "connection_diagrams": {
      "multi_block": {
        "format": "Show multiple blocks with connecting lines",
        "example": [
          "âââââââââââââââ         âââââââââââââââ",
          "â   CPU       â         â   UART      â",
          "â             â         â Controller  â",
          "â clk_i       âââââââââââ clk_i       â",
          "â rst_n_i     âââââââââââ rst_n_i     â",
          "â             â         â             â",
          "â paddr[7:0]  âââââââââââ paddr[7:0]  â",
          "â pwdata[31:0]âââââââââââ pwdata[31:0]â",
          "â prdata[31:0]âââââââââââ prdata[31:0]â",
          "â psel        âââââââââââ psel        â",
          "â penable     âââââââââââ penable     â",
          "â pwrite      âââââââââââ pwrite      â",
          "â pready      âââââââââââ pready      â",
          "â pslverr     âââââââââââ pslverr     â",
          "â             â         â             â",
          "â             â         â tx_o        âââââº UART_TX",
          "â             â         â rx_i        âââââ UART_RX",
          "âââââââââââââââ         âââââââââââââââ"
        ]
      },
      "connection_annotations": {
        "bus_connections": "Use ââââ for multi-bit connections",
        "single_signals": "Use âââ for single-bit connections",
        "bidirectional": "Use ââââº for bidirectional signals",
        "interface_labels": "Add interface type labels (APB, AXI, etc.)"
      }
    },
    "interface_specific": {
      "apb": {
        "signals": ["pclk", "presetn", "psel", "penable", "pwrite", "paddr", "pwdata", "prdata", "pready", "pslverr"],
        "grouping": "Clock/Reset | Control | Address/Data | Response"
      },
      "axi_lite": {
        "signals": ["aclk", "aresetn", "awaddr", "awvalid", "awready", "wdata", "wstrb", "wvalid", "wready", "bresp", "bvalid", "bready", "araddr", "arvalid", "arready", "rdata", "rresp", "rvalid", "rready"],
        "grouping": "Clock/Reset | Write Address | Write Data | Write Response | Read Address | Read Data"
      },
      "uart": {
        "signals": ["tx", "rx", "cts", "rts"],
        "grouping": "Transmit | Receive | Flow Control"
      },
      "spi": {
        "signals": ["sclk", "mosi", "miso", "ss_n"],
        "grouping": "Clock | Data | Chip Select"
      }
    },
    "generation_rules": {
      "readability": "Use clear spacing and alignment for readability",
      "consistency": "Use consistent symbols and formatting throughout",
      "completeness": "Include all interface signals with proper grouping",
      "annotations": "Add signal descriptions and interface labels",
      "scalability": "Design diagrams to accommodate different IP sizes"
    }
  },
  
  "reference_projects": {
    "simple_digital_ip": {
      "description": "Basic digital IP with APB interface",
      "files": [
        "rtl/pwm_controller.sv",
        "tb/tb_pwm_controller.sv",
        "tb/cocotb/test_pwm_controller.py",
        "flow/openlane/config.json",
        "test/vectors/basic_test.json",
        "docs/architecture.md"
      ]
    },
    "complex_digital_ip": {
      "description": "Complex digital IP with multiple interfaces",
      "files": [
        "rtl/uart_controller.sv",
        "rtl/uart_transmitter.sv",
        "rtl/uart_receiver.sv",
        "tb/tb_uart_controller.sv",
        "tb/cocotb/test_uart_controller.py",
        "flow/openlane/config.json",
        "test/vectors/uart_tests.json",
        "docs/architecture.md"
      ]
    },
    "spi_controller_ip": {
      "description": "SPI Controller IP with comprehensive design documentation and validation",
      "files": [
        "rtl/spi_controller.sv",
        "rtl/spi_master.sv",
        "rtl/spi_slave.sv",
        "rtl/spi_fifo.sv",
        "tb/tb_spi_controller.sv",
        "tb/cocotb/test_spi_controller.py",
        "flow/openlane/config.json",
        "flow/vivado/constraints.xdc",
        "test/vectors/spi_tests.json",
        "docs/SPI_Controller_design.md",
        "docs/architecture.md",
        "docs/waveforms.md"
      ],
      "design_features": [
        "Comprehensive design specification document",
        "Multiple interface support (APB, SPI Master/Slave)",
        "Configurable parameters and register map",
        "Complete validation strategy with test vectors",
        "Visual documentation with ASCII diagrams",
        "Quality assurance and compliance checking"
      ]
    },
    "fpga_optimized_ip": {
      "description": "IP block optimized for FPGA implementation with vendor-specific features",
      "files": [
        "rtl/spi_controller.sv",
        "rtl/spi_fpga_optimized.sv",
        "flow/vivado/vivado_project.tcl",
        "flow/vivado/constraints.xdc",
        "flow/vivado/synthesis.tcl",
        "flow/vivado/implementation.tcl",
        "constraints/vivado/pin_assignment.xdc",
        "constraints/vivado/timing.xdc",
        "ip/vivado/spi_controller_ip.tcl",
        "tb/fpga/tb_fpga_spi_controller.sv",
        "tb/hardware/fpga_test_bench.v",
        "docs/fpga_integration.md",
        "docs/fpga_timing_analysis.md",
        "docs/fpga_utilization_report.md"
      ],
      "fpga_features": [
        "Vendor-specific optimizations (Xilinx/Intel)",
        "FPGA resource utilization optimization",
        "Timing closure and constraint management",
        "IP core integration and configuration",
        "Hardware verification and testing",
        "Bitstream generation and programming"
      ]
    },
    "hybrid_ip": {
      "description": "IP block with analog and digital domains (e.g., SAR ADC)",
      "files": [
        "rtl/digital_core.sv",
        "rtl/analog_interface.vams",
        "tb/tb_digital_core.sv",
        "tb/cocotb/test_digital_core.py",
        "docs/mixed_signal_notes.md"
      ]
    },
    "chiplet_ready_ip": {
      "description": "IP block designed for chiplet integration with die-to-die interfaces",
      "files": [
        "rtl/uart_controller.sv",
        "rtl/ucie_interface.sv",
        "rtl/chiplet_wrapper.sv",
        "tb/tb_chiplet_integration.sv",
        "tb/cocotb/test_chiplet_communication.py",
        "packaging/interposer_constraints.json",
        "packaging/bump_map.csv",
        "packaging/thermal_analysis.json",
        "packaging/power_domains.json",
        "packaging/signal_conformance.json",
        "packaging/lifecycle_metadata.json",
        "docs/chiplet_integration.md",
        "docs/packaging_requirements.md",
        "docs/thermal_analysis.md",
        "docs/power_management.md"
      ]
    }
  }
} 