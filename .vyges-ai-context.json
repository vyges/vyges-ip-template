{
  "vyges_version": "1.0.0",
  "ai_context_version": "1.0.0",
  "context_type": "ai_workflow",
  "description": "AI integration, workflow automation, and advanced verification for Vyges IP development. Covers AI prompts, workflow patterns, and verification methodologies.",
  "copyright": "Â© 2025 Vyges. All Rights Reserved",
  "author": "shivaram@vyges.com",
  "date_guidance": "All new or updated metadata should use the actual current UTC date/time (in ISO 8601 format) for created, updated, and generated_at fields. This includes metadata JSON files if they are updated. Avoid hardcoded dates from the past. Update copyright year annually.",
  "git_commit_guidance": "For Git commit messages, do not use double quotes as the command line version will reject the message. Use single quotes or no quotes instead.",
  "critical_ai_instructions": {
    "description": "CRITICAL instructions that must ALWAYS be followed when generating code, documents, or metadata",
    "date_handling": {
      "rule": "ALWAYS use the `date` command to get the current date/time",
      "command": "date -u +%Y-%m-%dT%H:%M:%SZ",
      "usage": "Use this command to get current UTC date/time in ISO 8601 format for all 'created', 'updated', and 'generated_at' fields",
      "prohibition": "NEVER use pattern matching based on existing files in the current repo for dates",
      "examples": [
        "metadata.json: 'created': '$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
        "documentation: 'Last updated: $(date -u +%Y-%m-%d)'",
        "commit messages: 'Updated on $(date -u +%Y-%m-%d)'"
      ]
    },
    "repository_name_detection": {
      "rule": "ALWAYS use `git rev-parse --show-toplevel` to get the correct repository name",
      "command": "basename $(git rev-parse --show-toplevel)",
      "usage": "Use this command to get the correct repo name for IP block names, metadata files, and documentation",
      "importance": "This is critical as the same name gets into generated metadata files, documentation, and other artifacts",
      "prohibition": "NEVER guess or use hardcoded repository names",
      "examples": [
        "IP block name: Use repo name from git rev-parse",
        "Metadata files: Use repo name for file naming",
        "Documentation: Use repo name in headers and titles"
      ]
    },
    "context_file_protection": {
      "rule": "NEVER update .vyges-ai-context.json file in any repository unless explicitly asked to do so",
      "prohibition": "Do not modify, update, or regenerate .vyges-ai-context.json files",
      "exception": "Only update when user explicitly requests: 'Update .vyges-ai-context.json' or similar",
      "reason": "This file contains critical configuration and should only be changed intentionally"
    },
    "enforcement": "These rules are MANDATORY and must be followed in ALL code generation, documentation creation, and metadata updates"
  },
  "project_structure": {
    "conventions": {
      "naming": {
        "repository": "{orgname}/{repo-name} or {username}/{repo-name} (e.g., vyges/uart-controller, janedoe/pwm-generator)",
        "repository_workflow": {
          "step1": "Create new repository using GitHub 'Use this template' button from vyges-ip-template",
          "step2": "Clone the newly created repository (not the template repository)",
          "step3": "Use Vyges CLI to initialize the project in current directory",
          "warning": "Ensure Git remote points to new repository, not template repository",
          "fix_command": "git remote remove origin && git remote add origin https://github.com/{org}/{repo}.git",
          "cli_fix": "Use 'vyges init --fix-remote' or 'vyges quickstart --fix-remote' to automatically remove template remote",
          "functional_ip_principle": "Each repository represents one functional IP in the catalog (e.g., uart-controller contains UART Master, FIFO, and other components as one functional unit)",
          "namespace_safety_principle": "Use {block}_{module}.sv naming to prevent namespace collisions when integrating multiple IP blocks from different vendors or organizations"
        },
        "ip_name": "lowercase with hyphens/underscores, 3-50 chars, start with letter, no consecutive hyphens/underscores",
        "modules": "snake_case (e.g., pwm_controller, uart_transmitter)",
        "files": "{block}_{module}.sv (e.g., fft_memory_interface.sv, fft_rescale_unit.sv)",
        "testbenches": "tb_<module_name>.sv (e.g., tb_pwm_controller.sv)",
        "parameters": "UPPER_SNAKE_CASE (e.g., CLOCK_FREQUENCY, DATA_WIDTH)",
        "signals": "snake_case (e.g., clock_i, data_o, enable_n)",
        "parameter_namespace_isolation": "All global scope parameters and defines must include IP block prefix (e.g., {BLOCK}_DATA_WIDTH, {BLOCK}_APB_ADDR_WIDTH) to prevent namespace collisions between different IP blocks",
        "define_macro_prefixing": "All `define macros in global scope must include IP block prefix (e.g., `define {BLOCK}_DATA_WIDTH, `define {BLOCK}_STATUS_IDLE) to ensure namespace isolation",
        "typedef_namespace_isolation": "All typedef declarations in global scope must include IP block prefix (e.g., {block}_data_t, {block}_twiddle_t) to prevent type name conflicts",
        "module_parameter_consistency": "Module parameters must use the same prefixed names throughout the IP block for consistency and maintainability",
        "namespace_collision_prevention": "Use IP block prefix (e.g., {BLOCK}_) for all global scope identifiers to prevent conflicts when integrating multiple IP blocks in the same design",
        "intelligent_suggestions": {
          "description": "AI-powered naming suggestions for common IP types to guide developers in choosing appropriate block and module names",
          "workflow_trigger": "When user requests 'Develop a design and architecture specification for ____ IP using Vyges Conventions', provide intelligent naming suggestions",
          "common_ip_patterns": {
            "communication_protocols": {
              "pattern": "{protocol}_controller or {protocol}_interface",
              "examples": [
                "uart_controller",
                "spi_interface",
                "i2c_protocol",
                "pcie_phy"
              ]
            },
            "memory_interfaces": {
              "pattern": "{memory_type}_controller or {memory_type}_interface",
              "examples": [
                "ddr_controller",
                "sram_interface",
                "flash_protocol"
              ]
            },
            "processing_units": {
              "pattern": "{unit_type}_core or {unit_type}_processor",
              "examples": [
                "cpu_core",
                "dsp_processor",
                "gpu_unit"
              ]
            },
            "analog_circuits": {
              "pattern": "{circuit_type}_converter or {circuit_type}_system",
              "examples": [
                "adc_converter",
                "dac_interface",
                "pll_generator"
              ]
            }
          },
          "naming_workflow": [
            "1. Capture current date: $(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "2. Analyze IP type and functionality from user request",
            "3. Suggest appropriate block name following Vyges conventions",
            "4. Create document structure with block name prefix",
            "5. Store original user requirements in raw format",
            "6. Prepare for specification and architecture development"
          ]
        }
      },
      "naming_convention_benefits": {
        "namespace_safety": "Prevents naming collisions when integrating IP blocks from multiple vendors",
        "file_organization": "Clear identification of IP block ownership and module functionality",
        "automation_friendly": "Enables automated tooling and CI/CD pipelines to identify and process files correctly",
        "integration_support": "Facilitates safe integration of third-party IP without namespace conflicts",
        "catalog_management": "Supports Vyges IP Catalog organization and discovery",
        "parameter_namespace_isolation": "Example: FFT_DATA_WIDTH vs UART_DATA_WIDTH prevents conflicts when both IP blocks are used in the same design"
      },
      "organization": {
        "rtl_files": "Place all RTL modules in rtl/ directory with {block}_{module}.sv naming",
        "header_files": "Place common headers in rtl/ directory with {block}_{type}.vh naming",
        "testbench_files": "Place all testbenches in tb/ directory",
        "test_files": "Place test vectors and coverage in test/ directory",
        "documentation": "Place all docs in docs/ directory",
        "flow_configs": "Place tool configurations in flow/ directory",
        "simulation_files": "Place simulation scripts and Makefiles under sim/",
        "constraints": "Place synthesis/implementation constraints (e.g., SDC, XDC) in constraints/"
      },
      "advanced_patterns": {
        "multi_platform": "For projects targeting both ASIC and FPGA, or including analog/mixed-signal, create subdirectories under rtl/, flow/, and constraints/ for asic/, fpga/, digital/, analog/, etc. The CLI should offer to expand the structure as needed.",
        "directory_expansion": {
          "rtl": {
            "asic": "ASIC-specific RTL (digital and analog)",
            "fpga": "FPGA-specific RTL (digital only)",
            "digital": "Digital RTL (platform-agnostic)",
            "analog": "Analog/mixed-signal RTL (ASIC only)",
            "behavioral": "Behavioral models (Verilog-A, SystemVerilog-AMS)",
            "verilog_a": "Verilog-A behavioral models"
          },
          "schematic": {
            "schematic": "Cadence Virtuoso schematic files",
            "symbol": "Cadence Virtuoso symbol files",
            "netlist": "Simulation netlists (SPICE, Spectre)"
          },
          "simulation": {
            "spectre": "Spectre simulation files and results",
            "configs": "Simulation configuration files",
            "results": "Simulation results and reports",
            "waveforms": "Simulation waveform files"
          },
          "layout": {
            "layout": "Cadence Virtuoso layout files",
            "constraints": "Layout constraints and rules",
            "lvs": "Layout vs. schematic verification",
            "drc": "Design rule checking"
          },
          "pdks": {
            "cadence": "Cadence PDK files and models",
            "models": "Device models and libraries",
            "techfiles": "Technology files and rules"
          },
          "constraints": {
            "asic": "ASIC synthesis and timing constraints",
            "fpga": "FPGA implementation constraints"
          },
          "flow": {
            "asic": "ASIC tool flows (OpenLane, Synopsys, etc.)",
            "fpga": "FPGA tool flows (Vivado, Quartus, etc.)",
            "analog": "Analog design flows (Virtuoso, Spectre, etc.)"
          },
          "packaging": {
            "interposer": "Interposer design and routing constraints",
            "bump_map": "Bump map definitions for die-to-die connections",
            "thermal": "Thermal analysis and constraints for multi-die systems"
          }
        }
      }
    },
    "required_patterns": {
      "include_guards": {
        "description": "Every RTL file must have include guards to prevent multiple inclusion",
        "pattern": "`ifndef {BLOCK}_{MODULE}_SV` and `define {BLOCK}_{MODULE}_SV",
        "example": "`ifndef FFT_MEMORY_INTERFACE_SV` ... `endif // FFT_MEMORY_INTERFACE_SV",
        "naming": "Use UPPER_SNAKE_CASE with BLOCK_MODULE_SV format"
      },
      "common_headers": {
        "description": "Include common header files for consistency",
        "required": [
          "{block}_timescale.vh",
          "{block}_defines.vh"
        ],
        "purpose": "Centralized parameter management and consistency across modules",
        "timescale_header": {
          "filename": "{block}_timescale.vh",
          "content": "Common timescale definition (e.g., `timescale 1ns/1ps)",
          "include_guard": "`ifndef {BLOCK}_TIMESCALE_VH` ... `endif // {BLOCK}_TIMESCALE_VH"
        },
        "defines_header": {
          "filename": "{block}_defines.vh",
          "content": "Shared parameters, types, and constants",
          "include_guard": "`ifndef {BLOCK}_DEFINES_VH` ... `endif // {BLOCK}_DEFINES_VH"
        }
      },
      "required_patterns": {
        "include_guards": {
          "description": "Every RTL file must have include guards to prevent multiple inclusion",
          "pattern": "`ifndef {BLOCK}_{MODULE}_SV` and `define {BLOCK}_{MODULE}_SV",
          "example": "`ifndef FFT_MEMORY_INTERFACE_SV` ... `endif // FFT_MEMORY_INTERFACE_SV",
          "naming": "Use UPPER_SNAKE_CASE with BLOCK_MODULE_SV format"
        },
        "module_header": {
          "description": "Every RTL module must have a standardized header with include guards",
          "template": [
            "`ifndef {BLOCK}_{MODULE}_SV",
            "`define {BLOCK}_{MODULE}_SV",
            "",
            "`include \"{block}_timescale.vh\"",
            "`include \"{block}_defines.vh\"",
            "",
            "//=============================================================================",
            "// Module Name: {module_name}",
            "//============================================================================="
          ]
        }
      }
    }
  },
  "validation_rules": {
    "structure": {
      "required_files": {
        "vyges-metadata.json": "Required metadata file with v1.0.0 schema compliance",
        "rtl/": "Required directory for RTL sources",
        "tb/": "Required directory for testbenches",
        "flow/": "Required directory for tool configurations",
        "test/": "Required directory for test files",
        "docs/": "Required directory for documentation"
      },
      "optional_files": {
        "constraints/": "Optional directory for physical/synthesis constraints",
        "sim/": "Optional directory for simulation scripts and Makefiles"
      },
      "metadata_validation": "vyges-metadata.json must contain all required fields from v1.0.0 schema",
      "ip_name_validation": "IP name must follow GitHub repository naming conventions and Vyges format rules"
    },
    "code_quality": {
      "linting": "All RTL must pass basic linting checks",
      "synthesis": "RTL must be synthesizable",
      "simulation": "Testbenches must run without errors",
      "coverage": "Basic functional coverage must be implemented",
      "cocotb_compatibility": "If cocotb is used, test must run with ghdl/iverilog/verilator",
      "include_guard_validation": {
        "description": "Validate that all RTL files have proper include guards",
        "check": "Every .sv file must start with `ifndef and end with `endif",
        "naming": "Include guard names must match filename pattern: {BLOCK}_{MODULE}_SV"
      },
      "common_header_inclusion": {
        "description": "Validate that all RTL files include common headers",
        "required": [
          "`include \"{block}_timescale.vh\"",
          "`include \"{block}_defines.vh\""
        ]
      },
      "namespace_safety": {
        "description": "Ensure namespace safety through proper file naming",
        "principle": "Use {block}_{module}.sv to prevent collisions between IP blocks",
        "benefit": "Enables safe integration of multiple IP blocks without naming conflicts"
      }
    },
    "design_document_quality": {
      "completeness": {
        "required_sections": "All template sections must be present and populated",
        "interface_coverage": "All interfaces must be documented with signal descriptions",
        "timing_specifications": "Critical timing requirements must be specified",
        "validation_criteria": "Clear validation and test criteria must be defined"
      },
      "consistency": {
        "metadata_alignment": "Design document must align with vyges-metadata.json",
        "interface_definitions": "Interface signals must match across all documentation",
        "naming_conventions": "All names must follow Vyges naming conventions"
      },
      "traceability": {
        "requirements_tracking": "Functional requirements must be traceable to implementation",
        "test_coverage": "Test cases must cover all specified requirements",
        "validation_evidence": "Validation results must demonstrate requirement satisfaction"
      },
      "visual_documentation": {
        "block_diagrams": "ASCII block diagrams must be included for IP representation",
        "connection_diagrams": "Connection diagrams must show interface compatibility",
        "timing_diagrams": "Critical timing relationships must be visually represented"
      },
      "documentation_style": {
        "language": "Use clear English text instead of JSON code blocks for better readability"
      }
    }
  },
  "catalog_objectives": {
    "description": "Ensure generated IP meets requirements for inclusion in the Vyges IP Catalog",
    "requirements": [
      "vyges-metadata.json is complete and conforms to schema",
      "Includes license, maturity, and interface metadata",
      "Includes testbench with pass/fail assertion",
      "Includes minimum documentation in docs/overview.md",
      "Must include basic functional verification (simulation or cocotb)",
      "Supports versioning and reproducibility via source tracking"
    ],
    "discoverability": {
      "description": "Make IP blocks easily discoverable by users",
      "metadata_completeness": "Ensure all metadata fields are properly filled",
      "categorization": "Use appropriate categories and tags for IP classification",
      "search_optimization": "Optimize metadata for search and filtering",
      "documentation_quality": "Provide comprehensive and clear documentation"
    },
    "quality_assurance": {
      "description": "Ensure high quality standards for all IP blocks",
      "verification_coverage": "Achieve high verification coverage",
      "documentation_standards": "Follow consistent documentation standards",
      "code_quality": "Maintain high code quality and readability",
      "testing_rigor": "Implement comprehensive testing strategies"
    },
    "interoperability": {
      "description": "Ensure IP blocks work together seamlessly",
      "interface_standards": "Follow standard interface protocols",
      "parameter_consistency": "Use consistent parameter naming and values",
      "clock_domain_handling": "Properly handle multiple clock domains",
      "reset_strategies": "Implement consistent reset strategies"
    },
    "maintainability": {
      "description": "Ensure IP blocks are easy to maintain and update",
      "code_organization": "Organize code in logical and maintainable structures",
      "documentation_maintenance": "Keep documentation up-to-date",
      "version_management": "Implement proper version control and release management",
      "dependency_management": "Manage dependencies and tool requirements"
    },
    "ai_assist_prompts": {
      "generate_catalog_ready_ip": "Create a SystemVerilog IP block that is ready for the Vyges Catalog. Include complete metadata, documentation, and testbench.",
      "check_catalog_readiness": "Validate the IP block for Vyges Catalog readiness: metadata coverage, testability, and discoverability."
    }
  },
  "usage_notes": {
    "description": "This AI workflow context provides AI integration, advanced verification, and workflow automation. Import this context when working on AI-assisted development, advanced verification, or workflow automation.",
    "import_guidance": "Start with this core context, then add specialized contexts based on your development needs (RTL, testbench, synthesis, etc.)",
    "backward_compatibility": "This modular approach maintains compatibility with the monolithic .vyges-ai-context.json while providing better organization and maintainability",
    "when_to_use": "Use when implementing AI-assisted workflows, advanced verification methodologies, or workflow automation",
    "dependencies": "Requires vyges-core-context.json for basic naming conventions and project structure",
    "compliance_focus": "This context emphasizes standards compliance first, with vendor extensions as optional enhancements"
  },
  "imports": [
    "vyges-core-context.json"
  ],
  "ascii_diagram_conventions": {
    "description": "Conventions for generating ASCII block diagrams of IP blocks and their connections",
    "block_representation": {
      "single_block": {
        "format": "Box with rounded corners using ASCII characters",
        "example": [
          "âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ",
          "â           IP_BLOCK_NAME                                â",
          "â                                                         â",
          "â  âââââââââââ    âââââââââââ                            â",
          "â  â Clock   â    â Reset   â                            â",
          "â  â clk_i   â    â rst_n_i â                            â",
          "â  âââââââââââ    âââââââââââ                            â",
          "â                                                         â",
          "â  ââââââââââââââââââââââââââââââââââââââââââââââââââââââââ",
          "â  â      Data Interface                                 ââ",
          "â  â data_i[7:0]                                        ââ",
          "â  â data_o[7:0]                                        ââ",
          "â  ââââââââââââââââââââââââââââââââââââââââââââââââââââââââ",
          "âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ"
        ]
      },
      "pin_grouping": {
        "clock_reset": "Group clock and reset signals together",
        "data_bus": "Group data bus signals (address, data, control)",
        "control": "Group control signals (enable, valid, ready)",
        "interrupts": "Group interrupt signals",
        "power": "Group power and ground signals",
        "debug": "Group debug and test signals"
      }
    },
    "connection_representations": {
      "signal_connections": {
        "single_signal": "Use -- for single signal connections",
        "bus_connection": "Use === for bus connections",
        "bidirectional": "Use <--> for bidirectional signals",
        "clock_connection": "Use -[CLK]- for clock signals",
        "reset_connection": "Use -[RST]- for reset signals",
        "interrupt_connection": "Use -[IRQ]- for interrupt signals"
      },
      "interface_connections": {
        "master_slave": "Show master driving slave with arrow direction",
        "peer_to_peer": "Show bidirectional communication between peers",
        "hierarchical": "Show clear hierarchy with indentation",
        "cross_domain": "Use special markers for clock domain crossings"
      }
    },
    "layout_conventions": {
      "orientation": {
        "top_to_bottom": "Primary flow from top to bottom",
        "left_to_right": "Secondary flow from left to right",
        "hierarchical": "Use indentation to show hierarchy levels",
        "grouped": "Group related blocks with visual boundaries"
      },
      "spacing": {
        "consistent": "Use consistent spacing between elements",
        "readable": "Ensure sufficient spacing for readability",
        "aligned": "Align related elements for clarity",
        "balanced": "Balance diagram elements for visual appeal"
      }
    },
    "ai_prompts": {
      "generate_block_diagram": "Generate ASCII block diagram for {module_name} showing {interfaces} and {connections}",
      "create_interface_diagram": "Create ASCII interface diagram showing {interface_type} connections between {modules}",
      "generate_system_diagram": "Generate ASCII system diagram showing {system_components} and their interconnections",
      "create_hierarchy_diagram": "Create ASCII hierarchy diagram showing {hierarchy_levels} for {ip_block}"
    }
  },
  "reference_projects": {
    "description": "Reference projects and examples for different IP types. For the latest examples and implementations, check the Vyges IP Catalog at https://vyges.com",
    "project_categories": {
      "simple_digital_ip": {
        "description": "Basic digital IP with APB interface",
        "key_characteristics": [
          "Single interface (APB)",
          "Basic functionality",
          "Standard verification",
          "Open-source toolchain support"
        ]
      },
      "complex_digital_ip": {
        "description": "Complex digital IP with multiple interfaces",
        "key_characteristics": [
          "Multiple interfaces (APB, UART, etc.)",
          "Modular design",
          "Comprehensive verification",
          "Multiple toolchain support"
        ]
      },
      "fpga_optimized_ip": {
        "description": "IP block optimized for FPGA implementation",
        "key_characteristics": [
          "Vendor-specific optimizations",
          "FPGA resource optimization",
          "Timing closure support",
          "IP core integration"
        ]
      },
      "hybrid_ip": {
        "description": "IP block with analog and digital domains",
        "key_characteristics": [
          "Mixed-signal design",
          "Behavioral modeling",
          "Analog interface support",
          "Cross-domain verification"
        ]
      },
      "chiplet_ready_ip": {
        "description": "IP block designed for chiplet integration",
        "key_characteristics": [
          "Die-to-die interfaces",
          "Packaging considerations",
          "Thermal analysis",
          "Multi-die testing"
        ]
      },
      "analog_ip": {
        "description": "Analog IP block with comprehensive design flow",
        "key_characteristics": [
          "Behavioral modeling",
          "Transistor-level design",
          "PDK integration",
          "Layout verification"
        ]
      }
    },
    "catalog_reference": {
      "url": "https://vyges.com",
      "description": "Live Vyges IP Catalog with current examples and implementations",
      "benefits": [
        "Always up-to-date examples",
        "Current file structures and naming",
        "Latest toolchain configurations",
        "Active community contributions"
      ]
    }
  },
  "internationalization": {
    "description": "Internationalization, localization, and regional compliance features",
    "multi_language_support": {
      "description": "Multi-language support for documentation and interfaces",
      "documentation": "Support for multi-language documentation",
      "ui": "Multi-language user interface support",
      "english": "Primary language for technical documentation",
      "localization": "Support for local language documentation",
      "translation": "Translation guidelines and standards",
      "cultural_adaptation": "Cultural adaptation for different regions"
    },
    "regional_compliance": {
      "description": "Regional compliance and certification standards",
      "standards": [
        "CE",
        "FCC",
        "RoHS",
        "REACH",
        "CCC"
      ],
      "compliance_guidance": "Guidance for regional standards and compliance"
    },
    "localization": {
      "description": "Localization tools and workflows",
      "translation": "Translation workflows for documentation and UI",
      "localization_tools": [
        "poedit",
        "crowdin",
        "lokalise"
      ]
    },
    "documentation_standards": {
      "description": "International documentation standards",
      "iso_standards": "Follow ISO documentation standards",
      "ieee_standards": "Follow IEEE documentation standards",
      "accessibility": "Ensure documentation accessibility",
      "format_consistency": "Maintain consistent formatting across languages"
    },
    "naming_conventions": {
      "description": "International naming conventions",
      "character_sets": "Use UTF-8 encoding for international characters",
      "naming_rules": "Follow international naming conventions",
      "abbreviations": "Use standard international abbreviations",
      "symbols": "Use internationally recognized symbols"
    }
  },
  "template_integration": {
    "mode": "hybrid",
    "description": "Use codegen + AI to scaffold IP repos: template + AI phase optimize for maximum developer productivity",
    "ai_prompts": {
      "bootstrap_project": "Generate directory structure and basic RTL/test files based on metadata using the vyges-ip-template as base.",
      "customize_template": "Customize the vyges-ip-template structure for specific IP requirements and target platforms.",
      "expand_template": "Expand the minimal template structure with additional directories and files based on IP complexity.",
      "optimize_structure": "Optimize project structure for the specific IP type, interfaces, and target platforms."
    },
    "workflow": {
      "start_with_template": "Begin with vyges-ip-template as the foundation",
      "ai_customization": "Use AI to customize structure and generate initial files",
      "progressive_expansion": "Expand complexity using vyges expand commands",
      "metadata_driven": "Use vyges-metadata.json to guide all customizations"
    },
    "benefits": [
      "Reduces cognitive load and setup time",
      "Ensures consistency with Vyges conventions",
      "Enables rapid prototyping and iteration",
      "Supports both simple and complex IP development"
    ]
  },
  "metadata_driven_generation": {
    "description": "Use vyges-metadata.json as canonical source of truth for generating specifications and code",
    "capabilities": {
      "specification_generation": {
        "input": "vyges-metadata.json fields (name, description, parameters, interfaces, target, design_type, toolRequirements, flows, test, performance)",
        "output": "docs/specification.md - Human-readable requirements document",
        "template_sections": [
          "Overview",
          "Target (ASIC/FPGA)",
          "Interfaces",
          "Parameters",
          "Tool Requirements",
          "Flows",
          "Test Strategy",
          "Performance Requirements"
        ]
      }
    }
  },
  "standardized_interfaces": {
    "description": "Use Vyges Standardized Interface Catalog for consistent IP integration",
    "canonical_bus_types": [
      "AXI4",
      "AXI4-Lite",
      "APB",
      "Wishbone",
      "SPI",
      "I2C"
    ],
    "interface_categories": [
      "bus",
      "clock",
      "reset",
      "mailbox",
      "interrupt",
      "debug",
      "power",
      "security",
      "memory",
      "misc"
    ],
    "signal_naming_conventions": {
      "clock": "clk, clk_en",
      "reset": "rst_n, init_done",
      "power": "power_on, power_good, pwr_gate_en, pwr_retention",
      "interrupts": "irq, error_irq, timer_irq",
      "debug": "jtag_tck, jtag_tdi, jtag_tdo, jtag_tms, trace_data",
      "security": "fuse_data, fuse_addr, fuse_prog, fuse_done, trng_valid, trng_data"
    },
    "ai_assist_prompts": {
      "use_standard_interfaces": "Use Vyges Standardized Interface Catalog signals and naming conventions for IP integration",
      "validate_interface_compliance": "Validate that interface signals follow Vyges Standardized Interface Catalog conventions",
      "generate_interface_wrapper": "Generate interface wrapper using standardized signal names from Vyges catalog"
    }
  },
  "ipxact_conversion": {
    "description": "IP-XACT to Vyges metadata conversion functionality for AI-assisted migration. This section contains IPXACT-specific conversion logic while following the main Vyges conventions defined in project_structure.",
    "conversion_mapping": {
      "component_info": {
        "vendor": "Extract vendor name for IP identification",
        "library": "Extract library name for organization",
        "name": "Extract component name for IP naming",
        "version": "Extract version information",
        "description": "Extract component description"
      },
      "ports_to_pins": {
        "port_name": "Map IP-XACT port names to Vyges pin names",
        "direction": "Convert IP-XACT direction (in/out/inout) to Vyges direction (input/output/inout)",
        "width": "Extract bus width from vectors or arrays",
        "signal_type": "Infer signal type from port name and context",
        "description": "Generate pin description from port information"
      },
      "parameters": {
        "parameter_name": "Map IP-XACT parameter names to Vyges parameter names",
        "parameter_type": "Convert IP-XACT parameter types to Vyges types",
        "default_value": "Extract default values and ranges",
        "description": "Preserve parameter descriptions and documentation"
      },
      "bus_interfaces": {
        "interface_name": "Map IP-XACT bus interface names to Vyges interface names",
        "protocol": "Extract bus protocol information (APB, AXI, etc.)",
        "port_maps": "Convert port maps to Vyges signal mappings",
        "abstraction": "Handle abstraction type information"
      },
      "file_sets": {
        "file_set_name": "Map IP-XACT file set names to Vyges file categories",
        "file_paths": "Extract file paths and types",
        "file_types": "Map IP-XACT file types to Vyges file types"
      }
    },
    "conversion_rules": {
      "naming_conventions": {
        "ip_name": "Convert to lowercase with hyphens: {vendor}/{name}",
        "pin_names": "Preserve original names or convert to snake_case",
        "parameter_names": "Convert to UPPER_SNAKE_CASE",
        "interface_names": "Preserve protocol names (APB, AXI, etc.)"
      },
      "type_mapping": {
        "ipxact_types": {
          "bit": "int",
          "string": "string",
          "float": "float",
          "long": "int"
        }
      }
    }
  },
  "industry_standards": {
    "description": "Industry standards and specifications relevant to Vyges IP development",
    "chiplet_standards": {
      "cdxml": {
        "description": "OCP CDXML (Chiplet Design Exchange Format) for die-to-die interfaces",
        "version": "cdxml-v0.2",
        "purpose": "Standardize chiplet interface definitions for cross-vendor interoperability",
        "scope": "Die-to-die interfaces, electrical characteristics, mechanical constraints",
        "compliance_areas": [
          "Interface protocol definitions",
          "Electrical specifications",
          "Mechanical constraints",
          "Power domain definitions",
          "Thermal requirements"
        ],
        "validation_requirements": [
          "Protocol compliance checking",
          "Electrical validation",
          "Mechanical validation",
          "Power domain validation",
          "Thermal analysis validation"
        ]
      },
      "bow": {
        "description": "BoW (Bunch of Wires) protocol for cost-effective die-to-die communication",
        "version": "2.0d.1",
        "purpose": "Provide simple, low-overhead protocol for consumer and IoT applications",
        "scope": "Signaling, timing, bump configuration, compliance features",
        "signaling_classes": {
          "class_a": "Lowest power, basic functionality",
          "class_b": "Balanced power and performance",
          "class_c": "Highest performance, advanced features"
        },
        "compliance_features": [
          "Loopback testing",
          "PRBS pattern generation",
          "Error detection and reporting",
          "Clock training and synchronization",
          "Signal integrity validation"
        ],
        "validation_requirements": [
          "Signaling class compliance",
          "Timing constraint validation",
          "Bump configuration validation",
          "Compliance feature testing",
          "Protocol conformance validation"
        ]
      },
      "ucie": {
        "description": "Universal Chiplet Interconnect Express for high-performance applications",
        "purpose": "Provide high-bandwidth, low-latency die-to-die communication",
        "compliance": "CDXML v0.2 compliant",
        "key_features": [
          "High bandwidth",
          "Low latency",
          "Advanced error handling",
          "PCIe compatibility"
        ]
      },
      "aib": {
        "description": "Advanced Interface Bus for Intel-based systems",
        "purpose": "Provide Intel-proprietary high-performance die-to-die interface",
        "compliance": "CDXML v0.2 compliant",
        "key_features": [
          "High bandwidth",
          "Low power",
          "Advanced features",
          "Intel ecosystem integration"
        ]
      },
      "emib": {
        "description": "Embedded Multi-die Interconnect Bridge for Intel advanced packaging",
        "purpose": "Provide high-density, low-latency interconnect for Intel packaging",
        "compliance": "CDXML v0.2 compliant",
        "key_features": [
          "High density",
          "Low latency",
          "Advanced packaging",
          "Intel technology integration"
        ]
      }
    },
    "interface_standards": {
      "axi": {
        "description": "AMBA AXI (Advanced eXtensible Interface) protocol family",
        "versions": [
          "AXI4",
          "AXI4-Lite",
          "AXI4-Stream"
        ],
        "purpose": "Standardize high-performance on-chip communication",
        "compliance_areas": [
          "Protocol compliance",
          "Signal timing",
          "Handshake protocols",
          "Burst transfer support"
        ]
      },
      "apb": {
        "description": "AMBA APB (Advanced Peripheral Bus) protocol",
        "purpose": "Standardize low-power peripheral communication",
        "compliance_areas": [
          "Protocol compliance",
          "Signal timing",
          "Transfer protocols",
          "Power management"
        ]
      },
      "wishbone": {
        "description": "Open-source Wishbone bus protocol",
        "purpose": "Provide open, flexible on-chip communication",
        "compliance_areas": [
          "Protocol compliance",
          "Signal timing",
          "Transfer protocols",
          "Interface compatibility"
        ]
      }
    },
    "verification_standards": {
      "uvm": {
        "description": "Universal Verification Methodology for SystemVerilog",
        "purpose": "Standardize verification methodology and practices",
        "compliance_areas": [
          "Methodology compliance",
          "Coverage standards",
          "Assertion practices",
          "Testbench architecture"
        ]
      },
      "pss": {
        "description": "Portable Stimulus Standard for verification",
        "purpose": "Standardize verification stimulus generation",
        "compliance_areas": [
          "Language compliance",
          "Modeling practices",
          "Stimulus generation",
          "Coverage mapping"
        ]
      }
    }
  },
  "rtl_patterns": {
    "module_header": {
      "description": "Every RTL module must have a standardized header with include guards",
      "template": [
        "`ifndef {BLOCK}_{MODULE}_SV",
        "`define {BLOCK}_{MODULE}_SV",
        "",
        "`include \"{block}_timescale.vh\"",
        "`include \"{block}_defines.vh\"",
        "",
        "//=============================================================================",
        "// Module Name: {module_name}",
        "//=============================================================================",
        "// Description: {description}",
        "// Author: {author}",
        "// License: {license}",
        "//=============================================================================",
        "",
        "module {module_name} #(",
        "    // ... parameters ...",
        ") (",
        "    // ... ports ...",
        ");",
        "",
        "    // ... implementation ...",
        "",
        "endmodule",
        "",
        "`endif // {BLOCK}_{MODULE}_SV"
      ]
    },
    "interface_patterns": {
      "clock_reset": "All modules must have clock_i and reset_n_i signals",
      "apb_slave": "APB slave interface must follow standard APB protocol signals: pclk, presetn, psel, penable, pwrite, paddr, pwdata, prdata, pready, pslverr",
      "axi_master": "AXI master interface must follow standard AXI protocol signals",
      "axi_lite_slave": "AXI-Lite slave interface must include: aclk, aresetn, awaddr, awvalid, awready, wdata, wstrb, wvalid, wready, bresp, bvalid, bready, araddr, arvalid, arready, rdata, rresp, rvalid, rready",
      "wishbone": "Wishbone interface must include: wb_clk_i, wb_rst_i, wb_cyc_i, wb_stb_i, wb_ack_o, wb_adr_i, wb_dat_i, wb_dat_o, wb_we_i",
      "spi_master": "SPI master interface must include: sclk_o, mosi_o, miso_i, ss_n_o[N-1:0], busy_o, done_o, data_valid_o, data_ready_i",
      "spi_slave": "SPI slave interface must include: sclk_i, mosi_i, miso_o, ss_n_i, busy_o, done_o, data_valid_o, data_ready_i",
      "interrupts": "Interrupt signals should be named irq_<description>_o",
      "power_management": "Power signals: power_on, power_good, pwr_gate_en, pwr_retention",
      "mailbox": "Mailbox interface: mbx_req, mbx_ack, mbx_addr, mbx_data, mbx_we, mbx_valid, mbx_ready",
      "debug": "Debug interface: jtag_tck, jtag_tdi, jtag_tdo, jtag_tms, trace_data",
      "security": "Security interface: fuse_data, fuse_addr, fuse_prog, fuse_done, trng_valid, trng_data",
      "chiplet_interfaces": {
        "ucie": "UCIe interface signals: ucie_clk, ucie_rst_n, ucie_tx_data, ucie_rx_data, ucie_tx_valid, ucie_rx_valid, ucie_tx_ready, ucie_rx_ready",
        "bow": "Bunch of Wires (BoW) interface: bow_clk, bow_rst_n, bow_tx_data, bow_rx_data, bow_tx_valid, bow_rx_valid",
        "aib": "Advanced Interface Bus (AIB): aib_clk, aib_rst_n, aib_tx_data, aib_rx_data, aib_tx_valid, aib_rx_valid",
        "emib": "Intel EMIB interface: emib_clk, emib_rst_n, emib_tx_data, emib_rx_data, emib_tx_valid, emib_rx_valid"
      },
      "standards_compliance": {
        "cdxml_compliance": "CDXML-compliant interface signals following OCP specification",
        "bow_compliance": "BoW-compliant interface signals following BoW specification",
        "protocol_validation": "Protocol compliance validation signals and interfaces",
        "standards_testing": "Standards compliance testing interfaces and signals"
      }
    },
    "coding_standards": {
      "language": "SystemVerilog",
      "style": "Use always_ff for sequential logic, always_comb for combinational logic",
      "assertions": "Include basic assertions for critical functionality",
      "parameters": "Use parameters for configurable features",
      "comments": "Include detailed comments for complex logic",
      "naming_comment_convention": "Use // <type>: <description> for inline comments (e.g., // signal: rising edge detector)",
      "port_direction_comment": "Use comments above ports for direction and purpose",
      "forbidden_constructs": [
        "casex",
        "inout without direction",
        "unused signals",
        "implicit wire declarations"
      ],
      "required_constructs": [
        "always_ff for sequential logic",
        "always_comb for combinational logic",
        "explicit signal declarations"
      ]
    },
    "semantic_fixes": {
      "casex_replacement": "Replace casex with casez for better synthesis and simulation consistency",
      "width_mismatch": "Ensure all signal assignments have matching widths, use explicit width casting when needed",
      "unused_signal_handling": "Mark unused signals with _unused suffix or add // unused comment",
      "implicit_declaration_fix": "Always declare signals explicitly with proper types and widths",
      "port_direction_clarity": "Ensure all ports have clear direction and type specifications"
    }
  },
  "advanced_patterns": {
    "multi_platform": "For projects targeting both ASIC and FPGA, or including analog/mixed-signal, create subdirectories under rtl/, flow/, and constraints/ for asic/, fpga/, digital/, analog/, etc. The CLI should offer to expand the structure as needed.",
    "directory_expansion": {
      "rtl": {
        "asic": "ASIC-specific RTL (digital and analog)",
        "fpga": "FPGA-specific RTL (digital only)",
        "digital": "Digital RTL (platform-agnostic)",
        "analog": "Analog/mixed-signal RTL (ASIC only)",
        "behavioral": "Behavioral models (Verilog-A, SystemVerilog-AMS)",
        "verilog_a": "Verilog-A behavioral models"
      }
    }
  },
  "code_generation_rules": {
    "rtl": {
      "language": "SystemVerilog",
      "style": "Use always_ff for sequential logic, always_comb for combinational logic",
      "assertions": "Include basic assertions for critical functionality",
      "parameters": "Use parameters for configurable features",
      "comments": "Include detailed comments for complex logic",
      "naming_comment_convention": "Use // <type>: <description> for inline comments (e.g., // signal: rising edge detector)",
      "port_direction_comment": "Use comments above ports for direction and purpose"
    },
    "testbench": {
      "language": "SystemVerilog",
      "structure": [
        "Clock and reset generation",
        "DUT instantiation",
        "Test stimulus generation",
        "Response checking",
        "Coverage collection"
      ],
      "verification": "Include basic functional verification and coverage",
      "test_categories": {
        "functional_tests": "Basic functionality, protocol compliance, interface verification",
        "performance_tests": "Maximum frequency, throughput measurement, latency analysis",
        "corner_case_tests": "FIFO overflow/underflow, timeout conditions, reset behavior",
        "error_tests": "Protocol violations, error injection, fault tolerance",
        "coverage_tests": "Functional coverage, code coverage, toggle coverage, FSM coverage"
      },
      "verification_requirements": {
        "coverage_goals": "95% functional coverage, 90% code coverage, 100% toggle coverage",
        "assertion_requirements": "Protocol compliance assertions, safety assertions, performance assertions",
        "waveform_requirements": "Comprehensive waveform generation for debugging and analysis",
        "regression_requirements": "Automated regression testing with CI/CD integration"
      }
    },
    "cocotb": {
      "language": "Python",
      "framework": "cocotb",
      "structure": [
        "Import cocotb and required triggers",
        "Create coroutine with `@cocotb.test()`",
        "Drive inputs and check outputs",
        "Include test cases for edge conditions",
        "Add coverage collection and assertions",
        "Include waveform generation and analysis"
      ],
      "file_structure": {
        "location": "tb/cocotb/",
        "file_naming": "test_<module_name>.py"
      },
      "integration_notes": "Ensure Makefile or sim/ run script supports cocotb test execution",
      "makefile_patterns": {
        "description": "Standard cocotb Makefile patterns for proper simulator integration",
        "location": "tb/cocotb/Makefile",
        "standard_approach": "Follow cocotb documentation: https://docs.cocotb.org/en/stable/quickstart.html#creating-a-makefile",
        "required_variables": {
          "SIM": "Simulator to use (icarus, verilator, vcs, modelsim)",
          "TOPLEVEL_LANG": "Language of top-level module (verilog, vhdl)",
          "VERILOG_SOURCES": "List of RTL source files with full paths",
          "TOPLEVEL": "Name of the top-level module in RTL",
          "MODULE": "Basename of the Python test file (without .py)"
        },
        "cocotb_config_detection": {
          "pattern": "COCOTB_CONFIG := $(shell which cocotb-config 2>/dev/null || echo $(HOME)/.local/bin/cocotb-config)",
          "purpose": "Detect cocotb-config in PATH or common installation locations",
          "fallback_locations": [
            "$(HOME)/.local/bin/cocotb-config",
            "/usr/local/bin/cocotb-config",
            "/usr/bin/cocotb-config"
          ]
        },
        "makefile_inclusion": {
          "standard": "include $(shell cocotb-config --makefiles)/Makefile.sim",
          "fallback": "Provide fallback targets when cocotb-config is not available"
        }
      }
    }
  },
  "ai_assistance": {
    "description": "AI assistance capabilities for synthesis and implementation flows",
    "flow_specific_guidance": {
      "asic_flow": "Provide ASIC-specific synthesis guidance including timing optimization, area optimization, and power analysis",
      "fpga_flow": "Provide FPGA-specific synthesis guidance including pin constraints, resource optimization, and bitstream generation",
      "analog_flow": "Provide analog-specific synthesis guidance including behavioral modeling, circuit design, and layout optimization",
      "digital_flow": "Provide digital verification guidance including functional verification, coverage analysis, and platform-agnostic testing",
      "mixed_signal_flow": "Provide mixed-signal synthesis guidance including digital/analog partitioning and co-simulation setup"
    },
    "standards_compliance": {
      "cdxml_guidance": "Guide CDXML compliance for chiplet interfaces with {protocol} and {requirements}",
      "bow_guidance": "Guide BoW compliance for chiplet interfaces with {signaling_class} and {timing_requirements}",
      "interface_validation": "Guide interface validation for {protocol} compliance with {test_requirements}",
      "standards_testing": "Guide standards compliance testing for {standard} with {validation_requirements}",
      "protocol_validation": "Guide protocol compliance validation for {protocol} with {compliance_requirements}",
      "cdxml_validation": "Guide CDXML compliance validation for chiplet interfaces",
      "bow_validation": "Guide BoW compliance validation for chiplet interfaces"
    },
    "code_generation": {
      "module_generation": "Generate SystemVerilog module for {functionality} with {interfaces} following Vyges conventions",
      "interface_generation": "Generate interface wrapper for {protocol} with {requirements}",
      "testbench_generation": "Generate testbench for {module} with {verification_requirements}",
      "constraint_generation": "Generate constraints for {target_flow} with {requirements}"
    },
    "verification_methodologies": {
      "uvm_guidance": "Guide UVM methodology implementation for {module} with {verification_requirements}",
      "cocotb_guidance": "Guide cocotb implementation for {module} with {verification_requirements}",
      "formal_verification": "Guide formal verification for {module} with {property_requirements}",
      "coverage_analysis": "Guide coverage analysis for {module} with {coverage_goals}"
    },
    "synthesis_optimization": {
      "timing_optimization": "Guide timing optimization strategies for {target_frequency} with {constraints}",
      "area_optimization": "Guide area optimization strategies for {target_area} with {performance_requirements}",
      "power_optimization": "Guide power optimization strategies for {target_power} with {performance_requirements}",
      "constraint_generation": "Generate synthesis constraints for {target_flow} with {requirements}"
    },
    "tool_integration": {
      "vivado_integration": "Provide Vivado-specific guidance for {device_family} with {requirements}",
      "quartus_integration": "Provide Quartus-specific guidance for {device_family} with {requirements}",
      "open_source_integration": "Provide open-source tool guidance for {toolchain} with {requirements}",
      "proprietary_integration": "Provide proprietary tool guidance for {tool} with {requirements}"
    }
  },
  "testbench_patterns": {
    "structure": "Testbenches must include clock generation, reset sequence, and test stimulus",
    "naming": "Testbench files must be named tb_<module_name>.sv",
    "coverage": "Include basic functional coverage for critical paths",
    "test_categories": "Must include functional, performance, corner case, error, and coverage tests",
    "verification_goals": "Must achieve 95% functional coverage, 90% code coverage, 100% toggle coverage",
    "assertion_requirements": "Must include protocol compliance, safety, and performance assertions",
    "regression_testing": "Must support automated regression testing with CI/CD integration"
  },
  "testbench_standards": {
    "language": "SystemVerilog",
    "framework": "Use standard SystemVerilog testbench patterns or cocotb for Python-based testing",
    "structure": [
      "Clock and reset generation",
      "DUT instantiation",
      "Test stimulus generation",
      "Response checking",
      "Coverage collection"
    ],
    "verification": "Include basic functional verification and coverage",
    "test_categories": {
      "functional_tests": "Basic functionality, protocol compliance, interface verification",
      "performance_tests": "Maximum frequency, throughput measurement, latency analysis",
      "corner_case_tests": "FIFO overflow/underflow, timeout conditions, reset behavior",
      "error_tests": "Protocol violations, error injection, fault tolerance",
      "coverage_tests": "Functional coverage, code coverage, toggle coverage, FSM coverage"
    },
    "verification_requirements": {
      "coverage_goals": "95% functional coverage, 90% code coverage, 100% toggle coverage",
      "assertion_requirements": "Protocol compliance assertions, safety assertions, performance assertions",
      "waveform_requirements": "Comprehensive waveform generation for debugging and analysis",
      "regression_requirements": "Automated regression testing with CI/CD integration"
    }
  },
  "cocotb_integration": {
    "language": "Python",
    "framework": "cocotb",
    "structure": [
      "Import cocotb and required triggers",
      "Create coroutine with `@cocotb.test()`",
      "Drive inputs and check outputs",
      "Include test cases for edge conditions",
      "Add coverage collection and assertions",
      "Include waveform generation and analysis"
    ],
    "file_structure": {
      "location": "tb/cocotb/",
      "file_naming": "test_<module_name>.py"
    },
    "integration_notes": "Ensure Makefile or sim/ run script supports cocotb test execution",
    "makefile_patterns": {
      "description": "Standard cocotb Makefile patterns for proper simulator integration",
      "location": "tb/cocotb/Makefile",
      "standard_approach": "Follow cocotb documentation: https://docs.cocotb.org/en/stable/quickstart.html#creating-a-makefile",
      "required_variables": {
        "SIM": "Simulator to use (icarus, verilator, vcs, modelsim)",
        "TOPLEVEL_LANG": "Language of top-level module (verilog, vhdl)",
        "VERILOG_SOURCES": "List of RTL source files with full paths",
        "TOPLEVEL": "Name of the top-level module in RTL",
        "MODULE": "Basename of the Python test file (without .py)"
      },
      "cocotb_config_detection": {
        "pattern": "COCOTB_CONFIG := $(shell which cocotb-config 2>/dev/null || echo $(HOME)/.local/bin/cocotb-config)",
        "purpose": "Detect cocotb-config in PATH or common installation locations",
        "fallback_locations": [
          "$(HOME)/.local/bin/cocotb-config",
          "/usr/local/bin/cocotb-config",
          "/usr/bin/cocotb-config"
        ]
      },
      "makefile_inclusion": {
        "standard": "include $(shell cocotb-config --makefiles)/Makefile.sim",
        "fallback": "Provide fallback targets when cocotb-config is not available",
        "conditional": "Use ifneq ($(wildcard $(COCOTB_CONFIG)),) for conditional compilation"
      },
      "fallback_patterns": {
        "icarus_only": "When cocotb-config not found, provide basic Icarus Verilog compilation",
        "warning_messages": "Inform user about missing cocotb and installation instructions",
        "limited_functionality": "Only basic compilation and simulation, no advanced cocotb features"
      },
      "additional_targets": {
        "test_modules": "Create targets for different test modules (test_rescaling, test_edge_cases)",
        "test_all": "Target to run all test modules in sequence",
        "coverage": "Generate coverage reports and copy to public directory",
        "help": "Comprehensive help target with usage examples and status"
      },
      "verilator_integration": {
        "build_command": "verilator -cc --exe -Mdir sim_build -DCOCOTB_SIM=1 --top-module {module} --timescale 1ns/1ps --vpi --public-flat-rw --prefix Vtop -o Vtop -LDFLAGS \"-Wl,-rpath,{cocotb_lib_path} -L{cocotb_lib_path} -lcocotbvpi_verilator\" {rtl_files} {cocotb_verilator_cpp}",
        "linking": "Automatic linking with cocotb VPI library via -lcocotbvpi_verilator",
        "simulation": "Run with sim_build/Vtop executable"
      }
    }
  },
  "verification_methodologies": {
    "functional_verification": {
      "description": "Verify IP functionality meets specifications",
      "approaches": [
        "Directed testing",
        "Random testing",
        "Coverage-driven verification"
      ],
      "tools": [
        "SystemVerilog assertions",
        "Coverage collection",
        "Waveform analysis"
      ]
    },
    "performance_verification": {
      "description": "Verify IP meets performance requirements",
      "metrics": [
        "Maximum frequency",
        "Throughput",
        "Latency",
        "Power consumption"
      ],
      "tools": [
        "Timing analysis",
        "Power analysis",
        "Performance profiling"
      ]
    },
    "protocol_verification": {
      "description": "Verify IP follows bus protocol specifications",
      "protocols": [
        "APB",
        "AXI",
        "SPI",
        "UART",
        "I2C"
      ],
      "tools": [
        "Protocol checkers",
        "Bus functional models",
        "Assertion-based verification"
      ]
    }
  },
  "fpga_flow_configuration": {
    "description": "Comprehensive FPGA tool flow configuration and requirements",
    "constraints": "Place constraints in constraints/ directory",
    "supported_toolchains": {
      "vivado": {
        "description": "Xilinx Vivado FPGA flow for Xilinx devices",
        "tools": [
          "vivado",
          "vivado_hls",
          "vitis"
        ],
        "supported_families": [
          "artix7",
          "kintex7",
          "virtex7",
          "zynq",
          "ultrascale",
          "versal"
        ],
        "config_files": {
          "project": "vivado_project.tcl",
          "constraints": "constraints.xdc",
          "synthesis": "synthesis.tcl",
          "implementation": "implementation.tcl",
          "bitstream": "bitstream.tcl"
        },
        "outputs": [
          "bitstream.bit",
          "netlist.v",
          "timing_report.txt",
          "utilization_report.txt"
        ],
        "board_support": [
          "arty-a7",
          "nexys4",
          "zybo",
          "ultra96",
          "kcu105"
        ],
        "ip_catalog": "Xilinx IP Catalog integration",
        "simulation": "Vivado Simulator support",
        "version_requirements": "Vivado 2023.1+ recommended"
      },
      "quartus": {
        "description": "Intel Quartus FPGA flow for Intel/Altera devices",
        "tools": [
          "quartus",
          "modelsim",
          "nios_eds"
        ],
        "supported_families": [
          "cyclone",
          "arria",
          "stratix",
          "max",
          "agilex"
        ],
        "config_files": {
          "project": "quartus_project.qpf",
          "constraints": "constraints.sdc",
          "synthesis": "synthesis.qsf",
          "implementation": "implementation.qsf"
        },
        "outputs": [
          "output.sof",
          "netlist.v",
          "timing_report.txt",
          "power_report.txt"
        ],
        "board_support": [
          "de0-nano",
          "de1-soc",
          "de10-nano",
          "stratix10",
          "agilex7"
        ],
        "ip_catalog": "Intel IP Catalog integration",
        "simulation": "ModelSim support",
        "version_requirements": "Quartus 22.1+ recommended"
      },
      "openfpga": {
        "description": "Open-source FPGA implementation flow",
        "tools": [
          "yosys",
          "nextpnr",
          "openroad"
        ],
        "supported_families": [
          "ice40",
          "ecp5",
          "nexus"
        ],
        "config_files": {
          "synthesis": "synthesis.ys",
          "constraints": "constraints.pcf",
          "placement": "placement.json"
        },
        "outputs": [
          "output.bin",
          "netlist.v",
          "timing_report.txt"
        ],
        "board_support": [
          "icebreaker",
          "ecp5-evn",
          "nexus-a7"
        ],
        "open_source": "Fully open-source toolchain",
        "version_requirements": "Latest stable releases"
      }
    }
  },
  "asic_flow_configuration": {
    "description": "ASIC implementation flows and configurations",
    "openlane": {
      "description": "Open-source ASIC implementation flow",
      "configuration": "Use OpenLane configuration files",
      "constraints": "Place constraints in constraints/ directory with .sdc extension",
      "synthesis": "Use Yosys for synthesis",
      "placement": "Use OpenROAD for placement and routing",
      "timing_analysis": "Run timing analysis with OpenSTA"
    },
    "synopsys": {
      "description": "Synopsys Design Compiler and IC Compiler flow",
      "synthesis": "Use Design Compiler for synthesis",
      "placement": "Use IC Compiler for placement and routing",
      "timing_analysis": "Use PrimeTime for timing analysis",
      "constraints": "Use .sdc files for timing constraints"
    },
    "cadence": {
      "description": "Cadence Genus and Innovus flow",
      "synthesis": "Use Genus for synthesis",
      "placement": "Use Innovus for placement and routing",
      "timing_analysis": "Use Tempus for timing analysis",
      "constraints": "Use .sdc files for timing constraints"
    }
  },
  "proprietary_tools_guidance": {
    "description": "Guidance for handling proprietary EDA tools in build systems and workflows",
    "license_management": "Ensure proper license management for proprietary tools",
    "version_pinning": "Pin tool versions for reproducibility",
    "configuration_files": "Store tool configurations in flow/ directory",
    "documentation": "Document tool-specific requirements and procedures",
    "fallback_options": "Provide open-source alternatives when possible",
    "principle": "When providing support via Makefiles with proprietary tools such as Vivado, Quartus, Synopsys, Innovus/Cadence, we should always skip running those as part of the build system. The user may subsequently add that support.",
    "rationale": [
      "Proprietary tools require licensing and are not openly available",
      "Build systems should focus on open-source tools for accessibility",
      "Users can add proprietary tool support based on their specific needs",
      "Ensures build systems work out-of-the-box without licensing barriers"
    ],
    "proprietary_tools": {
      "vivado": {
        "vendor": "AMD/Xilinx",
        "availability": "Commercial license required",
        "build_system": "Skip in default builds",
        "user_addition": "User can add Vivado support to Makefiles as needed"
      },
      "quartus": {
        "vendor": "Intel/Altera",
        "availability": "Commercial license required",
        "build_system": "Skip in default builds",
        "user_addition": "User can add Quartus support to Makefiles as needed"
      },
      "synopsys": {
        "vendor": "Synopsys",
        "availability": "Commercial license required",
        "build_system": "Skip in default builds",
        "user_addition": "User can add Synopsys support to Makefiles as needed"
      },
      "innovus": {
        "vendor": "Cadence",
        "availability": "Commercial license required",
        "build_system": "Skip in default builds",
        "user_addition": "User can add Innovus support to Makefiles as needed"
      },
      "cadence": {
        "vendor": "Cadence",
        "availability": "Commercial license required",
        "build_system": "Skip in default builds",
        "user_addition": "User can add Cadence support to Makefiles as needed"
      }
    },
    "open_source_alternatives": {
      "synthesis": [
        "yosys",
        "berkeley-abc"
      ],
      "simulation": [
        "verilator",
        "icarus",
        "ghdl"
      ],
      "layout": [
        "magic",
        "klayout"
      ],
      "verification": [
        "netgen",
        "cocotb"
      ],
      "waveform": [
        "gtkwave"
      ]
    }
  },
  "synthesis_patterns": {
    "description": "Common synthesis patterns and best practices",
    "clock_constraints": "Define clock constraints for all clock domains",
    "false_paths": "Identify and specify false paths",
    "multicycle_paths": "Define multicycle paths for complex logic",
    "area_constraints": "Specify area constraints when needed",
    "power_constraints": "Define power constraints for low-power designs"
  },
  "implementation_patterns": {
    "description": "Implementation and optimization patterns",
    "floorplanning": "Define chip floorplan and power domains",
    "clock_tree_synthesis": "Optimize clock tree for skew and power",
    "routing": "Use appropriate routing strategies for different nets",
    "power_analysis": "Run power analysis and optimize power consumption",
    "timing_closure": "Iterate to achieve timing closure"
  },
  "analog_flow_configuration": {
    "description": "Comprehensive analog IP design flow configuration for behavioral modeling, circuit implementation, simulation, and layout targeting Cadence PDKs",
    "analog_ip_design": {
      "description": "Design flow for analog IP blocks including behavioral modeling, circuit implementation, simulation, and layout targeting a Cadence PDK",
      "stages": [
        {
          "name": "generate_behavioral_model",
          "description": "Create Verilog-A or SystemVerilog-AMS behavioral models based on specs in the /docs directory",
          "inputs": [
            "specs",
            "block_name"
          ],
          "outputs": [
            "behavioral_model.sv",
            "testbench.sv"
          ],
          "task_templates": {
            "verilog_a": "Generate Verilog-A behavioral model with proper module structure and parameter definitions",
            "systemverilog_ams": "Generate SystemVerilog-AMS model with mixed-signal capabilities",
            "testbench": "Create comprehensive testbench with corner case analysis and Monte Carlo simulation"
          },
          "verification_criteria": {
            "functional": "Behavioral model matches specification requirements",
            "performance": "Model achieves target performance metrics",
            "corner_cases": "Model handles process, voltage, and temperature variations"
          }
        },
        {
          "name": "design_transistor_level_circuit",
          "description": "Develop transistor-level implementation targeting a specified Cadence PDK, using the behavioral model as reference",
          "inputs": [
            "behavioral_model.sv",
            "pdks/cadence/<pdk-name>",
            "constraints"
          ],
          "outputs": [
            "schematic_cellview",
            "simulation_netlist"
          ],
          "task_templates": {
            "schematic": "Create transistor-level schematic with proper device sizing and biasing",
            "netlist": "Generate simulation-ready netlist with parasitic extraction",
            "constraints": "Define design constraints for area, power, and performance"
          },
          "verification_criteria": {
            "functionality": "Circuit implements required analog function",
            "performance": "Meets gain, bandwidth, noise, and power specifications",
            "robustness": "Design is robust across process corners"
          }
        },
        {
          "name": "simulate_with_spectre",
          "description": "Run Spectre simulations to validate the transistor-level design against functional and corner cases",
          "inputs": [
            "simulation_netlist",
            "spectre_config"
          ],
          "outputs": [
            "waveforms",
            "metrics",
            "monte_carlo_results"
          ],
          "task_templates": {
            "dc_analysis": "DC operating point analysis for biasing verification",
            "ac_analysis": "AC analysis for frequency response and stability",
            "transient": "Transient analysis for time-domain behavior",
            "noise": "Noise analysis for signal integrity",
            "monte_carlo": "Monte Carlo analysis for process variation"
          },
          "verification_criteria": {
            "accuracy": "Simulation results match behavioral model",
            "performance": "Meets all performance specifications",
            "corner_analysis": "Design works across process corners"
          }
        },
        {
          "name": "create_layout",
          "description": "Generate physical layout using Cadence Virtuoso with proper design rules and parasitic considerations",
          "inputs": [
            "schematic_cellview",
            "design_rules",
            "constraints"
          ],
          "outputs": [
            "layout_cellview",
            "gds_file",
            "extracted_netlist"
          ],
          "task_templates": {
            "floorplanning": "Plan layout topology and device placement",
            "routing": "Route interconnections with proper design rules",
            "extraction": "Extract parasitic capacitance and resistance",
            "verification": "Run DRC and LVS checks"
          },
          "verification_criteria": {
            "design_rules": "Layout passes all DRC checks",
            "schematic_match": "LVS verification passes",
            "parasitics": "Extracted netlist includes parasitics"
          }
        }
      ]
    },
    "tool_integration": {
      "cadence_virtuoso": {
        "description": "Primary tool for analog design and layout",
        "capabilities": [
          "Schematic capture",
          "Circuit simulation",
          "Layout design",
          "Design rule checking",
          "Layout vs. schematic verification"
        ],
        "file_types": [
          "schematic files (.cdb)",
          "layout files (.cdb)",
          "netlist files (.cdb)",
          "simulation files (.scs)"
        ]
      },
      "spectre": {
        "description": "Circuit simulator for analog design verification",
        "capabilities": [
          "DC analysis",
          "AC analysis",
          "Transient analysis",
          "Noise analysis",
          "Monte Carlo simulation",
          "Corner analysis"
        ],
        "output_formats": [
          "Waveform data",
          "Performance metrics",
          "Statistical results"
        ]
      }
    },
    "pdk_integration": {
      "description": "Process Design Kit integration for analog design",
      "cadence_pdks": {
        "description": "Cadence PDK support for various process nodes",
        "components": [
          "Device models",
          "Design rules",
          "Technology files",
          "Parameterized cells"
        ],
        "integration": "Seamless integration with Virtuoso and Spectre"
      }
    }
  },
  "mixed_signal_design": {
    "description": "Mixed-signal design considerations and workflows",
    "digital_analog_interface": {
      "description": "Interface between digital and analog domains",
      "considerations": [
        "Clock domain crossing",
        "Signal integrity",
        "Noise coupling",
        "Timing synchronization"
      ],
      "design_patterns": [
        "Level shifters",
        "Clock buffers",
        "Isolation techniques",
        "Filtering circuits"
      ]
    },
    "verification_strategies": {
      "description": "Verification approaches for mixed-signal designs",
      "co_simulation": "Digital and analog co-simulation",
      "interface_verification": "Verify digital-analog interfaces",
      "timing_analysis": "Mixed-signal timing analysis",
      "power_analysis": "Power consumption analysis"
    }
  },
  "chiplet_schema_structure": {
    "description": "New chiplet schema architecture with standards-first approach",
    "compliance": {
      "description": "Required standards foundation for interoperability",
      "cdxml": "OCP CDXML compliance for die-to-die interfaces",
      "bow_specification": "BoW protocol compliance with signaling and timing",
      "required": true,
      "purpose": "Ensure industry standard compliance and cross-vendor interoperability"
    },
    "extensions": {
      "description": "Optional vendor-specific customizations beyond standards",
      "meta": "Chiplet metadata and configuration",
      "testing": "Multi-die testing and validation",
      "lifecycle": "Supply chain and lifecycle management",
      "custom_electrical": "Vendor-specific electrical characteristics",
      "custom_physical": "Vendor-specific physical constraints",
      "required": false,
      "purpose": "Enable competitive differentiation while maintaining standards compliance"
    }
  },
  "cdxml_compliance": {
    "description": "OCP CDXML (Chiplet Design Exchange Format) compliance requirements",
    "version": "cdxml-v0.2",
    "interface_validation": {
      "description": "Die-to-die interface characteristics validation",
      "protocol_support": [
        "UCIe",
        "BoW",
        "AIB",
        "EMIB"
      ],
      "electrical_validation": "Power and electrical specifications per OCP",
      "mechanical_validation": "Physical and packaging specifications per OCP"
    },
    "compliance_checklist": {
      "description": "CDXML compliance validation checklist",
      "interface_definitions": "Standardized interface definitions for die-to-die communication",
      "electrical_characteristics": "Power and electrical specs per OCP specifications",
      "mechanical_constraints": "Physical and packaging constraints per OCP",
      "validation_tracking": "Compliance validation with tools and dates"
    }
  },
  "bow_specification": {
    "description": "BoW (Bunch of Wires) protocol compliance requirements",
    "spec_version": "2.0d.1",
    "signaling_validation": {
      "description": "BoW signaling characteristics validation",
      "voltage_classes": [
        "Class A",
        "Class B",
        "Class C"
      ],
      "signaling_protocol": "Simple, low-overhead protocol for cost-effective applications",
      "bump_configuration": "Physical bump configuration and connectivity"
    },
    "timing_validation": {
      "description": "BoW timing constraints validation",
      "clock_training": "Clock training and synchronization requirements",
      "signal_integrity": "Signal integrity and timing margins",
      "compliance_features": "Loopback, PRBS, error detection capabilities"
    }
  },
  "chiplet_workflow_configuration": {
    "description": "Comprehensive chiplet development workflow with standards compliance focus",
    "chiplet_development_phases": {
      "phase1_standards_compliance": {
        "description": "Standards compliance foundation and validation",
        "activities": [
          "Validate CDXML compliance for target OCP version",
          "Verify BoW specification compliance for target version",
          "Check interface protocol support (UCIe, BoW, AIB, EMIB)",
          "Establish compliance baseline and validation plan"
        ],
        "deliverables": [
          "CDXML compliance validation report",
          "BoW specification compliance report",
          "Interface protocol compliance matrix",
          "Compliance validation plan"
        ]
      },
      "phase2_design": {
        "description": "Chiplet architecture and interface design with standards compliance",
        "activities": [
          "Define chiplet boundaries and interfaces per CDXML",
          "Select die-to-die interface protocols per BoW spec",
          "Design chiplet wrapper with compliance validation",
          "Plan power domain partitioning per standards",
          "Define thermal and packaging requirements"
        ],
        "deliverables": [
          "Standards-compliant chiplet architecture specification",
          "CDXML-compliant interface protocol definitions",
          "BoW-compliant power domain specifications",
          "Thermal analysis requirements per standards"
        ]
      },
      "phase3_implementation": {
        "description": "RTL implementation and verification with compliance focus",
        "activities": [
          "Implement CDXML-compliant chiplet wrapper modules",
          "Develop BoW-compliant die-to-die interface logic",
          "Create power management logic per standards",
          "Implement test access mechanisms for compliance",
          "Develop chiplet-specific testbenches with validation"
        ],
        "deliverables": [
          "Standards-compliant chiplet RTL implementation",
          "CDXML-compliant interface verification testbenches",
          "BoW-compliant power domain verification",
          "Multi-die communication tests per standards"
        ]
      },
      "phase4_packaging": {
        "description": "Packaging design and constraints with standards compliance",
        "activities": [
          "Design interposer layout per CDXML mechanical specs",
          "Define bump map per BoW physical requirements",
          "Specify thermal management per standards",
          "Plan power delivery network per CDXML electrical",
          "Design test access infrastructure for compliance"
        ],
        "deliverables": [
          "CDXML-compliant interposer design constraints",
          "BoW-compliant bump map specifications",
          "Standards-compliant thermal analysis results",
          "CDXML-compliant power delivery specifications"
        ]
      },
      "phase5_integration": {
        "description": "Multi-die system integration with compliance validation",
        "activities": [
          "Integrate multiple chiplets with standards compliance",
          "Verify system-level functionality per CDXML",
          "Perform thermal and power analysis per standards",
          "Validate signal integrity per BoW requirements",
          "Execute system-level testing with compliance checks"
        ],
        "deliverables": [
          "Standards-compliant integrated system design",
          "CDXML-compliant system-level verification results",
          "Standards-compliant thermal and power analysis reports",
          "BoW-compliant signal integrity analysis"
        ]
      }
    },
    "chiplet_specific_tools": {
      "design_tools": {
        "interposer_design": [
          "Cadence Virtuoso",
          "Synopsys Custom Compiler",
          "OpenROAD (open-source)"
        ],
        "bump_planning": [
          "Cadence Package Designer",
          "Synopsys IC Validator",
          "Custom bump planning tools"
        ],
        "thermal_analysis": [
          "Cadence Celsius",
          "Synopsys PrimePower",
          "Ansys Icepak"
        ]
      },
      "verification_tools": {
        "signal_integrity": [
          "Cadence Sigrity",
          "Synopsys PrimeSim",
          "Custom SI analysis tools"
        ],
        "power_analysis": [
          "Cadence Voltus",
          "Synopsys PrimePower",
          "Custom power analysis tools"
        ],
        "compliance_validation": [
          "CDXML validation tools",
          "BoW compliance checkers",
          "Protocol validation tools"
        ]
      }
    },
    "interface_protocols": {
      "description": "Supported die-to-die interface protocols with compliance status",
      "ucie": {
        "description": "Universal Chiplet Interconnect Express",
        "features": [
          "Industry standard",
          "High bandwidth",
          "Low latency",
          "Advanced features"
        ],
        "use_cases": [
          "High-performance computing",
          "Data center applications",
          "AI/ML accelerators"
        ],
        "compliance": "CDXML v0.2 compliant"
      },
      "bow": {
        "description": "Bunch of Wires",
        "features": [
          "Simple protocol",
          "Low overhead",
          "Easy implementation",
          "Cost-effective"
        ],
        "use_cases": [
          "Consumer electronics",
          "IoT devices",
          "Cost-sensitive applications"
        ],
        "compliance": "BoW 2.0d.1 compliant"
      },
      "aib": {
        "description": "Advanced Interface Bus",
        "features": [
          "Intel proprietary",
          "High bandwidth",
          "Low power",
          "Advanced features"
        ],
        "use_cases": [
          "Intel-based systems",
          "FPGA integration",
          "High-performance applications"
        ],
        "compliance": "CDXML v0.2 compliant"
      },
      "emib": {
        "description": "Embedded Multi-die Interconnect Bridge",
        "features": [
          "Intel technology",
          "High density",
          "Low latency",
          "Advanced packaging"
        ],
        "use_cases": [
          "Intel advanced packaging",
          "High-density integration",
          "Performance-critical applications"
        ],
        "compliance": "CDXML v0.2 compliant"
      }
    },
    "packaging_considerations": {
      "interposer_technology": {
        "silicon_interposer": {
          "description": "Silicon-based interposer with high routing density",
          "advantages": [
            "High routing density",
            "Fine pitch connections",
            "Excellent electrical performance"
          ],
          "challenges": [
            "Higher cost",
            "Thermal management",
            "Design complexity"
          ]
        },
        "organic_interposer": {
          "description": "Organic substrate-based interposer",
          "advantages": [
            "Lower cost",
            "Easier thermal management",
            "Simpler design"
          ],
          "challenges": [
            "Lower routing density",
            "Limited electrical performance",
            "Coarser pitch"
          ]
        }
      },
      "bump_technology": {
        "micro_bumps": {
          "description": "Fine-pitch micro-bumps for high-density connections",
          "pitch_range": "40-100 Î¼m",
          "applications": "High-density die-to-die connections"
        },
        "c4_bumps": {
          "description": "Controlled collapse chip connection bumps",
          "pitch_range": "150-200 Î¼m",
          "applications": "Die-to-package connections"
        }
      }
    }
  },
  "ai_prompts": {
    "description": "AI assistance prompts for IP development across all flows with enhanced standards compliance and verification",
    "compliance_validation": {
      "validate_cdxml": "Validate chiplet against CDXML {version} with compliance checklist, interface validation, and electrical validation",
      "check_bow_compliance": "Check BoW {spec_version} compliance for {signaling_class} signaling, timing constraints, and bump configuration",
      "verify_interface_protocol": "Verify {protocol} compliance with {lane_configuration} and {training_requirements}",
      "validate_standards": "Validate chiplet compliance with {industry_standards} and {certification_requirements}"
    },
    "design_generation": {
      "generate_cdxml_compliant": "Generate CDXML-compliant chiplet interface for {protocol} with {interface_width} lanes",
      "create_bow_compliant": "Create BoW-compliant signaling for {class} with {timing} and {bump_config}",
      "design_compliance_wrapper": "Design compliance wrapper for {protocol} with {compliance_features}",
      "generate_standards_interface": "Generate standards-compliant interface using {protocol} specifications"
    },
    "packaging_design": {
      "generate_interposer": "Generate interposer design constraints for {interposer_tech} with {routing_layers} and {die_spacing}",
      "create_bump_map": "Create bump map constraints with {bump_pitch}, {bump_size}, and {power_signal_ratio}",
      "design_thermal": "Design thermal management for {power_dissipation} with {junction_temp} and {thermal_resistance}",
      "generate_packaging": "Generate packaging constraints for {package_type} with {pin_count} and thermal considerations"
    },
    "verification": {
      "create_compliance_test": "Create compliance test for {protocol} with {validation_requirements}",
      "generate_standards_testbench": "Generate standards-compliant testbench for {protocol} validation",
      "validate_signal_conformance": "Validate signal conformance against {protocol} specifications",
      "test_multi_die": "Create multi-die testbench with chiplet-to-chiplet communication testing",
      "formal_verification": "Create formal verification properties for {verification_target}",
      "assertion_generation": "Generate assertions for {specific_behavior} in this design",
      "coverage_analysis": "Analyze coverage gaps in this verification plan",
      "regression_testing": "Set up automated regression testing for {test_suite}"
    },
    "rtl_generation": {
      "generate_module": "Generate a SystemVerilog module for {functionality} with {interfaces}",
      "optimize_design": "Optimize this RTL design for {target_metric} while maintaining {constraints}",
      "fix_issues": "Identify and fix issues in this RTL code: {code_snippet}",
      "add_features": "Add {feature} to this existing module while preserving {existing_functionality}"
    },
    "testbench_generation": {
      "create_testbench": "Create a comprehensive testbench for {module_name} with {test_cases}",
      "add_coverage": "Add functional coverage for {specific_functionality} in this testbench",
      "generate_stimulus": "Generate test stimulus for {test_scenario} in this testbench",
      "debug_issues": "Help debug this testbench issue: {problem_description}"
    },
    "testbench_standards": {
      "description": "Default testbench generation standards for digital flows with SystemVerilog and Python Cocotb support",
      "digital_flow_requirements": {
        "systemverilog": {
          "description": "Primary testbench language for digital flows",
          "file_naming": "tb_{module_name}.sv",
          "features": [
            "Clock and reset generation",
            "DUT instantiation and interface connections",
            "Test stimulus generation and response checking",
            "Functional coverage collection",
            "Assertion-based verification",
            "Waveform generation for debugging"
          ],
          "coverage_goals": "95% functional coverage, 90% code coverage, 100% toggle coverage"
        },
        "python_cocotb": {
          "description": "Python-based testbench framework for digital flows",
          "file_naming": "test_{module_name}.py",
          "features": [
            "Python-based test stimulus generation",
            "cocotb framework integration",
            "VCD file generation for simulation",
            "Coverage collection and analysis",
            "Regression testing support",
            "CI/CD integration capabilities"
          ],
          "vcd_generation": {
            "description": "Generate VCD files for simulation waveform analysis",
            "simulator_support": [
              "iverilog",
              "verilator",
              "vcs",
              "modelsim"
            ],
            "file_naming": "{module_name}_simulation.vcd",
            "benefits": [
              "Waveform visualization in GTKWave or similar tools",
              "Debug signal behavior and timing",
              "Share simulation results with team members",
              "Support for automated analysis and verification"
            ]
          }
        },
        "dual_testbench_approach": {
          "description": "Provide both SystemVerilog and Python Cocotb testbenches for comprehensive verification",
          "benefits": [
            "Language flexibility for different team preferences",
            "Enhanced verification coverage through multiple approaches",
            "Python integration for complex test scenarios",
            "VCD file generation for detailed simulation analysis"
          ],
          "file_structure": {
            "systemverilog": "tb/{module_name}/tb_{module_name}.sv",
            "python_cocotb": "tb/{module_name}/test_{module_name}.py",
            "makefile": "tb/{module_name}/Makefile",
            "vcd_outputs": "tb/{module_name}/simulation_outputs/"
          }
        }
      },
      "non_digital_flows": {
        "analog_flows": "Use Verilog-A or SPICE-based testbenches with analog simulation tools",
        "mixed_signal_flows": "Combine digital testbenches with analog behavioral models",
        "chiplet_flows": "Use digital testbenches with chiplet-specific interface testing"
      }
    },
    "documentation": {
      "create_documentation": "Generate documentation for {component} following Vyges standards",
      "update_metadata": "Update metadata for {ip_block} with latest information",
      "create_diagrams": "Create ASCII diagrams for {system_architecture}",
      "write_user_guide": "Write a user guide for {ip_functionality}"
    },
    "flow_specific_assistance": {
      "asic_flow": "Provide ASIC-specific guidance for {design_type} including synthesis, timing, and area optimization",
      "fpga_flow": "Provide FPGA-specific guidance for {design_type} including pin constraints, synthesis, and implementation",
      "analog_flow": "Provide analog-specific guidance for {design_type} including behavioral modeling, circuit design, and layout",
      "chiplet_flow": "Provide chiplet-specific guidance for {design_type} including CDXML/BoW compliance and packaging",
      "digital_flow": "Provide digital design guidance for {design_type} including RTL, verification, and optimization",
      "verification_flow": "Provide verification-specific guidance for {design_type} including testbench, coverage, and formal verification"
    },
    "standards_compliance": {
      "validate_protocol": "Validate {protocol} compliance for {design_type} against {specification}",
      "check_standards": "Check {design_type} against {industry_standard} with compliance checklist",
      "verify_interface": "Verify {interface_type} interface compliance with {protocol_spec}",
      "generate_compliance_report": "Generate compliance validation report for {design_type} against {standards}"
    },
    "ai_copilot_integration": {
      "generate_from_metadata": "Generate complete IP specification and code scaffolding from vyges-metadata.json ai_copilot prompts",
      "validate_ai_compatibility": "Validate IP block for AI compatibility based on ai_copilot metadata requirements",
      "enhance_ai_assistance": "Enhance IP block to improve AI assistance capabilities and metadata coverage",
      "create_ai_optimized": "Create AI-optimized IP block with comprehensive metadata and verification support"
    },
    "create_module": "Create a SystemVerilog module following Vyges conventions. Include proper header, interface signals, and basic functionality.",
    "create_testbench": "Create a SystemVerilog testbench for the given module. Include clock generation, reset sequence, and basic test stimulus.",
    "expand_structure": "Suggest when to use 'vyges expand' commands to add complexity to the project structure.",
    "validate_structure": "Check if the current project structure follows Vyges conventions and suggest improvements.",
    "generate_documentation": "Generate documentation for the functional IP block based on the RTL code and metadata.",
    "refactor_module": "Refactor a SystemVerilog module to improve readability, modularity, and testability. Follow Vyges naming and structure conventions.",
    "add_interface": "Extend the functional IP module by adding a new interface using Vyges Standardized Interface Catalog (e.g., AXI4-Lite, APB, Wishbone). Include port declarations and update documentation.",
    "generate_catalog_ready_ip": "Create a SystemVerilog functional IP block that is ready for the Vyges Catalog. Include complete metadata, documentation, and testbench.",
    "check_catalog_readiness": "Validate the functional IP block for Vyges Catalog readiness: metadata coverage, testability, and discoverability.",
    "improve_catalog_score": "Improve this functional IP block to raise its catalog quality score by enhancing metadata, documentation, and test coverage.",
    "update_metadata_from_code": "Update vyges-metadata.json based on changes in RTL code and interfaces",
    "synchronize_metadata_code": "Ensure vyges-metadata.json and generated code are in sync",
    "validate_ip_name": "Validate IP name format for GitHub compatibility and Vyges ecosystem usage",
    "setup_project": "Guide developer through initial functional IP project setup using vyges init --interactive workflow",
    "use_standard_interfaces": "Use Vyges Standardized Interface Catalog signals and naming conventions for IP integration",
    "validate_interface_compliance": "Validate that interface signals follow Vyges Standardized Interface Catalog conventions",
    "generate_interface_wrapper": "Generate interface wrapper using standardized signal names from Vyges catalog",
    "generate_ascii_diagram": "Generate ASCII block diagram showing functional IP block with all pins, grouped by interface type (clock, reset, data, control, etc.) with signal descriptions",
    "generate_connection_diagram": "Generate ASCII diagram showing connections between multiple functional IP blocks, highlighting pin-to-pin connections and interface compatibility",
    "validate_pin_connections": "Validate pin connections between functional IP blocks for signal compatibility, timing, and protocol compliance",
    "generate_cocotb_testbench": "Generate comprehensive cocotb testbench with coverage, assertions, and waveform generation from vyges-metadata.json test specifications",
    "create_cocotb_harness": "Create cocotb verification harness that can be bundled into packaging metadata for automated testing",
    "setup_cocotb_ci": "Set up CI hooks for cocotb testbenches with verilator/vcs, returning waveform artifacts and coverage reports",
    "adapt_cocotb_chinese_tools": "Create cocotb-style testbench adapters for non-cocotb-compatible Chinese EDA tools",
    "generate_readme": "Generate comprehensive README.md following Vyges conventions with all required sections, tables, and badges",
    "update_readme_sections": "Update specific sections of README.md based on IP metadata and current project state",
    "generate_pinout_table": "Generate a Markdown pinout table for the functional IP block, listing all external signals with columns: Name, Function, Direction, Description, based on vyges-metadata.json.",
    "generate_design_document": "Generate comprehensive design specification document following Vyges conventions with all required sections, quality requirements, and visual aids",
    "validate_design_document": "Validate design document for completeness, consistency, traceability, and visual documentation quality",
    "enhance_design_document": "Improve existing design document by adding missing sections, enhancing visual aids, and ensuring quality compliance",
    "improve_documentation_readability": "Convert JSON code blocks and technical jargon to clear English text for better accessibility and readability",
    "create_chiplet_ready_ip": "Create a chiplet-ready IP block with die-to-die interface support, packaging considerations, and multi-die integration capabilities",
    "validate_chiplet_compatibility": "Validate IP block for chiplet integration readiness: interface compatibility, packaging requirements, and die-to-die connectivity",
    "generate_chiplet_interface": "Generate die-to-die interface wrapper using UCIe, BoW, AIB, or EMIB protocols for chiplet integration",
    "create_multi_die_testbench": "Create testbench for multi-die system simulation with chiplet-to-chiplet communication testing",
    "generate_chiplet_documentation": "Generate chiplet-specific documentation including packaging requirements, die-to-die interface specifications, and integration guidelines",
    "generate_interposer_constraints": "Generate interposer design constraints including technology, routing layers, pitch, and die spacing requirements",
    "create_bump_constraints": "Create bump map constraints with pitch, size, array configuration, and power/signal bump counts",
    "analyze_thermal_constraints": "Analyze and specify thermal constraints including power limits, junction temperature, thermal resistance, and cooling requirements",
    "design_multi_die_testing": "Design multi-die testing strategy with test access methods, coverage requirements, and test vector specifications",
    "validate_signal_conformance": "Validate signal conformance against protocol specifications with compliance testing and verification tools",
    "configure_power_domains": "Configure power domains with voltage levels, isolation requirements, retention capabilities, and current limits",
    "track_lifecycle_metadata": "Track lifecycle and supply chain metadata including origin, trusted fabricator status, certifications, and version control",
    "setup_fpga_project": "Set up FPGA project structure with appropriate toolchain, constraints, and IP cores",
    "generate_fpga_flow": "Generate FPGA-specific flow configuration with synthesis, implementation, and bitstream generation",
    "create_fpga_constraints": "Create FPGA timing and pin constraints for specific board and toolchain",
    "integrate_fpga_ip": "Integrate vendor IP cores with proper configuration and instantiation",
    "validate_fpga_timing": "Validate FPGA timing constraints and perform static timing analysis",
    "generate_fpga_bitstream": "Generate FPGA bitstream with proper synthesis and implementation flow",
    "setup_fpga_simulation": "Set up FPGA-specific simulation environment with vendor tools",
    "create_fpga_testbench": "Create FPGA-specific testbench for hardware verification",
    "analyze_fpga_utilization": "Analyze FPGA resource utilization and optimization opportunities",
    "generate_comprehensive_testbench": "Generate comprehensive testbench with functional, performance, corner case, error, and coverage tests",
    "create_verification_plan": "Create detailed verification plan with coverage goals, assertion requirements, and regression strategy",
    "setup_test_automation": "Set up automated test execution with multiple simulators and coverage reporting",
    "validate_test_coverage": "Validate test coverage against specified goals and requirements",
    "generate_analog_behavioral": "Generate Verilog-A behavioral model for {analog_block} with specifications: {specs}",
    "design_analog_circuit": "Design transistor-level circuit for {analog_block} targeting {pdk} with performance requirements: {specs}",
    "create_spectre_simulation": "Create Spectre simulation setup for {analog_block} with corner analysis and Monte Carlo simulation",
    "generate_analog_layout_constraints": "Generate layout constraints for {analog_block} with matching, symmetry, and routing requirements",
    "validate_analog_design": "Validate analog design {analog_block} against specifications: {specs}",
    "optimize_analog_performance": "Optimize {analog_block} for performance metrics: {metrics}",
    "create_analog_testbench": "Create comprehensive testbench for {analog_block} with corner case analysis",
    "generate_analog_documentation": "Generate analog design documentation for {analog_block} with performance analysis and layout guidelines",
    "setup_analog_project": "Set up analog project structure with behavioral, circuit, simulation, and layout directories"
  },
  "security_and_trust": {
    "description": "Security features and trust mechanisms for IP blocks",
    "security_levels": {
      "basic": "Basic security with standard protection features",
      "enhanced": "Enhanced security with additional protection mechanisms",
      "high": "High security for critical applications",
      "military": "Military-grade security for defense applications"
    },
    "protection_features": [
      "Tamper detection",
      "Side-channel attack protection",
      "Secure key storage",
      "Access control mechanisms",
      "Encryption and decryption",
      "Secure boot and authentication"
    ],
    "compliance_standards": [
      "ISO 26262 (Automotive)",
      "FIPS 140 (Cryptographic modules)",
      "Common Criteria (IT security)",
      "DO-254 (Avionics)",
      "IEC 61508 (Industrial safety)"
    ]
  },
  "security_testing_infrastructure": {
    "description": "Comprehensive security testing infrastructure patterns and targets",
    "makefile_security_targets": {
      "test_security": {
        "description": "Run full SystemVerilog security validation tests",
        "define": "SECURITY_ASSERTIONS",
        "tools": [
          "iverilog",
          "verilator"
        ],
        "coverage": "100% security assertion coverage"
      },
      "test_security_yosys": {
        "description": "Run security tests with Yosys compatibility",
        "define": "YOSYS_SYNTHESIS",
        "tools": [
          "iverilog",
          "yosys"
        ],
        "coverage": "Basic security validation without assertions"
      },
      "test_security_synthesis": {
        "description": "Test security checks in synthesis tools",
        "define": "YOSYS_SYNTHESIS",
        "tools": [
          "yosys",
          "synth"
        ],
        "purpose": "Verify security logic synthesizes correctly"
      },
      "test_security_coverage": {
        "description": "Validate security coverage requirements",
        "metrics": [
          "Security Assertions: 100%",
          "Vulnerability Coverage: 95%",
          "Attack Vector Coverage: 90%"
        ]
      },
      "generate_security_docs": {
        "description": "Generate comprehensive security documentation",
        "outputs": [
          "security_analysis.md",
          "threat_model.md",
          "vulnerability_assessment.md"
        ]
      }
    },
    "security_testbench_patterns": {
      "description": "Security testbench structure and patterns",
      "basic_structure": {
        "clock_reset": "Generate clock and reset signals",
        "test_control": "Test count, pass/fail tracking",
        "test_sequence": "Sequential execution of security tests",
        "coverage_reporting": "Comprehensive security coverage summary"
      },
      "security_test_categories": {
        "address_bounds": "Test illegal memory access prevention",
        "fsm_validity": "Test state machine security",
        "reset_synchronization": "Test reset behavior security",
        "memory_access": "Test memory access validation",
        "protocol_compliance": "Test bus protocol security",
        "data_integrity": "Test data validation security",
        "overflow_protection": "Test arithmetic overflow security",
        "buffer_access": "Test buffer selection security"
      }
    },
    "security_validation_workflow": {
      "description": "Security validation workflow phases",
      "development_phase": "Use YOSYS_SYNTHESIS for synthesis and basic validation",
      "verification_phase": "Use SECURITY_ASSERTIONS for comprehensive testing",
      "production_phase": "Enable both modes for maximum compatibility",
      "continuous_integration": "Run security tests in CI/CD pipeline"
    }
  },
  "security_test_generation": {
    "enabled": false,
    "default_settings": {
      "enabled": false,
      "tool_availability": "open_source",
      "target_flow": "fpga",
      "rationale": "Student-friendly defaults to lower barrier to entry"
    },
    "based_on_metadata": true,
    "frameworks": [
      "systemverilog",
      "cocotb",
      "uvm"
    ],
    "test_types": [
      "assert_illegal_address_access",
      "assert_fsm_safe_states",
      "inject_reset_glitch",
      "stress_random_inputs",
      "side_channel_analysis",
      "timing_attack_simulation",
      "fault_injection_testing",
      "cryptographic_validation",
      "privilege_escalation_check",
      "data_integrity_verification"
    ],
    "assertion_style": "systemverilog_assertions",
    "output_folder": "generated/security_tests",
    "metadata_integration": {
      "security_level": "Use security.enabled and security.security_level to determine test intensity",
      "tool_availability": "Use security.tool_availability to select open-source/commercial/hybrid tools",
      "target_flow": "Use security.target_flow to select tools from tools.{flow}.{license}.{category}",
      "risk_areas": "Generate targeted tests based on security.risk_areas array",
      "protection_features": "Validate implemented security.protection_features",
      "recommended_tests": "Generate tests from security.recommended_tests array",
      "assertion_coverage": "Use security.assertion_coverage for coverage requirements",
      "fuzzing_config": "Apply security.fuzzing_config for randomized testing",
      "formal_verification": "Use security.formal_verification.tools from tools.{flow}.{license}.formal",
      "side_channel_analysis": "Use security.side_channel_analysis.analysis_tools from tools.{flow}.{license}.security",
      "compliance_standards": "Validate against security.compliance_standards"
    },
    "ai_prompts": {
      "generate_security_assertions": "Generate SystemVerilog assertions for {risk_area} based on security metadata for {module_name}",
      "create_security_testbench": "Create security-focused testbench for {module_name} with {test_types} based on security metadata",
      "generate_fuzzing_tests": "Generate fuzzing tests for {module_name} using {fuzzing_config} from security metadata",
      "create_formal_properties": "Generate formal verification properties for {module_name} based on {security_properties}",
      "generate_side_channel_tests": "Generate side-channel analysis tests for {module_name} targeting {attack_vectors}",
      "validate_security_compliance": "Validate {module_name} against {compliance_standards} security requirements",
      "create_security_documentation": "Generate security documentation for {module_name} including threat model and validation results",
      "select_security_tools": "Recommend appropriate security testing tools for {module_name} based on {tool_availability} and {security_level}",
      "select_target_flow_tools": "Select security tools for {module_name} from tools.{target_flow}.{tool_availability}.{category} based on security metadata",
      "generate_oss_security_tests": "Generate security tests for {module_name} using open-source tools only",
      "generate_commercial_security_tests": "Generate security tests for {module_name} using commercial tools with {tool_licenses}",
      "create_hybrid_security_workflow": "Create hybrid security testing workflow for {module_name} combining open-source and commercial tools",
      "configure_student_defaults": "Configure {module_name} with student-friendly defaults: security disabled, FPGA target flow, open-source tools"
    },
    "test_generation_rules": {
      "memory_access": {
        "description": "Generate tests for memory access control and validation",
        "assertions": [
          "assert property (!(addr >= MEM_SIZE)) else $fatal('Out-of-bounds memory access');",
          "assert property (valid_addr -> granted_access) else $fatal('Invalid memory access granted');"
        ],
        "test_cases": [
          "Test illegal address access",
          "Test address range validation",
          "Test memory protection mechanisms"
        ]
      },
      "fsm_state_control": {
        "description": "Generate tests for FSM state validation and safe transitions",
        "assertions": [
          "assert property (state inside {IDLE, START, RUN, DONE}) else $fatal('Illegal FSM state');",
          "assert property (state == IDLE && valid_transition -> next_state inside {START, ERROR}) else $fatal('Invalid FSM transition');"
        ],
        "test_cases": [
          "Test illegal state transitions",
          "Test state machine security",
          "Test reset behavior"
        ]
      }
    }
  },
  "ieee_p1735_encryption": {
    "description": "IEEE P1735 encryption standards for IP protection",
    "encryption_methods": [
      "AES encryption for IP cores",
      "RSA encryption for licensing",
      "Digital signatures for authenticity",
      "Watermarking for IP identification"
    ],
    "implementation": {
      "encryption_blocks": "Implement encryption/decryption logic",
      "key_management": "Secure key storage and distribution",
      "license_validation": "Validate IP licenses at runtime",
      "tamper_detection": "Detect unauthorized modifications"
    }
  },
  "advanced_ip_types": {
    "description": "Support for advanced IP types including memory, security, and network IP blocks",
    "memory_ip": {
      "description": "Memory IP blocks and controllers",
      "controller": "Memory controller IP (DDR, LPDDR, SRAM, etc.)",
      "phy": "Memory PHY IP for high-speed interfaces",
      "ecc": "Error correction and detection features"
    },
    "security_ip": {
      "description": "Security and cryptographic IP blocks",
      "crypto": "Cryptographic accelerator IP (AES, RSA, ECC, etc.)",
      "trng": "True random number generator IP",
      "secure_boot": "Secure boot and root of trust IP"
    },
    "network_ip": {
      "description": "Network and communication IP blocks",
      "ethernet": "Ethernet MAC/PHY IP",
      "pcie": "PCI Express controller IP",
      "usb": "USB controller IP",
      "can": "CAN bus controller IP"
    },
    "ai_ml_support": {
      "description": "AI and machine learning IP support",
      "neural_network_accelerators": "Implement neural network processing units",
      "tensor_operations": "Optimize tensor operations for ML workloads",
      "quantization": "Support different precision levels",
      "model_compression": "Implement model compression techniques",
      "ai_ip_types": {
        "neural_network_accelerator": "Hardware accelerator for neural network inference/training",
        "ml_processor": "Processor optimized for machine learning workloads",
        "ai_peripheral": "Peripheral IP for AI/ML data movement and preprocessing"
      },
      "ai_ml_features": {
        "quantization": "Support for quantized neural network operations",
        "sparsity": "Sparsity-aware computation and storage",
        "reconfigurability": "Reconfigurable datapaths for AI workloads",
        "on_chip_memory": "On-chip memory for AI model storage",
        "dma_support": "DMA engines for high-throughput data movement"
      },
      "ml_verification": {
        "dataset_driven": "Verification using real-world datasets",
        "golden_model": "Golden model comparison for accuracy",
        "corner_case_generation": "Corner case input generation for ML models",
        "ai_prompts": {
          "generate_ai_ip": "Generate hardware accelerator for {model_type} neural network",
          "verify_ml_ip": "Verify ML IP block using {dataset} and {metrics}",
          "compare_golden_model": "Compare hardware results to golden model for {model_type}",
          "generate_corner_cases": "Generate corner case inputs for {model_type} verification"
        }
      }
    },
    "chiplet_integration": {
      "description": "Chiplet integration and packaging",
      "die_to_die_interfaces": [
        "UCIe (Universal Chiplet Interconnect Express)",
        "BoW (Bunch of Wires)",
        "AIB (Advanced Interface Bus)",
        "EMIB (Intel Embedded Multi-die Interconnect Bridge)"
      ],
      "packaging_considerations": {
        "interposer_technology": "Silicon or organic interposer",
        "bump_pitch": "Micro-bump pitch and density",
        "thermal_management": "Power dissipation and cooling",
        "test_access": "Test access mechanisms for chiplets"
      }
    },
    "quantum_computing": {
      "description": "Quantum computing IP support",
      "quantum_error_correction": "Implement error correction codes",
      "quantum_gates": "Design quantum logic gates",
      "quantum_measurement": "Quantum state measurement circuits",
      "cryogenic_operation": "Low-temperature operation considerations"
    },
    "ai_prompts": {
      "description": "AI prompts for advanced IP generation",
      "generate_memory_ip": "Generate memory controller IP for {memory_type}",
      "generate_security_ip": "Generate security IP block for {security_feature}",
      "generate_network_ip": "Generate network IP block for {protocol}",
      "implement_dual_mode_security": "Implement dual-mode security for {module_name}: YOSYS_SYNTHESIS mode for synthesis tools, SECURITY_ASSERTIONS mode for full SystemVerilog support, using conditional compilation with ifdef/endif blocks",
      "create_security_test_infrastructure": "Create comprehensive security testing infrastructure for {module_name} including Makefile targets, testbenches, and coverage validation for both Yosys and full SystemVerilog modes",
      "generate_security_validation": "Generate comprehensive security validation testbench for {module_name} covering all identified risk areas and attack vectors with dual-mode support"
    }
  },
  "performance_and_power_analysis": {
    "description": "Performance benchmarking, power analysis, and thermal management for IP blocks",
    "performance_benchmarking": {
      "description": "Standardized performance benchmarking and analysis",
      "performance_metrics": {
        "throughput": "Data processing throughput (Mbps, Gbps)",
        "latency": "Processing latency and response time",
        "frequency": "Maximum operating frequency",
        "area": "Silicon area utilization",
        "efficiency": "Performance per unit area/power",
        "scalability": "Performance scaling with parameters"
      },
      "benchmark_suites": {
        "synthetic": "Synthetic benchmark tests for basic performance",
        "real_world": "Real-world workload simulation",
        "stress": "Stress testing for maximum performance",
        "corner_case": "Corner case performance analysis",
        "comparative": "Comparative analysis against similar IP"
      },
      "measurement_methods": {
        "simulation": "Performance measurement through simulation",
        "emulation": "Performance measurement through emulation",
        "prototyping": "Performance measurement on prototype hardware",
        "production": "Performance measurement on production silicon"
      },
      "ai_prompts": {
        "performance_analysis": "Analyze performance of {ip_name} using {metrics} and {methods}",
        "benchmark_creation": "Create performance benchmarks for {ip_name} with {workloads}",
        "performance_optimization": "Optimize performance of {ip_name} for {target_metrics}",
        "comparative_analysis": "Compare performance of {ip_name} against {baseline}"
      }
    },
    "power_analysis": {
      "description": "Power analysis and optimization for IP blocks",
      "power_metrics": {
        "static_power": "Static power consumption (leakage)",
        "dynamic_power": "Dynamic power consumption (switching)",
        "peak_power": "Peak power consumption",
        "average_power": "Average power consumption",
        "power_efficiency": "Power efficiency (performance per watt)",
        "power_density": "Power density (watts per mmÂ²)"
      },
      "power_analysis_types": {
        "gate_level": "Gate-level power analysis",
        "rtl_level": "RTL-level power estimation",
        "architectural": "Architectural-level power analysis",
        "system_level": "System-level power analysis"
      },
      "power_optimization": {
        "clock_gating": "Clock gating for dynamic power reduction",
        "power_gating": "Power gating for static power reduction",
        "voltage_scaling": "Dynamic voltage scaling",
        "frequency_scaling": "Dynamic frequency scaling",
        "logic_optimization": "Logic optimization for power reduction",
        "memory_optimization": "Memory access optimization"
      },
      "tools": {
        "power_estimation": [
          "synopsys_power",
          "cadence_power",
          "mentor_power"
        ],
        "power_analysis": [
          "primetime_px",
          "voltus",
          "powerpro"
        ],
        "power_optimization": [
          "design_compiler",
          "ic_compiler",
          "innovus"
        ]
      },
      "ai_prompts": {
        "power_analysis": "Analyze power consumption of {ip_name} using {analysis_type}",
        "power_optimization": "Optimize power consumption of {ip_name} using {techniques}",
        "power_estimation": "Estimate power consumption of {ip_name} at {level}",
        "power_efficiency": "Improve power efficiency of {ip_name} for {target}"
      }
    }
  },
  "catalog_context": {
    "purpose": "Support Vyges IP Catalog operations and discoverability",
    "fields": {
      "name": "IP package name with org/user prefix",
      "version": "IP version following semantic versioning",
      "interfaces": "Signals and protocols exposed by the IP",
      "target": "asic/fpga target platforms",
      "design_type": "digital|analog|mixed-signal design type",
      "toolchain_support": "validated tools and flows",
      "tags": "discovery tags for catalog search",
      "trust_profile": "security indicators and maturity level",
      "maturity": "alpha|beta|stable|deprecated maturity status",
      "license": "SPDX license identifier",
      "maintainers": "contact information for IP maintainers",
      "chiplet_ready": "boolean indicating if IP is designed for chiplet integration",
      "integration_level": "rtl|netlist|hard_ip indicating integration abstraction level",
      "compliance": {
        "cdxml": "CDXML compliance version and validation status",
        "bow_specification": "BoW specification compliance and validation status",
        "standards_validation": "Overall standards compliance validation status"
      },
      "extensions": {
        "meta": "Chiplet metadata and configuration information",
        "testing": "Multi-die testing and validation requirements",
        "lifecycle": "Supply chain and lifecycle management information",
        "custom_electrical": "Vendor-specific electrical characteristics",
        "custom_physical": "Vendor-specific physical constraints"
      },
      "packaging_considerations": "notes about physical packaging requirements",
      "die_to_die_interfaces": "list of supported die-to-die interface protocols",
      "interposer_constraints": "interposer technology, routing layers, pitch, die spacing",
      "bump_constraints": "bump pitch, size, array configuration, power/signal counts",
      "thermal_constraints": "power limits, junction temperature, thermal resistance, cooling",
      "multi_die_testing": "test access methods, coverage requirements, test vectors",
      "signal_conformance": "protocol compliance, verification tools, test suites",
      "power_domains": "voltage, isolation, retention, current limits per domain",
      "lifecycle": "origin, trusted fabricator, certifications, supply chain tracking"
    },
    "ai_prompts": {
      "generate_catalog_entry": "Generate a catalog-ready summary with name, version, description, interfaces, targets, tags, and trust indicators for the Vyges IP Catalog.",
      "check_catalog_readiness": "Validate the IP block for Vyges Catalog readiness: metadata coverage, testability, and discoverability.",
      "improve_catalog_presentation": "Enhance IP metadata for better catalog presentation: improve description, add relevant tags, optimize discoverability, and suggest appropriate hierarchical categories.",
      "validate_catalog_compliance": "Check IP metadata for Vyges Catalog compliance: required fields, format validation, and completeness.",
      "suggest_catalog_categories": "Suggest appropriate hierarchical catalog categories for this IP block using the Vyges catalog structure with main categories and subcategories based on functionality, interfaces, and target applications."
    },
    "ai_assistance": {
      "description": "AI assistance capabilities for catalog management and discovery",
      "flow_specific_guidance": {
        "asic_flow": "Provide ASIC-specific catalog guidance including synthesis support, timing analysis, and power management",
        "fpga_flow": "Provide FPGA-specific catalog guidance including pin constraints, resource utilization, and implementation support",
        "analog_flow": "Provide analog-specific catalog guidance including behavioral modeling, circuit design, and mixed-signal support",
        "chiplet_flow": "Provide chiplet-specific catalog guidance including CDXML/BoW compliance and packaging considerations"
      },
      "standards_compliance": {
        "cdxml_validation": "Guide CDXML compliance validation for chiplet catalog entries",
        "bow_validation": "Guide BoW compliance validation for chiplet catalog entries",
        "standards_cataloging": "Guide standards-compliant catalog entry creation and validation",
        "compliance_reporting": "Guide compliance reporting and validation for catalog entries"
      },
      "discovery_optimization": {
        "tag_generation": "Generate relevant tags for {ip_type} with {interfaces} and {target_flows}",
        "category_suggestion": "Suggest appropriate categories for {ip_type} based on {functionality} and {applications}",
        "search_optimization": "Optimize metadata for search and discovery with {keywords} and {descriptions}",
        "related_ip_suggestion": "Suggest related IPs for {ip_type} based on {interfaces} and {functionality}"
      }
    },
    "discoverability_features": {
      "tags": "Generate relevant tags for IP discovery (e.g., uart, communication, apb, asic, fpga)",
      "keywords": "Extract search keywords from IP description and interfaces",
      "categories": "Suggest appropriate catalog categories based on IP type and interfaces using the hierarchical Vyges catalog structure",
      "related_ips": "Identify related IPs in the catalog based on interfaces and functionality"
    },
    "catalog_categories": {
      "description": "Comprehensive hierarchical catalog categories for IP classification",
      "main_categories": {
        "Analog & Mixed-Signal": {
          "description": "Analog circuits, mixed-signal designs, and analog-to-digital interfaces",
          "subcategories": [
            "Data Converters",
            "Analog Front-End",
            "Power Management",
            "Clock Generation",
            "Sensor Interfaces"
          ]
        },
        "Communication & Networking": {
          "description": "Communication protocols, networking interfaces, and data transmission",
          "subcategories": [
            "Serial Interfaces",
            "Parallel Interfaces",
            "Network Protocols",
            "Wireless Interfaces",
            "Optical Interfaces"
          ]
        },
        "Memory & Storage": {
          "description": "Memory controllers, storage interfaces, and data management",
          "subcategories": [
            "Memory Controllers",
            "Storage Interfaces",
            "Cache Management",
            "Data Compression",
            "Error Correction"
          ]
        },
        "Processing & Computing": {
          "description": "Processing units, computing accelerators, and computational logic",
          "subcategories": [
            "CPU Cores",
            "GPU Units",
            "DSP Processors",
            "AI Accelerators",
            "Cryptographic Units"
          ]
        },
        "Security & Trust": {
          "description": "Security features, trust mechanisms, and cryptographic functions",
          "subcategories": [
            "Cryptographic Engines",
            "Secure Boot",
            "Trusted Execution",
            "Key Management",
            "Security Monitors"
          ]
        }
      }
    }
  },
  "metadata_structure": {
    "description": "Standard Vyges metadata structure for all IP blocks",
    "required_fields": [
      "name",
      "version",
      "description",
      "license",
      "target",
      "design_type",
      "maturity",
      "template",
      "created",
      "updated"
    ],
    "optional_fields": [
      "parameters",
      "interfaces",
      "source",
      "sourceFiles",
      "files",
      "test",
      "flows",
      "meta"
    ],
    "default_values": {
      "license": "MIT",
      "target": [
        "asic"
      ],
      "design_type": [
        "digital"
      ],
      "maturity": "beta",
      "template": "vyges-ip-template@1.0.0"
    }
  },
  "sourceFiles_structure": {
    "description": "Detailed metadata for individual source files to prevent namespace collisions and improve traceability",
    "benefits": {
      "namespace_collision_prevention": "Prevents naming conflicts between different functional blocks within the same IP",
      "improved_traceability": "Clear ownership and versioning information for each source file",
      "vendor_integration": "Comprehensive metadata for third-party IP including documentation and contact information",
      "ai_automation_friendly": "Structured metadata enables AI engines to understand file relationships and dependencies",
      "licensing_clarity": "Individual file licensing prevents license conflicts in mixed-license projects"
    },
    "required_fields": [
      "path",
      "type",
      "owner",
      "version",
      "license"
    ],
    "optional_fields": [
      "vendor",
      "block"
    ],
    "file_types": {
      "rtl": "RTL source files (SystemVerilog, Verilog, VHDL)",
      "testbench": "Testbench and verification files",
      "constraint": "Synthesis and implementation constraints",
      "doc": "Documentation files",
      "header": "Header and include files"
    },
    "vendor_information": {
      "name": "Vendor or organization name",
      "docs": "Documentation links with types: datasheet, user_guide, api_ref, app_note, reference_manual, integration_guide, other",
      "contact": "Contact information with email, URL, and optional phone"
    },
    "block_field": "Logical block name or namespace to prevent naming conflicts between functional blocks within the same IP",
    "file_naming_enforcement": {
      "one_module_per_file": "Each RTL file must contain exactly one module",
      "filename_module_match": "Filename must match module name exactly (e.g., module spi_controller must be in spi_controller.sv)",
      "naming_pattern": "Use {block}_{module}.sv for internal files, {vendor}_{block}_{module}.sv for third-party IP",
      "file_placement": "RTL files in rtl/, testbenches in tb/, headers in rtl/ or include/, constraints in constraints/"
    }
  },
  "catalog_score_guidance": {
    "weighting": {
      "metadata_completeness": 35,
      "test_coverage": 20,
      "code_quality": 15,
      "documentation": 10,
      "discoverability_tags": 10,
      "security_validation": 10
    },
    "chiplet_specific_weighting": {
      "interface_compliance": 25,
      "thermal_analysis": 20,
      "power_integrity": 20,
      "signal_integrity": 15,
      "reliability_validation": 10,
      "ecosystem_integration": 10
    },
    "ai_prompt": "Improve this IP block to raise its catalog quality score"
  },
  "workflow_automation": {
    "description": "Workflow automation and CI/CD integration",
    "makefile_patterns": {
      "description": "Standard Makefile patterns for IP development",
      "targets": [
        "build: Compile and synthesize the design",
        "sim: Run simulation with specified testbench",
        "test: Run all tests and generate reports",
        "clean: Remove generated files and artifacts",
        "help: Display available targets and usage"
      ],
      "variables": "Define variables for tool paths, options, and configurations",
      "dependencies": "Specify proper dependencies between targets",
      "parallel_execution": "Enable parallel execution where possible"
    },
    "ci_cd_integration": {
      "description": "Continuous integration and deployment integration",
      "github_actions": "Use GitHub Actions for automated testing and validation",
      "gitlab_ci": "Use GitLab CI for automated workflows",
      "jenkins": "Use Jenkins for enterprise CI/CD pipelines",
      "automation_goals": [
        "Automated testing on every commit",
        "Automated validation of IP quality",
        "Automated generation of reports",
        "Automated deployment to catalog"
      ]
    },
    "quality_gates": {
      "description": "Quality gates and validation checkpoints",
      "syntax_checking": "Verify RTL syntax and basic rules",
      "linting": "Run linting tools and fix violations",
      "simulation": "Run basic simulation tests",
      "synthesis": "Verify design synthesizes correctly",
      "documentation": "Ensure documentation is complete and up-to-date"
    }
  },
  "collaboration": {
    "description": "Collaboration and team development features",
    "team_workflows": {
      "description": "Team collaboration workflows and processes",
      "branching": "Branching strategies for collaborative development",
      "merging": "Merging and conflict resolution workflows",
      "review_process": "Code review and approval workflows",
      "issue_tracking": "Issue tracking and project management integration"
    },
    "version_control": {
      "description": "Version control tools and best practices",
      "tools": [
        "git",
        "github",
        "gitlab",
        "bitbucket"
      ],
      "best_practices": "Best practices for version control in hardware projects"
    },
    "code_review": {
      "description": "Code review processes and guidelines",
      "review_checklist": [
        "Code follows Vyges naming conventions",
        "RTL follows coding standards",
        "Testbench provides adequate coverage",
        "Documentation is complete and accurate",
        "Security requirements are met"
      ],
      "review_tools": "Use appropriate tools for code review and collaboration",
      "feedback_integration": "Integrate review feedback into development workflow",
      "automated_review": "Automated code review using AI and static analysis tools",
      "peer_review": "Peer review workflow for code and documentation",
      "standardized_checklists": "Standardized review checklists for IP quality"
    },
    "version_management": {
      "description": "Version management and release processes",
      "semantic_versioning": "Follow semantic versioning for IP releases",
      "changelog": "Maintain changelog for all releases",
      "release_notes": "Generate comprehensive release notes",
      "backward_compatibility": "Ensure backward compatibility when possible"
    },
    "knowledge_sharing": {
      "description": "Knowledge sharing and documentation practices",
      "best_practices": "Document and share best practices across the team",
      "lessons_learned": "Capture and share lessons learned from projects",
      "training_materials": "Create training materials for new team members",
      "community_contributions": "Contribute to the broader Vyges community"
    },
    "static_analysis": {
      "description": "Static analysis and code quality tools",
      "tools": [
        "verilator",
        "spyglass",
        "codeql",
        "semgrep"
      ],
      "integration": "CI/CD integration for static analysis and linting"
    },
    "security_scanning": {
      "description": "Security scanning and vulnerability detection",
      "tools": [
        "bandit",
        "semgrep",
        "codeql"
      ],
      "integration": "Automated security scanning in CI/CD pipeline"
    },
    "collaboration_ai_prompts": {
      "description": "AI prompts for collaboration and team workflows",
      "suggest_branching": "Suggest branching strategy for {project_type}",
      "suggest_review_process": "Suggest code review process for {team_size}",
      "track_issues": "Track issues and progress for {ip_name}"
    }
  },
  "advanced_verification": {
    "description": "Advanced verification methodologies including formal verification, emulation, and hardware-in-the-loop testing",
    "formal_verification": {
      "description": "Formal verification methodology support for IP blocks",
      "formal_methods": {
        "model_checking": "Model checking for temporal logic verification",
        "theorem_proving": "Theorem proving for mathematical correctness",
        "equivalence_checking": "Equivalence checking between design representations",
        "property_checking": "Property checking using formal assertions",
        "reachability_analysis": "Reachability analysis for state space exploration"
      },
      "formal_tools": {
        "model_checkers": [
          "jkind",
          "pkind",
          "kind2",
          "nuXmv",
          "sal"
        ],
        "theorem_provers": [
          "coq",
          "isabelle",
          "hol",
          "acl2"
        ],
        "equivalence_checkers": [
          "conformal",
          "formality",
          "lec"
        ],
        "property_checkers": [
          "jasper",
          "vc_formal",
          "questa_formal"
        ]
      },
      "formal_properties": {
        "safety": "Safety properties (bad states never reached)",
        "liveness": "Liveness properties (good states eventually reached)",
        "invariants": "Invariant properties (always true conditions)",
        "protocol": "Protocol compliance properties",
        "timing": "Timing and performance properties"
      },
      "verification_goals": {
        "functional_correctness": "Functional correctness verification",
        "protocol_compliance": "Protocol compliance verification",
        "safety_critical": "Safety-critical property verification",
        "security_properties": "Security property verification",
        "performance_guarantees": "Performance guarantee verification"
      },
      "ai_prompts": {
        "formal_specification": "Create formal specification for {ip_name} with {properties}",
        "formal_verification": "Perform formal verification of {ip_name} using {methods}",
        "property_generation": "Generate formal properties for {ip_name} verification",
        "formal_analysis": "Analyze formal verification results for {ip_name}"
      }
    }
  },
  "intelligent_naming_suggestions": {
    "description": "AI-powered naming suggestions for IP development workflow, providing intelligent block name recommendations and document tracking for IP evolution",
    "workflow_integration": {
      "initial_prompt": "When user says 'Develop a design and architecture specification for ____ IP using Vyges Conventions', provide intelligent block name suggestions and document structure",
      "naming_workflow": [
        "1. Capture current date using 'date' command",
        "2. Analyze IP type and functionality from user request",
        "3. Suggest appropriate block name (IP block identifier) following Vyges conventions",
        "4. Create document structure with block name prefix",
        "5. Store original user requirements in raw format",
        "6. Prepare for specification and architecture development"
      ],
      "early_flow_determination": {
        "description": "Critical early decision point to determine design flow and avoid unnecessary code generation",
        "timing": "After block name selection and before detailed specification development",
        "default_options": {
          "description": "Sensible defaults to streamline workflow and provide good starting points",
          "design_type_default": "digital",
          "target_platform_default": "asic",
          "pdk_default": "gf180mcu",
          "rationale": "Digital ASIC designs with open-source PDK provide broad accessibility and learning opportunities",
          "default_benefits": [
            "Reduces initial decision complexity",
            "Provides proven open-source technology stack",
            "Enables rapid prototyping and learning",
            "No licensing costs or NDA requirements",
            "Community support and documentation available"
          ]
        },
        "flow_questions": [
          "1. Design Type: Is this a digital design, mixed-signal design, or analog design? (Default: digital)",
          "2. Target Platform: Do you want to target ASIC, FPGA, or both platforms? (Default: ASIC)",
          "3. Technology Node: For ASIC, what technology node or PDK do you want to use? (Default: GF180 180nm open-source PDK)"
        ],
        "design_type_options": {
          "digital": {
            "description": "Pure digital design with standard cell libraries",
            "characteristics": [
              "Standard cell-based implementation",
              "Synthesis and place-and-route flow",
              "Digital timing analysis and optimization",
              "Standard verification methodologies"
            ],
            "code_generation": "Generate digital RTL, testbenches, and synthesis constraints"
          },
          "mixed_signal": {
            "description": "Combines digital and analog/mixed-signal components",
            "characteristics": [
              "Digital RTL + analog behavioral models",
              "Mixed-signal simulation and verification",
              "Analog-digital interface considerations",
              "Layout-aware design constraints"
            ],
            "code_generation": "Generate digital RTL, analog behavioral models, and mixed-signal testbenches"
          },
          "analog": {
            "description": "Pure analog design with custom circuits",
            "characteristics": [
              "Custom transistor-level design",
              "Analog simulation and analysis",
              "Layout-dependent design rules",
              "Analog verification methodologies"
            ],
            "code_generation": "Generate analog behavioral models, SPICE netlists, and analog testbenches"
          }
        },
        "platform_targeting": {
          "asic_only": {
            "description": "Target only ASIC implementation",
            "benefits": [
              "Optimized for silicon implementation",
              "Full custom design capabilities",
              "Advanced power and area optimization",
              "Technology-specific optimizations"
            ],
            "workflow": "ASIC-specific RTL, synthesis, place-and-route, timing analysis"
          },
          "fpga_only": {
            "description": "Target only FPGA implementation",
            "benefits": [
              "Rapid prototyping and development",
              "Field-programmable flexibility",
              "Vendor IP integration",
              "Faster time-to-market"
            ],
            "workflow": "FPGA-specific RTL, synthesis, implementation, bitstream generation"
          },
          "both_platforms": {
            "description": "Target both ASIC and FPGA platforms",
            "benefits": [
              "Platform-agnostic design",
              "Reusable IP across platforms",
              "Flexible deployment options",
              "Cost-effective development"
            ],
            "workflow": "Platform-agnostic RTL with platform-specific constraints and flows"
          }
        },
        "pdk_selection": {
          "description": "Process Design Kit selection for ASIC flows",
          "open_source_pdks": {
            "description": "Free, open-source PDKs for academic and research use",
            "options": [
              "Google/SkyWater 130nm (sky130)",
              "Google/GlobalFoundries 180nm (gf180mcu)",
              "OpenPDK 45nm (nangate45)",
              "OpenPDK 15nm (nangate15)",
              "OpenPDK 7nm (nangate7)"
            ],
            "benefits": [
              "No licensing costs",
              "Academic and research friendly",
              "Community support and documentation",
              "Open-source toolchain compatibility"
            ],
            "limitations": [
              "Limited technology nodes",
              "Basic cell libraries",
              "Limited vendor support",
              "May not meet production requirements"
            ]
          },
          "commercial_pdks": {
            "description": "Commercial PDKs with full vendor support",
            "options": [
              "TSMC 28nm, 16nm, 7nm, 5nm, 3nm",
              "GlobalFoundries 22nm, 12nm, 7nm",
              "Intel 22nm, 14nm, 10nm, 7nm",
              "Samsung 28nm, 14nm, 10nm, 7nm, 5nm",
              "SMIC 28nm, 14nm, 12nm, 7nm"
            ],
            "benefits": [
              "Advanced technology nodes",
              "Full cell libraries and IP",
              "Vendor support and documentation",
              "Production-ready quality",
              "Advanced design rules and constraints"
            ],
            "considerations": [
              "Licensing costs and agreements",
              "NDA requirements",
              "Vendor-specific toolchains",
              "Production volume requirements"
            ]
          },
          "pdk_impact": {
            "design_rules": "PDK determines minimum feature sizes, spacing, and design rules",
            "cell_libraries": "Available standard cells, memories, and IP blocks",
            "toolchain": "Compatible synthesis, place-and-route, and verification tools",
            "constraints": "Timing, power, and area constraints specific to the technology",
            "verification": "Design rule checking (DRC) and layout vs. schematic (LVS) requirements"
          }
        },
        "workflow_guidance": {
          "digital_asic": "Generate ASIC-optimized RTL with synthesis constraints and timing analysis",
          "digital_fpga": "Generate FPGA-optimized RTL with vendor-specific constraints and implementation",
          "mixed_signal_asic": "Generate digital RTL + analog behavioral models with mixed-signal simulation",
          "mixed_signal_fpga": "Generate digital RTL with analog interface models for FPGA implementation",
          "analog_asic": "Generate analog behavioral models and SPICE netlists with layout constraints"
        },
        "default_workflow_example": {
          "description": "Example workflow when user accepts all default options",
          "default_choices": {
            "design_type": "digital",
            "target_platform": "asic",
            "pdk": "gf180mcu"
          },
          "generated_artifacts": [
            "ASIC-optimized RTL with GF180 PDK constraints",
            "Digital testbenches (SystemVerilog + Python Cocotb + VCD)",
            "GF180-specific synthesis constraints and timing analysis",
            "Open-source toolchain integration (Yosys, OpenROAD, Magic)",
            "Digital verification methodology with coverage goals"
          ],
          "workflow_sequence": [
            "1. Requirements gathering with digital ASIC focus",
            "2. Specification development for ASIC implementation",
            "3. Architecture design for digital ASIC flow",
            "4. RTL implementation with GF180 PDK considerations",
            "5. Digital testbench development and verification",
            "6. Synthesis validation with GF180 constraints",
            "7. Final validation and quality assurance"
          ],
          "benefits": [
            "Immediate start with proven technology stack",
            "No licensing or NDA delays",
            "Community support and documentation available",
            "Educational and research-friendly approach",
            "Path to production with open-source tools"
          ]
        }
      }
    },
    "ip_type_analysis": {
      "communication_protocols": {
        "uart": {
          "block_suggestions": [
            "uart_controller",
            "uart_interface",
            "uart_protocol"
          ],
          "module_suggestions": [
            "uart_transmitter",
            "uart_receiver",
            "uart_fifo",
            "uart_baud_gen",
            "uart_control"
          ],
          "file_examples": [
            "uart_controller_uart_transmitter.sv",
            "uart_controller_uart_receiver.sv",
            "uart_controller_uart_fifo.sv"
          ]
        },
        "spi": {
          "block_suggestions": [
            "spi_controller",
            "spi_interface",
            "spi_protocol"
          ],
          "module_suggestions": [
            "spi_master",
            "spi_slave",
            "spi_fifo",
            "spi_control",
            "spi_clock_gen"
          ],
          "file_examples": [
            "spi_controller_spi_master.sv",
            "spi_controller_spi_slave.sv",
            "spi_controller_spi_fifo.sv"
          ]
        },
        "i2c": {
          "block_suggestions": [
            "i2c_controller",
            "i2c_interface",
            "i2c_protocol"
          ],
          "module_suggestions": [
            "i2c_master",
            "i2c_slave",
            "i2c_fifo",
            "i2c_control",
            "i2c_clock_gen"
          ],
          "file_examples": [
            "i2c_controller_i2c_master.sv",
            "i2c_controller_i2c_slave.sv",
            "i2c_controller_i2c_fifo.sv"
          ]
        },
        "pcie": {
          "block_suggestions": [
            "pcie_phy",
            "pcie_controller",
            "pcie_interface"
          ],
          "module_suggestions": [
            "pcie_tx",
            "pcie_rx",
            "pcie_serdes",
            "pcie_control",
            "pcie_clock_gen"
          ],
          "file_examples": [
            "pcie_phy_pcie_tx.sv",
            "pcie_phy_pcie_rx.sv",
            "pcie_phy_pcie_serdes.sv"
          ]
        }
      },
      "memory_interfaces": {
        "ddr": {
          "block_suggestions": [
            "ddr_controller",
            "ddr_interface",
            "ddr_phy"
          ],
          "module_suggestions": [
            "ddr_command",
            "ddr_data_path",
            "ddr_control",
            "ddr_clock_gen",
            "ddr_timing"
          ],
          "file_examples": [
            "ddr_controller_ddr_command.sv",
            "ddr_controller_ddr_data_path.sv",
            "ddr_controller_ddr_control.sv"
          ]
        },
        "sram": {
          "block_suggestions": [
            "sram_controller",
            "sram_interface",
            "sram_memory"
          ],
          "module_suggestions": [
            "sram_control",
            "sram_data_path",
            "sram_address",
            "sram_timing"
          ],
          "file_examples": [
            "sram_controller_sram_control.sv",
            "sram_controller_sram_data_path.sv",
            "sram_controller_sram_address.sv"
          ]
        },
        "flash": {
          "block_suggestions": [
            "flash_controller",
            "flash_interface",
            "flash_protocol"
          ],
          "module_suggestions": [
            "flash_control",
            "flash_data_path",
            "flash_timing",
            "flash_erase",
            "flash_program"
          ],
          "file_examples": [
            "flash_controller_flash_control.sv",
            "flash_controller_flash_data_path.sv",
            "flash_controller_flash_timing.sv"
          ]
        }
      },
      "processing_units": {
        "cpu": {
          "block_suggestions": [
            "cpu_core",
            "cpu_processor",
            "cpu_unit"
          ],
          "module_suggestions": [
            "cpu_alu",
            "cpu_control",
            "cpu_registers",
            "cpu_memory",
            "cpu_pipeline"
          ],
          "file_examples": [
            "cpu_core_cpu_alu.sv",
            "cpu_core_cpu_control.sv",
            "cpu_core_cpu_registers.sv"
          ]
        },
        "dsp": {
          "block_suggestions": [
            "dsp_processor",
            "dsp_core",
            "dsp_unit"
          ],
          "module_suggestions": [
            "dsp_alu",
            "dsp_multiplier",
            "dsp_accumulator",
            "dsp_control",
            "dsp_memory"
          ],
          "file_examples": [
            "dsp_processor_dsp_alu.sv",
            "dsp_processor_dsp_multiplier.sv",
            "dsp_processor_dsp_accumulator.sv"
          ]
        },
        "gpu": {
          "block_suggestions": [
            "gpu_core",
            "gpu_processor",
            "gpu_unit"
          ],
          "module_suggestions": [
            "gpu_shader",
            "gpu_texture",
            "gpu_rasterizer",
            "gpu_memory",
            "gpu_control"
          ],
          "file_examples": [
            "gpu_core_gpu_shader.sv",
            "gpu_core_gpu_texture.sv",
            "gpu_core_gpu_rasterizer.sv"
          ]
        }
      },
      "analog_circuits": {
        "adc": {
          "block_suggestions": [
            "adc_converter",
            "adc_interface",
            "adc_system"
          ],
          "module_suggestions": [
            "adc_control",
            "adc_data_path",
            "adc_timing",
            "adc_calibration",
            "adc_reference"
          ],
          "file_examples": [
            "adc_converter_adc_control.sv",
            "adc_converter_adc_data_path.sv",
            "adc_converter_adc_timing.sv"
          ]
        },
        "dac": {
          "block_suggestions": [
            "dac_converter",
            "dac_interface",
            "dac_system"
          ],
          "module_suggestions": [
            "dac_control",
            "dac_data_path",
            "dac_timing",
            "dac_calibration",
            "dac_reference"
          ],
          "file_examples": [
            "dac_converter_dac_control.sv",
            "dac_converter_dac_data_path.sv",
            "dac_converter_dac_timing.sv"
          ]
        },
        "pll": {
          "block_suggestions": [
            "pll_generator",
            "pll_clock",
            "pll_system"
          ],
          "module_suggestions": [
            "pll_control",
            "pll_vco",
            "pll_divider",
            "pll_phase_detector",
            "pll_filter"
          ],
          "file_examples": [
            "pll_generator_pll_control.sv",
            "pll_generator_pll_vco.sv",
            "pll_generator_pll_divider.sv"
          ]
        }
      },
      "chiplet_interfaces": {
        "ucie": {
          "block_suggestions": [
            "ucie_interface",
            "ucie_protocol",
            "ucie_controller"
          ],
          "module_suggestions": [
            "ucie_tx",
            "ucie_rx",
            "ucie_control",
            "ucie_protocol_engine",
            "ucie_clock_gen"
          ],
          "file_examples": [
            "ucie_interface_ucie_tx.sv",
            "ucie_interface_ucie_rx.sv",
            "ucie_interface_ucie_control.sv"
          ]
        },
        "bow": {
          "block_suggestions": [
            "bow_interface",
            "bow_protocol",
            "bow_controller"
          ],
          "module_suggestions": [
            "bow_tx",
            "bow_rx",
            "bow_control",
            "bow_protocol_engine",
            "bow_clock_gen"
          ],
          "file_examples": [
            "bow_interface_bow_tx.sv",
            "bow_interface_bow_rx.sv",
            "bow_interface_bow_control.sv"
          ]
        }
      }
    },
    "naming_validation": {
      "vyges_conventions": {
        "block_naming": "lowercase with hyphens/underscores, 3-50 chars, start with letter, no consecutive hyphens/underscores",
        "file_naming": "{block_name}_{document_type}.md for documentation consistency",
        "namespace_safety": "Use {block_name}_ prefix for all documents to prevent conflicts and maintain organization"
      },
      "validation_checks": [
        "Block name follows Vyges repository naming conventions",
        "Document names use consistent {block_name}_ prefix",
        "Document types are clearly identified (requirements, specification, architecture, design)",
        "File structure follows Vyges documentation standards",
        "Requirements are stored in raw format for evolution tracking"
      ]
    },
    "ai_prompts": {
      "suggest_block_name": "Based on the IP type '{ip_type}' and functionality '{functionality}', suggest appropriate block names following Vyges conventions. Include document structure examples.",
      "create_document_structure": "Create the document structure for {block_name} including requirements, specification, architecture, and design documents with proper naming.",
      "store_requirements": "Store the original user requirements for {block_name} in raw format to track IP evolution from requirements to implementation.",
      "prepare_specification_phase": "Prepare for specification development for {block_name} based on the stored requirements and user input."
    },
    "example_workflow": {
      "user_input": "Develop a design and architecture specification for UART Controller IP using Vyges Conventions",
      "ai_response": [
        "1. Current date: $(date -u +%Y-%m-%dT%H:%M:%SZ)",
        "2. IP Analysis: UART Controller for serial communication",
        "3. Block Name Suggestions: uart_controller, uart_interface, uart_protocol",
        "4. Recommended: uart_controller as block name for clarity and consistency",
        "5. Document Structure:",
        "   - docs/uart_controller_requirements.md (store original requirements)",
        "   - docs/uart_controller_specification.md (functional specifications)",
        "   - docs/uart_controller_architecture.md (high-level architecture)",
        "   - docs/uart_controller_design.md (detailed design)",
        "6. Next Steps: Store requirements and begin specification development",
        "7. Module names will be determined after specification and architecture are complete"
      ]
    },
    "evolution_tracking": {
      "description": "Track how IP evolves from initial requirements to final implementation",
      "tracking_benefits": [
        "Trace requirements changes and decisions",
        "Document design evolution and trade-offs",
        "Maintain audit trail for compliance",
        "Support team collaboration and handoffs",
        "Enable IP reuse and adaptation"
      ],
      "tracking_phases": {
        "requirements": "Raw user input and initial needs",
        "specification": "Functional requirements and interface definitions",
        "architecture": "High-level design decisions and system structure",
        "design": "Detailed implementation and RTL organization",
        "implementation": "Actual code and verification",
        "validation": "Testing results and compliance verification"
      }
    },
    "metadata_update_checks": {
      "description": "Check and update vyges-metadata.json after each workflow step to maintain consistency",
      "critical_requirement": "After each major step in IP development, check if vyges-metadata.json needs updates",
      "update_triggers": {
        "requirements_phase": {
          "description": "After storing user requirements and creating document structure",
          "metadata_updates": [
            "Update created/updated timestamps",
            "Add requirements document references",
            "Update project status to 'requirements_gathered'",
            "Add initial IP description and type"
          ],
          "check_command": "Check if vyges-metadata.json reflects new requirements and document structure"
        },
        "specification_phase": {
          "description": "After completing functional specification",
          "metadata_updates": [
            "Update specification document references",
            "Add interface definitions and parameters",
            "Update project status to 'specification_complete'",
            "Add functional requirements and constraints"
          ],
          "check_command": "Check if vyges-metadata.json includes specification details and interface definitions"
        },
        "architecture_phase": {
          "description": "After completing high-level architecture",
          "metadata_updates": [
            "Update architecture document references",
            "Add system-level design decisions",
            "Update project status to 'architecture_complete'",
            "Add architectural constraints and trade-offs"
          ],
          "check_command": "Check if vyges-metadata.json reflects architectural decisions and system structure"
        },
        "design_phase": {
          "description": "After completing detailed design and RTL structure",
          "metadata_updates": [
            "Update design document references",
            "Add module definitions and hierarchy",
            "Update project status to 'design_complete'",
            "Add RTL structure and implementation details"
          ],
          "check_command": "Check if vyges-metadata.json includes module definitions and RTL structure"
        },
        "rtl_implementation_phase": {
          "description": "After completing RTL implementation",
          "metadata_updates": [
            "Update RTL implementation status",
            "Add RTL file references and module implementations",
            "Update project status to 'rtl_implementation_complete'",
            "Add implementation details and code structure"
          ],
          "check_command": "Check if vyges-metadata.json reflects RTL implementation status and code structure"
        },
        "testbench_development_phase": {
          "description": "After completing testbench development and verification",
          "metadata_updates": [
            "Update testbench references and coverage goals",
            "Add verification methodology and test results",
            "Update project status to 'testbench_complete'",
            "Add SystemVerilog and Python Cocotb testbench details"
          ],
          "check_command": "Check if vyges-metadata.json includes testbench details and verification approach"
        },
        "synthesis_validation_phase": {
          "description": "After completing synthesis validation and timing analysis",
          "metadata_updates": [
            "Update synthesis results and timing reports",
            "Add area and power analysis results",
            "Update project status to 'synthesis_validated'",
            "Add synthesis constraints and optimization results"
          ],
          "check_command": "Check if vyges-metadata.json reflects synthesis validation results and constraints"
        },
        "validation_phase": {
          "description": "After completing testing and validation",
          "metadata_updates": [
            "Update validation results and coverage metrics",
            "Add compliance verification status",
            "Update project status to 'validation_complete'",
            "Add quality metrics and readiness assessment"
          ],
          "check_command": "Check if vyges-metadata.json includes validation results and quality metrics"
        }
      },
      "metadata_update_workflow": [
        "1. Complete workflow step",
        "2. Identify metadata fields that need updates",
        "3. Check current vyges-metadata.json content",
        "4. Update relevant metadata fields",
        "5. Update timestamps (updated field)",
        "6. Validate metadata.json syntax and structure",
        "7. Commit metadata updates with descriptive message"
      ],
      "ai_prompts": {
        "check_metadata_updates": "After completing {workflow_step}, check if vyges-metadata.json needs updates and provide specific update recommendations.",
        "update_metadata": "Update vyges-metadata.json for {workflow_step} with {specific_updates} and validate the changes.",
        "validate_metadata": "Validate that vyges-metadata.json is consistent with current project state after {workflow_step}.",
        "metadata_sync": "Ensure vyges-metadata.json is synchronized with {project_artifacts} and {current_status}."
      },
      "benefits": [
        "Maintain metadata consistency throughout development",
        "Enable automated tools to track project progress",
        "Support catalog integration and discovery",
        "Provide audit trail for compliance and quality assurance",
        "Enable team collaboration with current project status"
      ]
    }
  },
  "_merge_info": {
    "description": "Comprehensive Vyges AI context merged from all modular context files",
    "merge_timestamp": "/Users/smysore/shiva/github/vyges/vyges-ip-internal/ai_context",
    "source_files": [
      "vyges-core-context.json",
      "vyges-standards-context.json",
      "vyges-rtl-context.json",
      "vyges-testbench-context.json",
      "vyges-synthesis-context.json",
      "vyges-analog-context.json",
      "vyges-chiplet-context.json",
      "vyges-security-context.json",
      "vyges-catalog-context.json",
      "vyges-ai-workflow-context.json"
    ],
    "total_files_processed": 10,
    "merge_script": "comprehensive-merge.py"
  }
}